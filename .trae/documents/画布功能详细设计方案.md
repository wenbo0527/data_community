# 画布功能详细设计方案

## 功能1：连接线删除与预览线恢复

### 1.1 功能概述
实现连接线的右键删除功能，删除后自动恢复上游节点的预览线，确保用户体验的连贯性。

### 1.2 技术实现方案

#### 1.2.1 核心组件修改

**TaskFlowCanvas.vue 增强**
```javascript
// 添加连接线右键菜单
const setupConnectionContextMenu = () => {
  graph.on('edge:contextmenu', ({ e, edge }) => {
    e.preventDefault()
    
    // 检查是否为真实连接线（非预览线）
    const edgeData = edge.getData()
    if (edgeData?.isPreviewLine) return
    
    showConnectionContextMenu({
      x: e.clientX,
      y: e.clientY,
      connectionId: edge.id,
      sourceNodeId: edge.getSourceCellId(),
      targetNodeId: edge.getTargetCellId()
    })
  })
}

// 删除连接线处理函数
const handleDeleteConnection = async (connectionInfo) => {
  try {
    const { connectionId, sourceNodeId, targetNodeId } = connectionInfo
    
    // 1. 从图形中移除连接线
    const edge = graph.getCellById(connectionId)
    if (edge) {
      graph.removeCell(edge)
    }
    
    // 2. 从数据数组中移除
    const connectionIndex = connections.value.findIndex(conn => conn.id === connectionId)
    if (connectionIndex !== -1) {
      connections.value.splice(connectionIndex, 1)
    }
    
    // 3. 检查源节点是否需要恢复预览线
    await restoreSourceNodePreviewLine(sourceNodeId)
    
    // 4. 触发画布变更事件
    emit('connection-deleted', { connectionId, sourceNodeId, targetNodeId })
    
    Message.success('连接线删除成功')
  } catch (error) {
    console.error('删除连接线失败:', error)
    Message.error('删除连接线失败')
  }
}

// 恢复源节点预览线
const restoreSourceNodePreviewLine = async (sourceNodeId) => {
  const sourceNode = graph.getCellById(sourceNodeId)
  if (!sourceNode) return
  
  const nodeData = sourceNode.getData()
  
  // 检查节点是否已配置且没有其他出向连接
  const hasOtherConnections = connections.value.some(conn => 
    conn.source === sourceNodeId && graph.getCellById(conn.id)
  )
  
  if (nodeData?.isConfigured && !hasOtherConnections) {
    // 使用预览线管理器恢复预览线
    if (window.unifiedPreviewLineManager) {
      await window.unifiedPreviewLineManager.regeneratePreviewLineForNode(sourceNodeId)
    }
  }
}
```

#### 1.2.2 右键菜单组件

**ConnectionContextMenu.vue**
```vue
<template>
  <div 
    v-if="visible" 
    class="connection-context-menu"
    :style="{ left: position.x + 'px', top: position.y + 'px' }"
  >
    <div class="menu-item" @click="handleDelete">
      <icon-delete />
      删除连接线
    </div>
    <div class="menu-item" @click="handleEdit">
      <icon-edit />
      编辑连接线
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
import { IconDelete, IconEdit } from '@arco-design/web-vue/es/icon'

const props = defineProps({
  visible: Boolean,
  position: Object,
  connectionInfo: Object
})

const emit = defineEmits(['delete', 'edit', 'close'])

const handleDelete = () => {
  emit('delete', props.connectionInfo)
  emit('close')
}

const handleEdit = () => {
  emit('edit', props.connectionInfo)
  emit('close')
}

// 点击外部关闭菜单
const handleClickOutside = (e) => {
  if (!e.target.closest('.connection-context-menu')) {
    emit('close')
  }
}

onMounted(() => {
  document.addEventListener('click', handleClickOutside)
})

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside)
})
</script>
```

### 1.3 预览线恢复逻辑

```javascript
// UnifiedPreviewLineManager.js 增强
class UnifiedPreviewLineManager {
  // 处理连接线删除后的预览线恢复
  async handleConnectionDeleted(connectionInfo) {
    const { sourceNodeId, targetNodeId } = connectionInfo
    
    // 检查源节点是否需要恢复预览线
    const sourceNode = this.graph.getCellById(sourceNodeId)
    if (sourceNode && this.shouldRestorePreviewLine(sourceNodeId)) {
      await this.regeneratePreviewLineForNode(sourceNodeId)
    }
  }
  
  // 判断是否应该恢复预览线
  shouldRestorePreviewLine(nodeId) {
    const node = this.graph.getCellById(nodeId)
    if (!node) return false
    
    const nodeData = node.getData()
    
    // 节点必须已配置
    if (!nodeData?.isConfigured) return false
    
    // 检查是否还有其他出向连接
    const hasOutgoingConnections = this.graph.getOutgoingEdges(node)
      .some(edge => !edge.getData()?.isPreviewLine)
    
    return !hasOutgoingConnections
  }
}
```

## 功能2：画布查询与统计模式

### 2.1 功能概述
在画布列表页面增加查询模式和统计模式，支持基于客户ID的用户行为查询和基于日期的节点执行统计。

### 2.2 查询和统计模式实现机制（前端Mock）

**Mock数据生成器**
- `StatisticsMockGenerator`: 核心mock数据生成类
- `UserBehaviorMocker`: 用户行为数据模拟器
- `NodePerformanceMocker`: 节点性能数据模拟器
- `CanvasAnalyticsMocker`: 画布分析数据模拟器

**前端展示组件**
- `StatisticsModePanel`: 统计模式主面板（使用mock数据）
- `UserBehaviorChart`: 用户行为可视化图表
- `NodePerformanceChart`: 节点性能统计图表
- `QueryInterface`: 查询条件设置界面

**Mock数据查询流程**
1. 用户设置查询条件（时间范围、节点类型等）
2. 前端调用mock数据生成器生成模拟数据
3. 数据处理和图表渲染（与真实数据展示效果一致）
4. 支持模拟数据导出和报告生成

**技术实现要点**
- 使用定时器模拟实时数据更新
- 采用Chart.js或ECharts进行数据可视化
- 实现本地缓存机制存储mock数据
- 支持多维度数据筛选和聚合（基于mock数据）
- Mock数据具有真实性和合理性，包含随机波动和趋势变化

### 2.3 技术实现方案

#### 2.2.1 画布列表页面增强

**TaskList.vue 修改**
```vue
<template>
  <div class="task-list-container">
    <!-- 模式切换标签 -->
    <a-tabs v-model:active-key="activeMode" @change="handleModeChange">
      <a-tab-pane key="list" title="画布列表">
        <!-- 原有列表内容 -->
      </a-tab-pane>
      <a-tab-pane key="query" title="查询模式">
        <QueryModePanel @query="handleUserQuery" />
      </a-tab-pane>
      <a-tab-pane key="statistics" title="统计模式">
        <StatisticsModePanel @query="handleStatisticsQuery" />
      </a-tab-pane>
    </a-tabs>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import QueryModePanel from './components/QueryModePanel.vue'
import StatisticsModePanel from './components/StatisticsModePanel.vue'

const activeMode = ref('list')

const handleModeChange = (mode) => {
  console.log('切换到模式:', mode)
}

const handleUserQuery = async (queryParams) => {
  // 处理用户行为查询
}

const handleStatisticsQuery = async (queryParams) => {
  // 处理统计查询
}
</script>
```

#### 2.2.2 查询模式面板

**QueryModePanel.vue**
```vue
<template>
  <div class="query-mode-panel">
    <a-card title="用户行为查询">
      <a-form :model="queryForm" layout="inline">
        <a-form-item label="画布选择">
          <a-select 
            v-model="queryForm.canvasId" 
            placeholder="选择画布"
            style="width: 200px"
          >
            <a-option 
              v-for="canvas in publishedCanvases" 
              :key="canvas.id" 
              :value="canvas.id"
            >
              {{ canvas.name }}
            </a-option>
          </a-select>
        </a-form-item>
        
        <a-form-item label="版本选择">
          <a-select 
            v-model="queryForm.version" 
            placeholder="选择版本"
            style="width: 120px"
          >
            <a-option 
              v-for="version in canvasVersions" 
              :key="version.id" 
              :value="version.versionNumber"
            >
              {{ version.versionNumber }}
            </a-option>
          </a-select>
        </a-form-item>
        
        <a-form-item label="客户ID">
          <a-input 
            v-model="queryForm.userId" 
            placeholder="输入客户ID"
            style="width: 200px"
          />
        </a-form-item>
        
        <a-form-item label="日期范围">
          <a-range-picker 
            v-model="queryForm.dateRange" 
            style="width: 300px"
          />
        </a-form-item>
        
        <a-form-item>
          <a-button type="primary" @click="handleQuery" :loading="loading">
            查询
          </a-button>
        </a-form-item>
      </a-form>
      
      <!-- 查询结果展示 -->
      <div v-if="queryResult" class="query-result">
        <UserBehaviorFlow :data="queryResult" />
      </div>
    </a-card>
  </div>
</template>

<script setup>
import { ref, reactive, watch } from 'vue'
import { getUserBehavior } from '@/api/canvas'
import UserBehaviorFlow from './UserBehaviorFlow.vue'

const emit = defineEmits(['query'])

const loading = ref(false)
const publishedCanvases = ref([])
const canvasVersions = ref([])
const queryResult = ref(null)

const queryForm = reactive({
  canvasId: '',
  version: '',
  userId: '',
  dateRange: []
})

// 监听画布选择变化，加载版本列表
watch(() => queryForm.canvasId, async (canvasId) => {
  if (canvasId) {
    canvasVersions.value = await loadCanvasVersions(canvasId)
  }
})

const handleQuery = async () => {
  if (!queryForm.canvasId || !queryForm.userId) {
    Message.error('请选择画布并输入客户ID')
    return
  }
  
  loading.value = true
  try {
    const result = await getUserBehavior({
      canvasId: queryForm.canvasId,
      userId: queryForm.userId,
      version: queryForm.version,
      startDate: queryForm.dateRange[0],
      endDate: queryForm.dateRange[1]
    })
    
    queryResult.value = result
    emit('query', result)
  } catch (error) {
    Message.error('查询失败')
  } finally {
    loading.value = false
  }
}
</script>
```

#### 2.2.3 统计模式面板

**StatisticsModePanel.vue**
```vue
<template>
  <div class="statistics-mode-panel">
    <a-card title="节点执行统计">
      <a-form :model="statsForm" layout="inline">
        <a-form-item label="画布选择">
          <a-select 
            v-model="statsForm.canvasId" 
            placeholder="选择画布"
            style="width: 200px"
          >
            <a-option 
              v-for="canvas in publishedCanvases" 
              :key="canvas.id" 
              :value="canvas.id"
            >
              {{ canvas.name }}
            </a-option>
          </a-select>
        </a-form-item>
        
        <a-form-item label="统计日期">
          <a-range-picker 
            v-model="statsForm.dateRange" 
            style="width: 300px"
          />
        </a-form-item>
        
        <a-form-item label="版本对比">
          <a-checkbox-group v-model="statsForm.versions">
            <a-checkbox 
              v-for="version in canvasVersions" 
              :key="version.id" 
              :value="version.versionNumber"
            >
              {{ version.versionNumber }}
            </a-checkbox>
          </a-checkbox-group>
        </a-form-item>
        
        <a-form-item>
          <a-button type="primary" @click="handleQuery" :loading="loading">
            统计
          </a-button>
        </a-form-item>
      </a-form>
      
      <!-- 统计结果展示 -->
      <div v-if="statsResult" class="stats-result">
        <NodeExecutionStats :data="statsResult" />
      </div>
    </a-card>
  </div>
</template>
```

### 2.3 数据可视化组件

#### 2.3.1 用户行为流程图

**UserBehaviorFlow.vue**
```vue
<template>
  <div class="user-behavior-flow">
    <div class="flow-header">
      <h3>用户行为流程</h3>
      <div class="flow-stats">
        <span>总执行时长: {{ formatDuration(data.totalDuration) }}</span>
        <span>节点数: {{ data.userPath.length }}</span>
      </div>
    </div>
    
    <div class="flow-timeline">
      <div 
        v-for="(step, index) in data.userPath" 
        :key="index"
        class="timeline-item"
      >
        <div class="timeline-node">
          <div class="node-icon" :class="getNodeTypeClass(step.nodeType)">
            <component :is="getNodeIcon(step.nodeType)" />
          </div>
          <div class="node-info">
            <div class="node-name">{{ step.nodeName }}</div>
            <div class="node-time">{{ formatTime(step.executedAt) }}</div>
            <div class="node-duration">耗时: {{ formatDuration(step.duration) }}</div>
          </div>
        </div>
        
        <div v-if="index < data.userPath.length - 1" class="timeline-connector">
          <div class="connector-line"></div>
          <div class="connector-arrow">→</div>
        </div>
      </div>
    </div>
  </div>
</template>
```

#### 2.3.2 节点执行统计图表

**NodeExecutionStats.vue**
```vue
<template>
  <div class="node-execution-stats">
    <a-row :gutter="16">
      <a-col :span="12">
        <a-card title="节点执行次数">
          <div ref="executionChart" style="height: 300px"></div>
        </a-card>
      </a-col>
      
      <a-col :span="12">
        <a-card title="平均执行时长">
          <div ref="durationChart" style="height: 300px"></div>
        </a-card>
      </a-col>
    </a-row>
    
    <a-row :gutter="16" style="margin-top: 16px">
      <a-col :span="24">
        <a-card title="版本对比">
          <div ref="versionChart" style="height: 400px"></div>
        </a-card>
      </a-col>
    </a-row>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue'
import * as echarts from 'echarts'

const props = defineProps({
  data: Object
})

const executionChart = ref()
const durationChart = ref()
const versionChart = ref()

let executionChartInstance = null
let durationChartInstance = null
let versionChartInstance = null

onMounted(() => {
  initCharts()
})

watch(() => props.data, () => {
  updateCharts()
}, { deep: true })

const initCharts = () => {
  executionChartInstance = echarts.init(executionChart.value)
  durationChartInstance = echarts.init(durationChart.value)
  versionChartInstance = echarts.init(versionChart.value)
  
  updateCharts()
}

const updateCharts = () => {
  if (!props.data) return
  
  // 更新执行次数图表
  const executionOption = {
    title: { text: '节点执行次数统计' },
    xAxis: { 
      type: 'category',
      data: props.data.nodeStats.map(item => item.nodeName)
    },
    yAxis: { type: 'value' },
    series: [{
      type: 'bar',
      data: props.data.nodeStats.map(item => item.executionCount)
    }]
  }
  
  executionChartInstance.setOption(executionOption)
  
  // 更新执行时长图表
  const durationOption = {
    title: { text: '平均执行时长统计' },
    xAxis: { 
      type: 'category',
      data: props.data.nodeStats.map(item => item.nodeName)
    },
    yAxis: { type: 'value' },
    series: [{
      type: 'line',
      data: props.data.nodeStats.map(item => item.avgDuration)
    }]
  }
  
  durationChartInstance.setOption(durationOption)
}
</script>
```

## 功能3：关键节点撤销功能

### 3.1 功能概述
实现关键节点操作的精细化撤销功能，支持选择性撤销特定操作，而不影响其他操作。

### 3.2 技术实现方案

#### 3.2.1 操作历史管理器

**OperationHistoryManager.js**
```javascript
class OperationHistoryManager {
  constructor(canvas) {
    this.canvas = canvas
    this.operations = []
    this.maxHistorySize = 100
    this.keyNodeTypes = ['start', 'end', 'decision', 'audience-split']
  }
  
  // 记录操作
  recordOperation(operation) {
    const operationRecord = {
      id: this.generateOperationId(),
      type: operation.type,
      timestamp: Date.now(),
      nodeId: operation.nodeId,
      nodeType: operation.nodeType,
      beforeState: this.cloneState(operation.beforeState),
      afterState: this.cloneState(operation.afterState),
      isKeyNode: this.keyNodeTypes.includes(operation.nodeType),
      dependencies: this.findDependencies(operation),
      canUndo: true
    }
    
    this.operations.push(operationRecord)
    
    // 限制历史记录大小
    if (this.operations.length > this.maxHistorySize) {
      this.operations.shift()
    }
    
    this.notifyHistoryChanged()
  }
  
  // 查找操作依赖
  findDependencies(operation) {
    const dependencies = []
    
    // 查找依赖此操作的后续操作
    for (let i = this.operations.length - 1; i >= 0; i--) {
      const op = this.operations[i]
      if (this.isDependentOperation(operation, op)) {
        dependencies.push(op.id)
      }
    }
    
    return dependencies
  }
  
  // 判断操作依赖关系
  isDependentOperation(baseOp, checkOp) {
    // 连接操作依赖于节点创建
    if (checkOp.type === 'create_connection' && 
        (checkOp.sourceNodeId === baseOp.nodeId || checkOp.targetNodeId === baseOp.nodeId)) {
      return true
    }
    
    // 节点配置依赖于节点创建
    if (checkOp.type === 'configure_node' && checkOp.nodeId === baseOp.nodeId) {
      return true
    }
    
    return false
  }
  
  // 执行撤销操作
  async undoOperation(operationId) {
    const operation = this.operations.find(op => op.id === operationId)
    if (!operation || !operation.canUndo) {
      throw new Error('操作无法撤销')
    }
    
    // 检查依赖操作
    const dependentOps = this.findDependentOperations(operationId)
    if (dependentOps.length > 0) {
      const confirmed = await this.confirmUndoWithDependencies(operation, dependentOps)
      if (!confirmed) return false
    }
    
    // 执行撤销
    await this.executeUndo(operation)
    
    // 标记为已撤销
    operation.canUndo = false
    operation.undoneAt = Date.now()
    
    this.notifyHistoryChanged()
    return true
  }
  
  // 执行具体的撤销逻辑
  async executeUndo(operation) {
    switch (operation.type) {
      case 'create_node':
        await this.undoCreateNode(operation)
        break
      case 'delete_node':
        await this.undoDeleteNode(operation)
        break
      case 'configure_node':
        await this.undoConfigureNode(operation)
        break
      case 'create_connection':
        await this.undoCreateConnection(operation)
        break
      case 'delete_connection':
        await this.undoDeleteConnection(operation)
        break
    }
  }
  
  // 撤销节点创建
  async undoCreateNode(operation) {
    const node = this.canvas.graph.getCellById(operation.nodeId)
    if (node) {
      // 删除相关连接
      const edges = this.canvas.graph.getConnectedEdges(node)
      edges.forEach(edge => this.canvas.graph.removeCell(edge))
      
      // 删除节点
      this.canvas.graph.removeCell(node)
      
      // 从数据数组中移除
      const nodeIndex = this.canvas.nodes.findIndex(n => n.id === operation.nodeId)
      if (nodeIndex !== -1) {
        this.canvas.nodes.splice(nodeIndex, 1)
      }
    }
  }
  
  // 撤销节点配置
  async undoConfigureNode(operation) {
    const node = this.canvas.graph.getCellById(operation.nodeId)
    if (node) {
      // 恢复之前的配置状态
      node.setData(operation.beforeState.nodeData)
      
      // 更新本地数据
      const localNode = this.canvas.nodes.find(n => n.id === operation.nodeId)
      if (localNode) {
        Object.assign(localNode, operation.beforeState.localData)
      }
      
      // 重新生成预览线
      if (this.canvas.unifiedPreviewLineManager) {
        await this.canvas.unifiedPreviewLineManager.regeneratePreviewLineForNode(operation.nodeId)
      }
    }
  }
}
```

#### 3.2.2 撤销操作面板

**UndoOperationPanel.vue**
```vue
<template>
  <div class="undo-operation-panel">
    <a-drawer
      v-model:visible="visible"
      title="操作历史"
      width="400px"
      placement="right"
    >
      <div class="operation-filters">
        <a-checkbox-group v-model="filters.types">
          <a-checkbox value="create_node">创建节点</a-checkbox>
          <a-checkbox value="configure_node">配置节点</a-checkbox>
          <a-checkbox value="create_connection">创建连接</a-checkbox>
        </a-checkbox-group>
        
        <a-switch v-model="filters.keyNodesOnly">
          <template #checked>仅关键节点</template>
          <template #unchecked>所有操作</template>
        </a-switch>
      </div>
      
      <div class="operation-list">
        <div 
          v-for="operation in filteredOperations" 
          :key="operation.id"
          class="operation-item"
          :class="{ 
            'key-operation': operation.isKeyNode,
            'cannot-undo': !operation.canUndo
          }"
        >
          <div class="operation-header">
            <div class="operation-type">
              <component :is="getOperationIcon(operation.type)" />
              {{ getOperationLabel(operation.type) }}
            </div>
            <div class="operation-time">
              {{ formatTime(operation.timestamp) }}
            </div>
          </div>
          
          <div class="operation-details">
            <div class="node-info">
              <span class="node-type">{{ operation.nodeType }}</span>
              <span class="node-id">{{ operation.nodeId }}</span>
            </div>
            
            <div v-if="operation.dependencies.length > 0" class="dependencies">
              <a-tag size="small" color="orange">
                影响 {{ operation.dependencies.length }} 个操作
              </a-tag>
            </div>
          </div>
          
          <div class="operation-actions">
            <a-button 
              v-if="operation.canUndo"
              type="primary" 
              size="small"
              @click="handleUndo(operation)"
            >
              撤销
            </a-button>
            
            <a-button 
              size="small"
              @click="previewUndo(operation)"
            >
              预览
            </a-button>
          </div>
        </div>
      </div>
    </a-drawer>
    
    <!-- 撤销预览对话框 -->
    <UndoPreviewDialog 
      v-model:visible="previewVisible"
      :operation="previewOperation"
      @confirm="confirmUndo"
    />
  </div>
</template>

<script setup>
import { ref, computed, reactive } from 'vue'
import { Message } from '@arco-design/web-vue'
import UndoPreviewDialog from './UndoPreviewDialog.vue'

const props = defineProps({
  visible: Boolean,
  operations: Array
})

const emit = defineEmits(['update:visible', 'undo'])

const previewVisible = ref(false)
const previewOperation = ref(null)

const filters = reactive({
  types: ['create_node', 'configure_node', 'create_connection'],
  keyNodesOnly: false
})

const filteredOperations = computed(() => {
  return props.operations.filter(op => {
    if (!filters.types.includes(op.type)) return false
    if (filters.keyNodesOnly && !op.isKeyNode) return false
    return true
  })
})

const handleUndo = async (operation) => {
  try {
    await emit('undo', operation.id)
    Message.success('操作撤销成功')
  } catch (error) {
    Message.error('撤销失败: ' + error.message)
  }
}

const previewUndo = (operation) => {
  previewOperation.value = operation
  previewVisible.value = true
}

const confirmUndo = async () => {
  await handleUndo(previewOperation.value)
  previewVisible.value = false
}
</script>
```

## 功能4：画布版本管理

### 4.1 功能概述
实现画布的版本控制功能，支持版本创建、切换、对比和发布管理。

### 4.2 技术实现方案

#### 4.2.1 版本管理器

**CanvasVersionManager.js**
```javascript
class CanvasVersionManager {
  constructor(canvasId) {
    this.canvasId = canvasId
    this.currentVersion = null
    this.versions = []
    this.versionHistory = []
  }
  
  // 创建新版本
  async createVersion(baseVersionId, description = '') {
    const baseVersion = await this.getVersion(baseVersionId)
    if (!baseVersion) {
      throw new Error('基础版本不存在')
    }
    
    const newVersionNumber = this.generateVersionNumber(baseVersion.versionNumber)
    
    const newVersion = {
      id: this.generateVersionId(),
      canvasId: this.canvasId,
      versionNumber: newVersionNumber,
      description,
      canvasData: this.cloneCanvasData(baseVersion.canvasData),
      isPublished: false,
      createdAt: new Date().toISOString(),
      createdBy: this.getCurrentUserId()
    }
    
    // 保存到后端
    await this.saveVersion(newVersion)
    
    this.versions.push(newVersion)
    this.currentVersion = newVersion
    
    return newVersion
  }
  
  // 生成版本号
  generateVersionNumber(baseVersion) {
    const [major, minor, patch] = baseVersion.split('.').map(Number)
    
    // 自动递增次版本号
    return `${major}.${minor + 1}.0`
  }
  
  // 切换版本
  async switchVersion(versionId) {
    const version = await this.getVersion(versionId)
    if (!version) {
      throw new Error('版本不存在')
    }
    
    // 检查当前版本是否有未保存的更改
    if (this.hasUnsavedChanges()) {
      const confirmed = await this.confirmSwitchWithUnsavedChanges()
      if (!confirmed) return false
    }
    
    // 加载版本数据
    await this.loadVersionData(version)
    
    this.currentVersion = version
    
    // 触发版本切换事件
    this.emit('version-switched', version)
    
    return true
  }
  
  // 发布版本
  async publishVersion(versionId) {
    const version = await this.getVersion(versionId)
    if (!version) {
      throw new Error('版本不存在')
    }
    
    // 验证版本数据完整性
    const validation = await this.validateVersionForPublish(version)
    if (!validation.isValid) {
      throw new Error('版本数据不完整: ' + validation.errors.join(', '))
    }
    
    // 标记为已发布
    version.isPublished = true
    version.publishedAt = new Date().toISOString()
    version.publishedBy = this.getCurrentUserId()
    
    await this.saveVersion(version)
    
    // 触发发布事件
    this.emit('version-published', version)
    
    return version
  }
  
  // 版本对比
  async compareVersions(versionId1, versionId2) {
    const version1 = await this.getVersion(versionId1)
    const version2 = await this.getVersion(versionId2)
    
    if (!version1 || !version2) {
      throw new Error('版本不存在')
    }
    
    const comparison = {
      version1: version1.versionNumber,
      version2: version2.versionNumber,
      differences: this.calculateDifferences(version1.canvasData, version2.canvasData)
    }
    
    return comparison
  }
  
  // 计算版本差异
  calculateDifferences(data1, data2) {
    const differences = {
      nodes: {
        added: [],
        removed: [],
        modified: []
      },
      connections: {
        added: [],
        removed: [],
        modified: []
      }
    }
    
    // 比较节点
    const nodes1Map = new Map(data1.nodes.map(n => [n.id, n]))
    const nodes2Map = new Map(data2.nodes.map(n => [n.id, n]))
    
    // 查找新增和修改的节点
    data2.nodes.forEach(node => {
      const oldNode = nodes1Map.get(node.id)
      if (!oldNode) {
        differences.nodes.added.push(node)
      } else if (!this.isNodeEqual(oldNode, node)) {
        differences.nodes.modified.push({
          id: node.id,
          before: oldNode,
          after: node
        })
      }
    })
    
    // 查找删除的节点
    data1.nodes.forEach(node => {
      if (!nodes2Map.has(node.id)) {
        differences.nodes.removed.push(node)
      }
    })
    
    // 类似地比较连接
    // ...
    
    return differences
  }
}
```

#### 4.2.2 版本控制组件

**VersionControlBar.vue**
```vue
<template>
  <div class="version-control-bar">
    <div class="version-info">
      <a-select 
        v-model="currentVersionId"
        style="width: 150px"
        @change="handleVersionChange"
      >
        <a-option 
          v-for="version in versions" 
          :key="version.id" 
          :value="version.id"
        >
          <div class="version-option">
            <span class="version-number">{{ version.versionNumber }}</span>
            <a-tag v-if="version.isPublished" color="green" size="small">
              已发布
            </a-tag>
          </div>
        </a-option>
      </a-select>
      
      <a-button-group>
        <a-button @click="showVersionHistory">
          <icon-history />
          历史
        </a-button>
        
        <a-button @click="showVersionComparison">
          <icon-diff />
          对比
        </a-button>
        
        <a-button type="primary" @click="createNewVersion">
          <icon-plus />
          新版本
        </a-button>
      </a-button-group>
    </div>
    
    <div class="version-actions">
      <a-button 
        v-if="!currentVersion?.isPublished"
        type="primary"
        @click="publishVersion"
      >
        发布版本
      </a-button>
    </div>
    
    <!-- 版本历史对话框 -->
    <VersionHistoryDialog 
      v-model:visible="historyVisible"
      :versions="versions"
      @switch="handleVersionSwitch"
    />
    
    <!-- 版本对比对话框 -->
    <VersionComparisonDialog 
      v-model:visible="comparisonVisible"
      :versions="versions"
      @compare="handleVersionCompare"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { Message } from '@arco-design/web-vue'
import { IconHistory, IconDiff, IconPlus } from '@arco-design/web-vue/es/icon'
import VersionHistoryDialog from './VersionHistoryDialog.vue'
import VersionComparisonDialog from './VersionComparisonDialog.vue'

const props = defineProps({
  canvasId: String
})

const emit = defineEmits(['version-changed', 'version-published'])

const versions = ref([])
const currentVersionId = ref('')
const historyVisible = ref(false)
const comparisonVisible = ref(false)

const currentVersion = computed(() => {
  return versions.value.find(v => v.id === currentVersionId.value)
})

onMounted(async () => {
  await loadVersions()
})

const loadVersions = async () => {
  try {
    const response = await getCanvasVersions(props.canvasId)
    versions.value = response.data
    
    // 设置当前版本为最新版本
    if (versions.value.length > 0) {
      currentVersionId.value = versions.value[0].id
    }
  } catch (error) {
    Message.error('加载版本列表失败')
  }
}

const handleVersionChange = async (versionId) => {
  try {
    await switchCanvasVersion(props.canvasId, versionId)
    emit('version-changed', versionId)
    Message.success('版本切换成功')
  } catch (error) {
    Message.error('版本切换失败')
    // 恢复之前的选择
    currentVersionId.value = currentVersion.value?.id
  }
}

const createNewVersion = async () => {
  try {
    const newVersion = await createCanvasVersion({
      canvasId: props.canvasId,
      baseVersionId: currentVersionId.value,
      description: '基于 ' + currentVersion.value?.versionNumber + ' 创建'
    })
    
    versions.value.unshift(newVersion)
    currentVersionId.value = newVersion.id
    
    Message.success('新版本创建成功')
  } catch (error) {
    Message.error('创建版本失败')
  }
}

const publishVersion = async () => {
  try {
    await publishCanvasVersion(props.canvasId, currentVersionId.value)
    
    // 更新本地版本状态
    const version = versions.value.find(v => v.id === currentVersionId.value)
    if (version) {
      version.isPublished = true
      version.publishedAt = new Date().toISOString()
    }
    
    emit('version-published', currentVersionId.value)
    Message.success('版本发布成功')
  } catch (error) {
    Message.error('版本发布失败')
  }
}
</script>
```

## 功能5：预览线颜色统一

### 5.1 功能概述
统一所有预览线的颜色和样式，提供一致的视觉体验。

### 5.2 技术实现方案

#### 5.2.1 预览线样式管理

**PreviewLineStyleManager.js**
```javascript
class PreviewLineStyleManager {
  constructor() {
    this.defaultStyle = {
      stroke: '#1890ff',
      strokeWidth: 2,
      strokeDasharray: '5,5',
      opacity: 0.8,
      targetMarker: {
        name: 'arrow',
        size: 8,
        fill: '#1890ff'
      }
    }
    
    this.customStyles = new Map()
  }
  
  // 获取预览线样式
  getPreviewLineStyle(nodeType = 'default', branchId = null) {
    // 所有预览线使用统一样式
    return { ...this.defaultStyle }
  }
  
  // 设置全局预览线样式
  setGlobalPreviewLineStyle(style) {
    Object.assign(this.defaultStyle, style)
    
    // 更新所有现有预览线的样式
    this.updateAllPreviewLineStyles()
  }
  
  // 更新所有预览线样式
  updateAllPreviewLineStyles() {
    if (window.unifiedPreviewLineManager) {
      window.unifiedPreviewLineManager.updateAllPreviewLineStyles(this.defaultStyle)
    }
  }
  
  // 应用样式到边
  applyStyleToEdge(edge) {
    const style = this.getPreviewLineStyle()
    
    edge.setAttrs({
      line: {
        stroke: style.stroke,
        strokeWidth: style.strokeWidth,
        strokeDasharray: style.strokeDasharray,
        opacity: style.opacity
      }
    })
    
    // 设置箭头样式
    if (style.targetMarker) {
      edge.setAttrs({
        line: {
          targetMarker: {
            name: style.targetMarker.name,
            size: style.targetMarker.size,
            fill: style.targetMarker.fill
          }
        }
      })
    }
  }
}
```

#### 5.2.2 UnifiedPreviewLineManager 样式增强

```javascript
// 在 UnifiedPreviewLineManager.js 中添加样式管理方法
class UnifiedPreviewLineManager {
  constructor(graph, options = {}) {
    // ... 现有构造函数代码
    
    // 初始化样式管理器
    this.styleManager = new PreviewLineStyleManager()
  }
  
  // 创建预览线时应用统一样式
  async createUnifiedPreviewLine(sourceNodeId, targetPosition, options = {}) {
    // ... 现有创建逻辑
    
    // 应用统一样式
    if (previewEdge) {
      this.styleManager.applyStyleToEdge(previewEdge)
    }
    
    return previewEdge
  }
  
  // 更新所有预览线样式
  updateAllPreviewLineStyles(newStyle) {
    const allEdges = this.graph.getEdges()
    
    allEdges.forEach(edge => {
      const edgeData = edge.getData()
      if (edgeData?.isPreviewLine || edgeData?.isUnifiedPreview) {
        this.styleManager.applyStyleToEdge(edge)
      }
    })
  }
  
  // 设置预览线样式
  setPreviewLineStyle(style) {
    this.styleManager.setGlobalPreviewLineStyle(style)
  }
}
```

#### 5.2.3 样式配置组件

**PreviewLineStyleConfig.vue**
```vue
<template>
  <div class="preview-line-style-config">
    <a-card title="预览线样式配置" size="small">
      <a-form :model="styleForm" layout="vertical">
        <a-form-item label="线条颜色">
          <a-input 
            v-model="styleForm.stroke" 
            type="color"
            style="width: 100px"
          />
        </a-form-item>
        
        <a-form-item label="线条宽度">
          <a-slider 
            v-model="styleForm.strokeWidth"
            :min="1"
            :max="5"
            :step="1"
          />
        </a-form-item>
        
        <a-form-item label="透明度">
          <a-slider 
            v-model="styleForm.opacity"
            :min="0.1"
            :max="1"
            :step="0.1"
          />
        </a-form-item>
        
        <a-form-item label="虚线样式">
          <a-select v-model="styleForm.strokeDasharray">
            <a-option value="">实线</a-option>
            <a-option value="5,5">短虚线</a-option>
            <a-option value="10,5">长虚线</a-option>
            <a-option value="5,5,1,5">点划线</a-option>
          </a-select>
        </a-form-item>
        
        <a-form-item>
          <a-space>
            <a-button type="primary" @click="applyStyle">
              应用样式
            </a-button>
            <a-button @click="resetStyle">
              重置
            </a-button>
            <a-button @click="previewStyle">
              预览
            </a-button>
          </a-space>
        </a-form-item>
      </a-form>
      
      <!-- 样式预览 -->
      <div class="style-preview">
        <svg width="200" height="50">
          <line 
            x1="10" 
            y1="25" 
            x2="190" 
            y2="25"
            :stroke="styleForm.stroke"
            :stroke-width="styleForm.strokeWidth"
            :stroke-dasharray="styleForm.strokeDasharray"
            :opacity="styleForm.opacity"
            marker-end="url(#arrow)"
          />
          <defs>
            <marker 
              id="arrow" 
              markerWidth="10" 
              markerHeight="10" 
              refX="9" 
              refY="3" 
              orient="auto" 
              markerUnits="strokeWidth"
            >
              <path 
                d="M0,0 L0,6 L9,3 z" 
                :fill="styleForm.stroke"
              />
            </marker>
          </defs>
        </svg>
      </div>
    </a-card>
  </div>
</template>

<script setup>
import { ref, reactive } from 'vue'
import { Message } from '@arco-design/web-vue'

const emit = defineEmits(['style-changed'])

const styleForm = reactive({
  stroke: '#1890ff',
  strokeWidth: 2,
  strokeDasharray: '5,5',
  opacity: 0.8
})

const defaultStyle = { ...styleForm }

const applyStyle = () => {
  // 应用样式到预览线管理器
  if (window.unifiedPreviewLineManager) {
    window.unifiedPreviewLineManager.setPreviewLineStyle(styleForm)
    Message.success('预览线样式已更新')
    emit('style-changed', styleForm)
  }
}

const resetStyle = () => {
  Object.assign(styleForm, defaultStyle)
}

const previewStyle = () => {
  // 临时应用样式进行预览
  Message.info('样式预览已应用，点击应用样式保存更改')
}
</script>

<style scoped>
.style-preview {
  margin-top: 16px;
  padding: 16px;
  background: #f5f5f5;
  border-radius: 4px;
}
</style>
```

### 5.3 集成到画布编辑器

在TaskFlowCanvas.vue中集成样式配置：

```vue
<template>
  <div class="task-flow-canvas">
    <!-- 现有画布内容 -->
    
    <!-- 样式配置面板 -->
    <a-drawer
      v-model:visible="styleConfigVisible"
      title="预览线样式"
      width="300px"
      placement="right"
    >
      <PreviewLineStyleConfig @style-changed="handleStyleChanged" />
    </a-drawer>
    
    <!-- 工具栏添加样式按钮 -->
    <div class="canvas-toolbar">
      <!-- 现有工具按钮 -->
      <a-button @click="styleConfigVisible = true">
        <icon-palette />
        样式
      </a-button>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import PreviewLineStyleConfig from './PreviewLineStyleConfig.vue'

const styleConfigVisible = ref(false)

const handleStyleChanged = (newStyle) => {
  console.log('预览线样式已更新:', newStyle)
  // 可以在这里保存样式配置到本地存储或后端
}
</script>
```

## 总结

本设计方案详细描述了5个画布功能增强的技术实现方案：

1. **连接线删除与预览线恢复**：通过右键菜单实现连接线删除，自动检测并恢复上游节点的预览线
2. **查询与统计模式**：新增用户行为查询和节点执行统计功能，支持多版本数据对比
3. **关键节点撤销**：实现精细化的操作历史管理和选择性撤销功能
4. **版本管理**：完整的版本控制系统，支持版本创建、切换、对比和发布
5. **预览线样式统一**：统一预览线的视觉表现，提供样式配置界面

所有功能都基于现有的Vue 3 + AntV X6架构，确保与现有系统的兼容性和一致性。