## 问题定位
- 横向几乎贴合：`colSpacing` 小于节点最大宽度，导致相邻列视觉贴合。
- 纵向同一水平线：右→左回推时兄弟分支被回推到同一 `laneId`，因为仅以叶子为种子；中间层的兄弟缺少独立车道种子，合流多数规则将其合并。

## 改造目标
- 保持连线约束不变：`router: 'normal'` + `connector: 'smooth'`，不写 `edge.vertices`。
- 解决两类挤压：
  1) 动态列间距：`colSpacing >= maxNodeWidth + hGap`；
  2) 兄弟车道独立：对“首层分支头”建立车道种子，保护不被多数回推覆盖。

## 实施方案
### 1) 动态间距计算
- 遍历所有节点 `bbox.width/height`，计算 `maxW/maxH`。
- 设定：
  - `colSpacing = Math.max(config.colSpacing || 280, maxW + 40)`；
  - `laneGapY = Math.max(config.laneGapY || 240, maxH + 20)`。
- 保证不同列与不同车道之间总有 40/20 像素的可视间隙。

### 2) 双向车道种子（保护兄弟分支）
- 右端种子：叶子层按 `laneOrder` 排序赋 `laneId`（已实现）。
- 左端种子：根的直接后继（首层分支头）按稳定顺序赋“独立车道种子”，并在回推时永不覆写：
  - `seedHeads = new Set(headIds)`；若 `laneOf.has(id)` 且 `id ∈ seedHeads`，跳过覆写。
- 回推策略融合：
  - 从最右层回推多数子车道；
  - 对未赋车道的中间层，若有父为种子头则继承其独立车道；否则按多数父车道决策。

### 3) 层列网格与去重
- `rankOf`：自根/多根 BFS 计算；不可达节点回退到 0。
- 坐标：
  - `x = startX + rank * colSpacing`；
  - `y = startY + laneId * laneGapY`；
  - 同层同车道多个节点使用 `rowOffset(±16)`微调，仍处同一走廊。

### 4) 应用与清理
- 批量 `node.position(x, y)` 应用；
- 遍历 `edges` 调用 `setVertices([])`，确保无控制点；连线仍平滑。

### 5) 验证
- 示例图：首层兄弟分支各自位于独立车道，后续层保持同一水平线；相邻列与车道均有可视间隙，视觉不再贴合。
- 输出日志：最大宽高、最终 `colSpacing/laneGapY`、种子数量、被多数回推计数、最终车道分布。

确认后我将按此方案修改实现，并完成一次快速布局验证。