# 预览线与连接线功能集成技术架构文档

## 1. 当前预览线和连接线的数据结构分析

### 1.1 预览线数据结构

基于代码分析，预览线具有以下特征：

```javascript
// 预览线识别逻辑
const isPreview = edgeSourceId && !edgeTargetId

// 预览线数据结构
{
  id: 'preview-line-xxx',
  source: 'source-node-id',    // 有源节点
  target: null,                // 无目标节点
  data: {
    type: 'preview-line',
    isUnifiedPreview: true,
    sourceNodeId: 'source-node-id',
    branchId: 'branch-xxx',    // 分支预览线特有
    isPreview: true
  },
  attrs: {
    line: {
      stroke: '#52c41a',
      strokeWidth: 2,
      strokeDasharray: '5,5',
      opacity: 0.7
    }
  }
}
```

### 1.2 连接线数据结构

```javascript
// 连接线数据结构
{
  id: 'connection-xxx',
  source: 'source-node-id',    // 有源节点
  target: 'target-node-id',    // 有目标节点
  sourcePort: 'out-port',
  targetPort: 'in-port',
  data: {
    type: 'real-connection',
    branchId: 'branch-xxx',    // 分支连接特有
    isPreview: false
  },
  attrs: {
    line: {
      stroke: '#1890ff',
      strokeWidth: 2,
      strokeDasharray: '0',
      targetMarker: {
        name: 'block',
        width: 8,
        height: 8
      }
    }
  }
}
```

### 1.3 当前系统问题分析

1. **多套预览线系统并存**
   - `usePreviewLine.js` - 基础预览线管理
   - `useCanvasConnection.js` - 连接线管理中的预览线功能
   - `PreviewLineSystem.js` - 统一预览线系统
   - 功能重叠，缺乏统一管理

2. **数据结构不一致**
   - 预览线和连接线使用不同的数据模型
   - 状态标记分散在不同属性中
   - 缺乏统一的类型定义

3. **生命周期管理混乱**
   - 预览线到连接线的转换逻辑复杂
   - 清理机制不统一
   - 状态同步问题

## 2. 预览线状态标记系统设计

### 2.1 统一状态枚举

```javascript
// 边的类型枚举
export const EdgeTypes = {
  PREVIEW: 'preview',           // 预览线
  CONNECTION: 'connection',     // 真实连接线
  TEMPORARY: 'temporary'        // 临时连接线
}

// 预览线状态枚举
export const PreviewStates = {
  INTERACTIVE: 'interactive',   // 可交互状态
  DRAGGING: 'dragging',        // 拖拽中状态
  CONNECTED: 'connected',      // 已连接状态
  HOVER: 'hover',              // 鼠标悬停状态
  PENDING: 'pending',          // 待处理状态
  INVALID: 'invalid'           // 无效状态
}

// 连接线状态枚举
export const ConnectionStates = {
  ACTIVE: 'active',            // 活跃连接
  INACTIVE: 'inactive',        // 非活跃连接
  BROKEN: 'broken',            // 断开连接
  VALIDATING: 'validating'     // 验证中
}
```

### 2.2 统一数据模型

```javascript
// 统一边数据模型
export interface UnifiedEdgeData {
  // 基础属性
  id: string
  type: EdgeTypes
  
  // 连接信息
  source: {
    nodeId: string
    portId?: string
    position?: Point
  }
  target?: {
    nodeId: string
    portId?: string
    position?: Point
  }
  
  // 状态信息
  state: PreviewStates | ConnectionStates
  isPreview: boolean
  isConnected: boolean
  
  // 分支信息（分流节点特有）
  branchId?: string
  branchLabel?: string
  branchIndex?: number
  
  // 样式配置
  style: EdgeStyle
  
  // 元数据
  metadata: {
    createdAt: number
    updatedAt: number
    createdBy: string
    nodeType?: string
  }
}
```

## 3. 连接线定位源节点和目标节点的机制

### 3.1 节点定位策略

```javascript
// 节点定位接口
export interface NodeLocator {
  // 通过ID定位节点
  locateById(nodeId: string): Node | null
  
  // 通过位置定位节点
  locateByPosition(position: Point, threshold?: number): Node | null
  
  // 验证节点是否存在且有效
  validateNode(nodeId: string): boolean
  
  // 获取节点的连接端口
  getNodePorts(nodeId: string): Port[]
}

// 连接验证器
export interface ConnectionValidator {
  // 验证连接是否有效
  validateConnection(source: string, target: string): ValidationResult
  
  // 检查是否允许连接
  canConnect(sourceNode: Node, targetNode: Node): boolean
  
  // 检查连接数限制
  checkConnectionLimits(nodeId: string): boolean
}
```

### 3.2 连接创建流程

```javascript
// 连接创建管理器
class ConnectionCreationManager {
  async createConnection(sourceId, targetId, options = {}) {
    // 1. 验证源节点和目标节点
    const sourceNode = this.nodeLocator.locateById(sourceId)
    const targetNode = this.nodeLocator.locateById(targetId)
    
    if (!sourceNode || !targetNode) {
      throw new Error('源节点或目标节点不存在')
    }
    
    // 2. 验证连接有效性
    const validation = this.validator.validateConnection(sourceId, targetId)
    if (!validation.isValid) {
      throw new Error(`连接无效: ${validation.errors.join(', ')}`)
    }
    
    // 3. 检查重复连接
    if (this.isDuplicateConnection(sourceId, targetId, options.branchId)) {
      throw new Error('连接已存在')
    }
    
    // 4. 创建连接线
    const connection = await this.createEdge({
      type: EdgeTypes.CONNECTION,
      source: { nodeId: sourceId },
      target: { nodeId: targetId },
      state: ConnectionStates.ACTIVE,
      isPreview: false,
      isConnected: true,
      ...options
    })
    
    // 5. 清理相关预览线
    await this.cleanupRelatedPreviewLines(sourceId, options.branchId)
    
    return connection
  }
}
```

## 4. 预览线只有源节点没有目标节点的特征

### 4.1 预览线识别逻辑

```javascript
// 统一预览线识别函数
export function isPreviewLine(edge) {
  if (!edge) return false
  
  // 方法1: 通过数据类型判断
  const edgeData = edge.getData?.() || {}
  if (edgeData.type === EdgeTypes.PREVIEW || edgeData.isPreview === true) {
    return true
  }
  
  // 方法2: 通过连接状态判断（核心特征）
  const hasSource = edge.getSourceCellId?.() || edge.source?.nodeId
  const hasTarget = edge.getTargetCellId?.() || edge.target?.nodeId
  
  return hasSource && !hasTarget
}

// 预览线类型分类
export function classifyPreviewLine(edge) {
  const edgeData = edge.getData?.() || {}
  
  if (edgeData.branchId) {
    return {
      type: 'branch-preview',
      branchId: edgeData.branchId,
      branchLabel: edgeData.branchLabel
    }
  }
  
  return {
    type: 'single-preview'
  }
}
```

### 4.2 预览线生命周期管理

```javascript
// 预览线生命周期管理器
class PreviewLineLifecycleManager {
  // 创建预览线
  async createPreviewLine(sourceNodeId, options = {}) {
    const previewLine = {
      id: `preview-${generateId()}`,
      type: EdgeTypes.PREVIEW,
      source: { nodeId: sourceNodeId },
      target: null, // 预览线特征：无目标节点
      state: PreviewStates.INTERACTIVE,
      isPreview: true,
      isConnected: false,
      ...options
    }
    
    return this.addToGraph(previewLine)
  }
  
  // 预览线转换为连接线
  async convertToConnection(previewLineId, targetNodeId) {
    const previewLine = this.getPreviewLine(previewLineId)
    if (!previewLine) {
      throw new Error('预览线不存在')
    }
    
    // 创建真实连接
    const connection = await this.connectionManager.createConnection(
      previewLine.source.nodeId,
      targetNodeId,
      {
        branchId: previewLine.branchId,
        style: previewLine.style
      }
    )
    
    // 删除预览线
    await this.removePreviewLine(previewLineId)
    
    return connection
  }
  
  // 清理无效预览线
  async cleanupInvalidPreviewLines() {
    const previewLines = this.getAllPreviewLines()
    
    for (const previewLine of previewLines) {
      const sourceNode = this.nodeLocator.locateById(previewLine.source.nodeId)
      
      // 源节点不存在或未配置
      if (!sourceNode || !this.isNodeConfigured(sourceNode)) {
        await this.removePreviewLine(previewLine.id)
        continue
      }
      
      // 检查是否已有真实连接
      if (this.hasRealConnection(previewLine.source.nodeId, previewLine.branchId)) {
        await this.removePreviewLine(previewLine.id)
      }
    }
  }
}
```

## 5. 功能集成的可行性分析和架构设计

### 5.1 集成可行性分析

**优势：**
1. **统一管理**: 预览线和连接线本质上都是图形边，可以使用统一的数据模型
2. **状态转换**: 预览线到连接线的转换是自然的状态变化
3. **简化逻辑**: 减少重复代码，统一事件处理机制
4. **性能优化**: 统一渲染和更新逻辑，减少重复计算

**挑战：**
1. **兼容性**: 需要保持与现有代码的兼容性
2. **复杂性**: 分支节点的预览线逻辑较复杂
3. **性能**: 大量预览线的渲染性能问题

### 5.2 集成架构设计

```javascript
// 统一边管理器架构
class UnifiedEdgeManager {
  constructor(graph) {
    this.graph = graph
    this.edges = new Map() // 统一存储所有边
    this.previewLines = new Map() // 预览线索引
    this.connections = new Map() // 连接线索引
    
    // 子管理器
    this.lifecycleManager = new EdgeLifecycleManager(this)
    this.stateManager = new EdgeStateManager(this)
    this.renderManager = new EdgeRenderManager(this)
    this.validationManager = new EdgeValidationManager(this)
  }
  
  // 创建边（统一入口）
  async createEdge(edgeData) {
    // 验证数据
    const validation = this.validationManager.validate(edgeData)
    if (!validation.isValid) {
      throw new Error(`边数据无效: ${validation.errors.join(', ')}`)
    }
    
    // 创建边实例
    const edge = await this.lifecycleManager.create(edgeData)
    
    // 添加到相应索引
    this.edges.set(edge.id, edge)
    if (edge.isPreview) {
      this.previewLines.set(edge.id, edge)
    } else {
      this.connections.set(edge.id, edge)
    }
    
    // 触发事件
    this.emit('edge:created', { edge })
    
    return edge
  }
  
  // 状态转换
  async convertPreviewToConnection(previewId, targetNodeId) {
    const preview = this.previewLines.get(previewId)
    if (!preview) {
      throw new Error('预览线不存在')
    }
    
    // 更新边数据
    const updatedEdge = {
      ...preview,
      target: { nodeId: targetNodeId },
      type: EdgeTypes.CONNECTION,
      state: ConnectionStates.ACTIVE,
      isPreview: false,
      isConnected: true
    }
    
    // 更新索引
    this.previewLines.delete(previewId)
    this.connections.set(previewId, updatedEdge)
    this.edges.set(previewId, updatedEdge)
    
    // 更新图形
    await this.renderManager.updateEdge(updatedEdge)
    
    // 触发事件
    this.emit('preview:converted', { edge: updatedEdge })
    
    return updatedEdge
  }
}
```

## 6. 连接线生成机制的具体实现

### 6.1 GraphOperationUtils 连接管理

基于 `GraphOperationUtils.js` 的实际实现，连接线生成采用以下机制：

```javascript
// GraphOperationUtils.js - 连接线添加方法
addConnection(sourceId, targetId, options = {}) {
  try {
    // 1. 生成唯一连接ID
    const connectionId = options.id || `connection-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    
    // 2. 验证源节点和目标节点存在性
    const sourceNode = this.graph.getCellById(sourceId)
    const targetNode = this.graph.getCellById(targetId)
    
    if (!sourceNode || !targetNode) {
      console.error('源节点或目标节点不存在:', { sourceId, targetId })
      return null
    }
    
    // 3. 配置端口信息（默认 out -> in）
    const sourcePort = options.sourcePort || 'out'
    const targetPort = options.targetPort || 'in'
    
    // 4. 创建连接配置
    const edgeConfig = {
      id: connectionId,
      source: { cell: sourceId, port: sourcePort },
      target: { cell: targetId, port: targetPort },
      attrs: {
        line: {
          stroke: options.stroke || '#1890ff',
          strokeWidth: options.strokeWidth || 2,
          targetMarker: {
            name: 'block',
            width: 8,
            height: 8,
            fill: options.stroke || '#1890ff'
          }
        }
      },
      data: {
        branchId: options.branchId,
        type: options.type || 'connection',
        createdBy: options.createdBy || 'system'
      }
    }
    
    // 5. 添加到图形和连接列表
    const edge = this.graph.addEdge(edgeConfig)
    this.connections.push({
      id: connectionId,
      sourceId,
      targetId,
      branchId: options.branchId,
      edge
    })
    
    console.log('连接创建成功:', connectionId)
    return edge
    
  } catch (error) {
    console.error('创建连接失败:', error)
    return null
  }
}
```

### 6.2 useCanvasConnection 连接管理

基于 `useCanvasConnection.js` 的实际实现：

```javascript
// 连接创建方法
const createConnection = async (sourceId, targetId, options = {}) => {
  try {
    // 1. 验证节点存在性
    const sourceNode = graph.value.getCellById(sourceId)
    const targetNode = graph.value.getCellById(targetId)
    
    if (!sourceNode || !targetNode) {
      throw new Error('源节点或目标节点不存在')
    }
    
    // 2. 检查重复连接
    const existingConnection = connections.value.find(conn => 
      conn.sourceId === sourceId && 
      conn.targetId === targetId &&
      conn.branchId === options.branchId
    )
    
    if (existingConnection) {
      console.warn('连接已存在:', existingConnection.id)
      return existingConnection.edge
    }
    
    // 3. 创建连接配置
    const connectionConfig = {
      id: options.id || `conn-${Date.now()}`,
      source: { cell: sourceId, port: options.sourcePort || 'out' },
      target: { cell: targetId, port: options.targetPort || 'in' },
      attrs: defaultStyle.value,
      data: {
        type: 'connection',
        branchId: options.branchId,
        sourceNodeId: sourceId,
        targetNodeId: targetId,
        createdAt: Date.now()
      }
    }
    
    // 4. 添加到图形
    const edge = graph.value.addEdge(connectionConfig)
    
    // 5. 更新连接状态
    connections.value.push({
      id: connectionConfig.id,
      sourceId,
      targetId,
      branchId: options.branchId,
      edge,
      createdAt: Date.now()
    })
    
    // 6. 应用样式和处理重叠
    await applyConnectionStyle(edge)
    edgeOverlapManager.value?.handleNewEdge(edge)
    
    // 7. 更新统计信息
    updateConnectionStats()
    
    return edge
    
  } catch (error) {
    console.error('创建连接失败:', error)
    throw error
  }
}
```

## 7. 连接线生成限制和验证机制

### 7.1 ConnectionValidator 验证器实现

基于 `ConnectionValidator.ts` 的实际实现：

```typescript
// 连接验证主方法
async validate(context: ConnectionValidationContext): Promise<ValidationResult> {
  const errors: ValidationError[] = []
  const warnings: ValidationError[] = []
  
  try {
    const { edge, sourceNode, targetNode } = context
    
    // 1. 基础连接校验
    this.validateBasicConnection(edge, sourceNode, targetNode, errors)
    
    // 2. 节点存在性校验
    this.validateNodeExistence(edge, sourceNode, targetNode, errors)
    
    // 3. 连接类型校验
    this.validateConnectionType(edge, sourceNode, targetNode, errors, warnings)
    
    // 4. 循环依赖校验
    this.validateCyclicDependency(edge, sourceNode, targetNode, errors)
    
    // 5. 重复连接校验
    this.validateDuplicateConnection(edge, sourceNode, targetNode, warnings)
    
    // 6. 端口方向校验
    this.validatePortDirection(edge, sourceNode, targetNode, errors)
    
    // 7. 数据兼容性校验
    this.validateDataCompatibility(edge, sourceNode, targetNode, warnings)
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      timestamp: Date.now()
    }
    
  } catch (error) {
    return {
      isValid: false,
      errors: [{
        type: 'VALIDATION_ERROR',
        message: `校验过程出错: ${error.message}`,
        severity: 'error',
        edgeId: context.edge?.id || 'unknown'
      }],
      warnings: [],
      timestamp: Date.now()
    }
  }
}

// 连接类型验证
private validateConnectionType(
  edge: Edge,
  sourceNode: Node,
  targetNode: Node,
  errors: ValidationError[],
  warnings: ValidationError[]
): void {
  const sourceData = sourceNode.getData()
  const targetData = targetNode.getData()
  
  const sourceType = sourceData?.nodeType
  const targetType = targetData?.nodeType

  // 检查允许的连接类型
  const sourceConfig = this.allowedConnections[sourceType]
  if (sourceConfig && !sourceConfig.canConnectTo.includes(targetType)) {
    errors.push({
      type: 'INVALID_CONNECTION_TYPE',
      message: `${sourceType} 节点不能连接到 ${targetType} 节点`,
      severity: 'error',
      edgeId: edge.id
    })
  }
}

// 循环依赖检测
private validateCyclicDependency(
  edge: Edge,
  sourceNode: Node,
  targetNode: Node,
  errors: ValidationError[]
): void {
  const visited = new Set<string>()
  const recursionStack = new Set<string>()

  const hasCycle = (nodeId: string): boolean => {
    if (recursionStack.has(nodeId)) return true
    if (visited.has(nodeId)) return false

    visited.add(nodeId)
    recursionStack.add(nodeId)

    const outgoingEdges = this.canvas.getOutgoingEdges(nodeId)
    for (const outEdge of outgoingEdges) {
      const targetId = outEdge.getTargetCellId()
      if (targetId && hasCycle(targetId)) return true
    }

    recursionStack.delete(nodeId)
    return false
  }

  if (hasCycle(sourceNode.id)) {
    errors.push({
      type: 'CYCLIC_DEPENDENCY',
      message: '此连接会形成循环依赖',
      severity: 'error',
      edgeId: edge.id
    })
  }
}
```

### 7.2 节点连接数限制

```javascript
// 节点连接数验证
checkConnectionLimits(nodeId, nodeType) {
  const connections = this.getNodeConnections(nodeId)
  const limits = this.getConnectionLimits(nodeType)
  
  return {
    canAddInput: connections.input.length < limits.maxInput,
    canAddOutput: connections.output.length < limits.maxOutput,
    currentInput: connections.input.length,
    currentOutput: connections.output.length,
    maxInput: limits.maxInput,
    maxOutput: limits.maxOutput
  }
}

// 连接限制配置
const connectionLimits = {
  'start-node': { maxInput: 0, maxOutput: 1 },
  'end-node': { maxInput: 1, maxOutput: 0 },
  'ai-call-node': { maxInput: 1, maxOutput: 1 },
  'branch-node': { maxInput: 1, maxOutput: Infinity },
  'condition-node': { maxInput: 1, maxOutput: 2 }
}
```

## 8. 删除连接线后预览线恢复机制

### 8.1 PreviewLineSystem 恢复机制

基于 `PreviewLineSystem.js` 的实际实现：

```javascript
// PreviewLineSystem 构造函数和初始化
constructor(graph) {
  // 严格验证图形实例
  if (!graph) {
    throw new Error('PreviewLineSystem: graph 实例是必需的')
  }
  
  // 验证图形实例的必要方法
  const requiredMethods = ['addEdge', 'removeEdge', 'getCellById', 'getEdges']
  for (const method of requiredMethods) {
    if (typeof graph[method] !== 'function') {
      throw new Error(`PreviewLineSystem: graph 实例缺少必要方法 ${method}`)
    }
  }
  
  this.graph = graph
  
  // 初始化核心模块
  this.eventManager = new PreviewLineEventManager()
  this.stateManager = new PreviewLineStateManager()
  this.configManager = new PreviewLineConfigManager()
  this.lifecycleManager = new PreviewLineLifecycleManager(this)
  
  // 初始化渲染器
  this.renderer = new PreviewLineRenderer(graph)
  this.algorithmManager = new PreviewLineAlgorithmManager()
  this.utilsManager = new PreviewLineUtilsManager()
  
  // 性能优化模块
  this.performanceOptimizer = new PreviewLinePerformanceOptimizer()
  this.batchProcessor = new PreviewLineBatchProcessor()
  this.cacheManager = new PreviewLineCacheManager()
  
  // 系统统计和错误处理
  this.stats = new PreviewLineStats()
  this.errorHandler = new PreviewLineErrorHandler()
  this.pluginSystem = new PreviewLinePluginSystem()
}

// 预览线恢复方法
async restorePreviewLine(nodeId, branchId = null, options = {}) {
  try {
    // 1. 验证节点存在性
    const node = this.graph.getCellById(nodeId)
    if (!node) {
      console.warn(`节点 ${nodeId} 不存在，无法恢复预览线`)
      return null
    }
    
    // 2. 检查是否已存在预览线
    if (this.hasPreviewLine(nodeId, branchId)) {
      console.log(`节点 ${nodeId} 的预览线已存在`)
      return this.getPreviewLine(nodeId, branchId)
    }
    
    // 3. 检查是否已有真实连接
    if (this.hasRealConnection(nodeId, branchId)) {
      console.log(`节点 ${nodeId} 已有真实连接，不需要恢复预览线`)
      return null
    }
    
    // 4. 创建预览线配置
    const previewConfig = {
      id: `preview-${nodeId}-${branchId || 'default'}-${Date.now()}`,
      sourceNodeId: nodeId,
      branchId,
      type: 'preview-line',
      isUnifiedPreview: true,
      ...options
    }
    
    // 5. 调用渲染器创建预览线
    const previewLine = await this.renderer.createPreviewLine(previewConfig)
    
    // 6. 存储到状态管理器
    this.stateManager.addPreviewLine(previewLine.id, {
      nodeId,
      branchId,
      edge: previewLine,
      createdAt: Date.now(),
      restoredFromConnection: true
    })
    
    // 7. 触发恢复事件
    this.eventManager.emit('preview-line:restored', {
      nodeId,
      branchId,
      previewLineId: previewLine.id,
      edge: previewLine
    })
    
    // 8. 更新统计信息
    this.stats.incrementRestored()
    
    return previewLine
    
  } catch (error) {
    this.errorHandler.handleError('restorePreviewLine', error, { nodeId, branchId })
    return null
  }
}

// 批量恢复预览线（性能优化）
async batchRestorePreviewLines(nodeConfigs, options = {}) {
  const startTime = performance.now()
  const results = []
  
  try {
    // 1. 验证批量操作参数
    if (!Array.isArray(nodeConfigs) || nodeConfigs.length === 0) {
      throw new Error('nodeConfigs 必须是非空数组')
    }
    
    // 2. 批量处理配置
    const batchSize = options.batchSize || 50
    const timeout = options.timeout || 100 // 100ms 内完成
    
    // 3. 分批处理
    for (let i = 0; i < nodeConfigs.length; i += batchSize) {
      const batch = nodeConfigs.slice(i, i + batchSize)
      const batchPromises = batch.map(config => 
        this.restorePreviewLine(config.nodeId, config.branchId, config.options)
      )
      
      const batchResults = await Promise.allSettled(batchPromises)
      results.push(...batchResults)
      
      // 检查超时
      if (performance.now() - startTime > timeout) {
        console.warn('批量恢复预览线超时，已处理部分数据')
        break
      }
    }
    
    // 4. 统计结果
    const successful = results.filter(r => r.status === 'fulfilled' && r.value).length
    const failed = results.length - successful
    
    console.log(`批量恢复预览线完成: 成功 ${successful}, 失败 ${failed}, 耗时 ${performance.now() - startTime}ms`)
    
    return {
      total: results.length,
      successful,
      failed,
      duration: performance.now() - startTime,
      results
    }
    
  } catch (error) {
    this.errorHandler.handleError('batchRestorePreviewLines', error, { nodeConfigs })
    return { total: 0, successful: 0, failed: nodeConfigs.length, results: [] }
  }
}
```

### 8.2 连接删除触发预览线恢复

```javascript
// GraphOperationUtils.js - 删除连接方法
deleteConnection(connectionId) {
  try {
    // 1. 查找连接
    const connectionIndex = this.connections.findIndex(conn => conn.id === connectionId)
    if (connectionIndex === -1) {
      console.warn('连接不存在:', connectionId)
      return false
    }
    
    const connection = this.connections[connectionIndex]
    
    // 2. 从图形中删除
    if (connection.edge) {
      this.graph.removeEdge(connection.edge)
    }
    
    // 3. 从连接列表中删除
    this.connections.splice(connectionIndex, 1)
    
    // 4. 恢复源节点的预览线（如果需要）
    if (this.previewLineManager && connection.sourceId) {
      this.previewLineManager.restorePreviewLine(
        connection.sourceId, 
        connection.branchId
      )
    }
    
    console.log('连接删除成功:', connectionId)
    return true
    
  } catch (error) {
    console.error('删除连接失败:', error)
    return false
  }
}

// useCanvasConnection.js - 删除连接方法
const removeConnection = async (connectionId) => {
  try {
    const connectionIndex = connections.value.findIndex(conn => conn.id === connectionId)
    if (connectionIndex === -1) {
      console.warn('连接不存在:', connectionId)
      return false
    }
    
    const connection = connections.value[connectionIndex]
    
    // 1. 从图形中删除边
    if (connection.edge) {
      graph.value.removeEdge(connection.edge)
    }
    
    // 2. 从连接数组中删除
    connections.value.splice(connectionIndex, 1)
    
    // 3. 恢复预览线
    if (connection.sourceId && connection.branchId) {
      await createPreviewLine(connection.sourceId, {
        branchId: connection.branchId,
        restoredFromConnection: true
      })
    }
    
    // 4. 更新统计信息
    updateConnectionStats()
    
    return true
    
  } catch (error) {
    console.error('删除连接失败:', error)
    return false
  }
}
```

## 9. 统一数据模型的设计方案

### 9.1 核心数据模型

```typescript
// 统一边数据接口
interface UnifiedEdge {
  // 基础标识
  id: string
  type: EdgeTypes
  
  // 连接信息
  source: EdgeEndpoint
  target?: EdgeEndpoint
  
  // 状态管理
  state: EdgeState
  isPreview: boolean
  isConnected: boolean
  isValid: boolean
  
  // 分支信息
  branch?: BranchInfo
  
  // 样式配置
  style: EdgeStyle
  
  // 渲染配置
  render: RenderConfig
  
  // 元数据
  metadata: EdgeMetadata
}

// 边端点接口
interface EdgeEndpoint {
  nodeId: string
  portId?: string
  position?: Point
  offset?: Point
}

// 分支信息接口
interface BranchInfo {
  id: string
  label: string
  index: number
  color?: string
}

// 边样式接口
interface EdgeStyle {
  stroke: string
  strokeWidth: number
  strokeDasharray?: string
  opacity?: number
  targetMarker?: MarkerConfig
  animation?: AnimationConfig
}
```

### 9.2 数据转换器

```javascript
// 数据转换器
class EdgeDataTransformer {
  // 将现有预览线数据转换为统一格式
  transformPreviewLine(legacyPreview) {
    return {
      id: legacyPreview.id,
      type: EdgeTypes.PREVIEW,
      source: {
        nodeId: legacyPreview.sourceNodeId || legacyPreview.source,
        position: legacyPreview.sourcePosition
      },
      target: null,
      state: PreviewStates.INTERACTIVE,
      isPreview: true,
      isConnected: false,
      branch: legacyPreview.branchId ? {
        id: legacyPreview.branchId,
        label: legacyPreview.branchLabel,
        index: legacyPreview.branchIndex
      } : undefined,
      style: this.transformStyle(legacyPreview.attrs?.line),
      metadata: {
        createdAt: Date.now(),
        updatedAt: Date.now(),
        version: '2.0'
      }
    }
  }
  
  // 将现有连接线数据转换为统一格式
  transformConnection(legacyConnection) {
    return {
      id: legacyConnection.id,
      type: EdgeTypes.CONNECTION,
      source: {
        nodeId: legacyConnection.source,
        portId: legacyConnection.sourcePort
      },
      target: {
        nodeId: legacyConnection.target,
        portId: legacyConnection.targetPort
      },
      state: ConnectionStates.ACTIVE,
      isPreview: false,
      isConnected: true,
      style: this.transformStyle(legacyConnection.attrs?.line),
      metadata: {
        createdAt: new Date(legacyConnection.createdAt).getTime(),
        updatedAt: Date.now(),
        version: '2.0'
      }
    }
  }
}
```

## 7. 状态管理和生命周期管理

### 7.1 状态管理器

```javascript
// 边状态管理器
class EdgeStateManager {
  constructor(edgeManager) {
    this.edgeManager = edgeManager
    this.stateTransitions = new Map()
    this.setupTransitions()
  }
  
  // 设置状态转换规则
  setupTransitions() {
    // 预览线状态转换
    this.addTransition(PreviewStates.INTERACTIVE, PreviewStates.DRAGGING)
    this.addTransition(PreviewStates.DRAGGING, PreviewStates.CONNECTED)
    this.addTransition(PreviewStates.CONNECTED, ConnectionStates.ACTIVE)
    
    // 连接线状态转换
    this.addTransition(ConnectionStates.ACTIVE, ConnectionStates.INACTIVE)
    this.addTransition(ConnectionStates.INACTIVE, ConnectionStates.ACTIVE)
    this.addTransition(ConnectionStates.ACTIVE, ConnectionStates.BROKEN)
  }
  
  // 状态转换
  async transitionState(edgeId, newState) {
    const edge = this.edgeManager.getEdge(edgeId)
    if (!edge) {
      throw new Error('边不存在')
    }
    
    // 验证转换是否允许
    if (!this.canTransition(edge.state, newState)) {
      throw new Error(`不允许从 ${edge.state} 转换到 ${newState}`)
    }
    
    const oldState = edge.state
    edge.state = newState
    edge.metadata.updatedAt = Date.now()
    
    // 触发状态变化事件
    this.edgeManager.emit('edge:stateChanged', {
      edge,
      oldState,
      newState
    })
    
    // 特殊状态处理
    await this.handleSpecialTransitions(edge, oldState, newState)
    
    return edge
  }
  
  // 处理特殊状态转换
  async handleSpecialTransitions(edge, oldState, newState) {
    // 预览线转连接线
    if (oldState === PreviewStates.CONNECTED && newState === ConnectionStates.ACTIVE) {
      await this.convertPreviewToConnection(edge)
    }
    
    // 连接断开
    if (newState === ConnectionStates.BROKEN) {
      await this.handleConnectionBroken(edge)
    }
  }
}
```

### 7.2 生命周期管理器

```javascript
// 边生命周期管理器
class EdgeLifecycleManager {
  constructor(edgeManager) {
    this.edgeManager = edgeManager
    this.hooks = new Map()
  }
  
  // 创建边
  async create(edgeData) {
    // 前置钩子
    await this.executeHooks('beforeCreate', edgeData)
    
    // 创建边实例
    const edge = new UnifiedEdge(edgeData)
    
    // 添加到图形
    const graphEdge = await this.addToGraph(edge)
    edge.graphInstance = graphEdge
    
    // 后置钩子
    await this.executeHooks('afterCreate', edge)
    
    return edge
  }
  
  // 更新边
  async update(edgeId, updates) {
    const edge = this.edgeManager.getEdge(edgeId)
    if (!edge) {
      throw new Error('边不存在')
    }
    
    // 前置钩子
    await this.executeHooks('beforeUpdate', { edge, updates })
    
    // 应用更新
    Object.assign(edge, updates)
    edge.metadata.updatedAt = Date.now()
    
    // 更新图形
    await this.updateGraphEdge(edge)
    
    // 后置钩子
    await this.executeHooks('afterUpdate', edge)
    
    return edge
  }
  
  // 删除边
  async remove(edgeId) {
    const edge = this.edgeManager.getEdge(edgeId)
    if (!edge) {
      return
    }
    
    // 前置钩子
    await this.executeHooks('beforeRemove', edge)
    
    // 从图形中移除
    await this.removeFromGraph(edge)
    
    // 从管理器中移除
    this.edgeManager.removeEdge(edgeId)
    
    // 后置钩子
    await this.executeHooks('afterRemove', { edgeId, edge })
  }
}
```

## 8. 性能优化和问题解决方案

### 8.1 性能优化策略

```javascript
// 性能优化管理器
class EdgePerformanceOptimizer {
  constructor(edgeManager) {
    this.edgeManager = edgeManager
    this.renderQueue = []
    this.updateBatch = new Set()
    this.isProcessing = false
  }
  
  // 批量渲染优化
  async batchRender(edges) {
    this.renderQueue.push(...edges)
    
    if (!this.isProcessing) {
      this.isProcessing = true
      await this.processRenderQueue()
      this.isProcessing = false
    }
  }
  
  // 处理渲染队列
  async processRenderQueue() {
    while (this.renderQueue.length > 0) {
      const batch = this.renderQueue.splice(0, 50) // 每批处理50个
      
      await Promise.all(batch.map(edge => this.renderEdge(edge)))
      
      // 让出控制权，避免阻塞UI
      await new Promise(resolve => setTimeout(resolve, 0))
    }
  }
  
  // 虚拟化渲染（大量预览线场景）
  setupVirtualization() {
    const viewport = this.edgeManager.graph.getViewport()
    
    // 只渲染视口内的边
    this.edgeManager.edges.forEach(edge => {
      const isInViewport = this.isEdgeInViewport(edge, viewport)
      
      if (isInViewport && !edge.isRendered) {
        this.renderEdge(edge)
      } else if (!isInViewport && edge.isRendered) {
        this.hideEdge(edge)
      }
    })
  }
  
  // 内存优化
  optimizeMemory() {
    // 清理无效边的缓存
    this.edgeManager.edges.forEach((edge, id) => {
      if (!edge.isValid || edge.metadata.lastAccessed < Date.now() - 300000) {
        this.edgeManager.removeEdge(id)
      }
    })
    
    // 压缩历史状态
    this.compressHistoryStates()
  }
}
```

### 8.2 问题解决方案

```javascript
// 问题诊断和修复器
class EdgeProblemResolver {
  constructor(edgeManager) {
    this.edgeManager = edgeManager
    this.diagnostics = []
  }
  
  // 诊断边问题
  async diagnoseProblems() {
    const problems = []
    
    // 检查重复边
    const duplicates = this.findDuplicateEdges()
    if (duplicates.length > 0) {
      problems.push({
        type: 'duplicate_edges',
        count: duplicates.length,
        edges: duplicates
      })
    }
    
    // 检查孤立预览线
    const orphanedPreviews = this.findOrphanedPreviewLines()
    if (orphanedPreviews.length > 0) {
      problems.push({
        type: 'orphaned_previews',
        count: orphanedPreviews.length,
        edges: orphanedPreviews
      })
    }
    
    // 检查无效连接
    const invalidConnections = this.findInvalidConnections()
    if (invalidConnections.length > 0) {
      problems.push({
        type: 'invalid_connections',
        count: invalidConnections.length,
        edges: invalidConnections
      })
    }
    
    return problems
  }
  
  // 自动修复问题
  async autoFixProblems(problems) {
    for (const problem of problems) {
      switch (problem.type) {
        case 'duplicate_edges':
          await this.fixDuplicateEdges(problem.edges)
          break
        case 'orphaned_previews':
          await this.fixOrphanedPreviewLines(problem.edges)
          break
        case 'invalid_connections':
          await this.fixInvalidConnections(problem.edges)
          break
      }
    }
  }
  
  // 修复重复边
  async fixDuplicateEdges(duplicates) {
    const groups = this.groupDuplicateEdges(duplicates)
    
    for (const group of groups) {
      // 保留最新的边，删除其他的
      const latest = group.reduce((latest, edge) => 
        edge.metadata.createdAt > latest.metadata.createdAt ? edge : latest
      )
      
      for (const edge of group) {
        if (edge.id !== latest.id) {
          await this.edgeManager.removeEdge(edge.id)
        }
      }
    }
  }
  
  // 修复孤立预览线
  async fixOrphanedPreviewLines(orphaned) {
    for (const edge of orphaned) {
      const sourceNode = this.edgeManager.nodeLocator.locateById(edge.source.nodeId)
      
      if (!sourceNode) {
        // 源节点不存在，删除预览线
        await this.edgeManager.removeEdge(edge.id)
      } else if (!this.isNodeConfigured(sourceNode)) {
        // 源节点未配置，删除预览线
        await this.edgeManager.removeEdge(edge.id)
      }
    }
  }
}
```

## 9. 实施建议和迁移策略

### 9.1 分阶段实施计划

**第一阶段：统一数据模型**
1. 定义统一的边数据接口
2. 实现数据转换器
3. 创建兼容性适配器

**第二阶段：核心管理器重构**
1. 实现 UnifiedEdgeManager
2. 集成现有功能
3. 保持API兼容性

**第三阶段：性能优化**
1. 实现批量渲染
2. 添加虚拟化支持
3. 优化内存使用

**第四阶段：问题修复和清理**
1. 实现问题诊断器
2. 添加自动修复功能
3. 清理遗留代码

### 9.2 风险控制

1. **渐进式迁移**: 保持现有API，逐步替换内部实现
2. **功能开关**: 使用特性开关控制新功能的启用
3. **回滚机制**: 保留旧版本实现，支持快速回滚
4. **充分测试**: 建立完整的测试用例覆盖

## 10. 总结

通过统一预览线和连接线的数据模型和管理机制，可以有效解决当前系统中的重复创建、状态不一致、性能问题等。关键在于：

1. **统一数据模型**: 使用 `isPreview` 和 `target` 属性区分预览线和连接线
2. **状态驱动**: 通过状态转换管理预览线到连接线的转换
3. **生命周期管理**: 统一的创建、更新、删除流程
4. **性能优化**: 批量渲染、虚拟化、内存优化
5. **问题诊断**: 自动检测和修复常见问题

这种集成方案既能解决现有问题，又能为未来的功能扩展提供良好的基础架构。