# èŠ‚ç‚¹æ ¸å¿ƒåŠŸèƒ½åˆ†ææŠ¥å‘Š

## ğŸ“‹ æ¦‚è¿°

æœ¬æŠ¥å‘Šæ·±å…¥åˆ†æäº†ç”»å¸ƒç³»ç»Ÿä¸­èŠ‚ç‚¹ï¼ˆNodeï¼‰çš„æ ¸å¿ƒåŠŸèƒ½å®ç°ï¼ŒåŒ…æ‹¬èŠ‚ç‚¹åˆ›å»ºã€æ ·å¼ç®¡ç†ã€åŠ è½½æœºåˆ¶ã€ç«¯å£ç³»ç»Ÿã€åæ ‡è®¡ç®—é€»è¾‘ã€åˆ é™¤æ“ä½œå’ŒèŠ‚ç‚¹é…ç½®ç­‰å…³é”®åŠŸèƒ½æ¨¡å—ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### 1.1 æ ¸å¿ƒç»„ä»¶æ¶æ„

```mermaid
graph TB
    A[NodeManager] --> B[NodeCreationService]
    A --> C[NodeStyleService]
    A --> E[NodeCoordinateService]
    A --> F[NodeConfigService]
    
    B --> G[NodeFactory]
    B --> H[NodeValidator]
    
    C --> I[StyleRenderer]
    C --> J[ThemeManager]
    
    E --> M[CoordinateCalculator]
    E --> N[LayoutEngine]
    
    F --> O[ConfigDrawer]
    F --> P[PropertyPanel]
    
    %% ç«¯å£åŠŸèƒ½é€šè¿‡ç‹¬ç«‹æ¨¡å—å®ç°
    Q[PortConfigurationFactory] --> R[ç«¯å£é…ç½®ç®¡ç†]
    S[portConfigFactory.js] --> T[ç«¯å£åˆ›å»ºå·¥å…·]
```

### 1.2 èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸç®¡ç†

```mermaid
sequenceDiagram
    participant U as User
    participant NM as NodeManager
    participant NC as NodeCreationService
    participant NS as NodeStyleService
    participant PCF as PortConfigurationFactory
    participant G as Graph
    
    U->>NM: åˆ›å»ºèŠ‚ç‚¹è¯·æ±‚
    NM->>NC: createNode(nodeData)
    NC->>NC: validateNodeData()
    NC->>PCF: createPortConfiguration(nodeType)
    PCF->>NC: è¿”å›ç«¯å£é…ç½®
    NC->>G: addNode(nodeConfig)
    G->>NS: applyNodeStyle(nodeId)
    G->>U: èŠ‚ç‚¹åˆ›å»ºå®Œæˆ
```

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

### 2.1 èŠ‚ç‚¹åˆ›å»ºç³»ç»Ÿ

#### ğŸ­ NodeCreationService èŠ‚ç‚¹åˆ›å»ºæœåŠ¡

**æ ¸å¿ƒèŒè´£ï¼š**
- èŠ‚ç‚¹æ•°æ®éªŒè¯å’Œé¢„å¤„ç†
- èŠ‚ç‚¹å®ä¾‹åŒ–å’Œåˆå§‹åŒ–
- èŠ‚ç‚¹æ·»åŠ åˆ°ç”»å¸ƒå›¾å½¢å®ä¾‹
- èŠ‚ç‚¹åˆ›å»ºåçš„å›è°ƒå¤„ç†

**å…³é”®æ–¹æ³•ï¼š**

```javascript
// èŠ‚ç‚¹åˆ›å»ºä¸»æ–¹æ³•
async createNode(nodeData, options = {}) {
  try {
    // 1. æ•°æ®éªŒè¯
    const validatedData = await this.validateNodeData(nodeData)
    
    // 2. ç”ŸæˆèŠ‚ç‚¹é…ç½®
    const nodeConfig = this.generateNodeConfig(validatedData, options)
    
    // 3. åˆ›å»ºèŠ‚ç‚¹å®ä¾‹
    const nodeInstance = await this.createNodeInstance(nodeConfig)
    
    // 4. æ·»åŠ åˆ°ç”»å¸ƒ
    const addedNode = await this.addNodeToGraph(nodeInstance)
    
    // 5. åˆå§‹åŒ–èŠ‚ç‚¹åŠŸèƒ½
    await this.initializeNodeFeatures(addedNode)
    
    console.log('[NodeCreationService] âœ… èŠ‚ç‚¹åˆ›å»ºæˆåŠŸ:', addedNode.id)
    return addedNode
    
  } catch (error) {
    console.error('[NodeCreationService] âŒ èŠ‚ç‚¹åˆ›å»ºå¤±è´¥:', error)
    throw error
  }
}

// èŠ‚ç‚¹æ•°æ®éªŒè¯
validateNodeData(nodeData) {
  const requiredFields = ['type', 'position']
  const missingFields = requiredFields.filter(field => !nodeData[field])
  
  if (missingFields.length > 0) {
    throw new Error(`ç¼ºå°‘å¿…éœ€å­—æ®µ: ${missingFields.join(', ')}`)
  }
  
  // ä½ç½®éªŒè¯
  if (!nodeData.position.x || !nodeData.position.y) {
    throw new Error('èŠ‚ç‚¹ä½ç½®åæ ‡æ— æ•ˆ')
  }
  
  return {
    ...nodeData,
    id: nodeData.id || this.generateNodeId(),
    timestamp: Date.now()
  }
}

// ç”ŸæˆèŠ‚ç‚¹é…ç½®
generateNodeConfig(nodeData, options) {
  return {
    id: nodeData.id,
    shape: this.getNodeShape(nodeData.type),
    x: nodeData.position.x,
    y: nodeData.position.y,
    width: nodeData.width || this.getDefaultWidth(nodeData.type),
    height: nodeData.height || this.getDefaultHeight(nodeData.type),
    data: {
      ...nodeData,
      ...options.additionalData
    },
    ports: this.generateNodePorts(nodeData.type),
    attrs: this.generateNodeAttrs(nodeData.type, nodeData.style)
  }
}
```

#### ğŸ¨ èŠ‚ç‚¹æ ·å¼ç”Ÿæˆ

```javascript
// ç”ŸæˆèŠ‚ç‚¹å±æ€§
generateNodeAttrs(nodeType, customStyle = {}) {
  const baseAttrs = {
    body: {
      stroke: '#d9d9d9',
      strokeWidth: 1,
      fill: '#ffffff',
      rx: 6,
      ry: 6
    },
    label: {
      fontSize: 12,
      fill: '#333333',
      textAnchor: 'middle',
      textVerticalAnchor: 'middle'
    }
  }
  
  // æ ¹æ®èŠ‚ç‚¹ç±»å‹åº”ç”¨ç‰¹å®šæ ·å¼
  const typeSpecificAttrs = this.getTypeSpecificAttrs(nodeType)
  
  // åˆå¹¶è‡ªå®šä¹‰æ ·å¼
  return this.mergeAttrs(baseAttrs, typeSpecificAttrs, customStyle)
}

// è·å–ç±»å‹ç‰¹å®šå±æ€§
getTypeSpecificAttrs(nodeType) {
  const typeAttrs = {
    'start': {
      body: { fill: '#e6f7ff', stroke: '#1890ff' },
      label: { fill: '#1890ff' }
    },
    'process': {
      body: { fill: '#f6ffed', stroke: '#52c41a' },
      label: { fill: '#52c41a' }
    },
    'decision': {
      body: { fill: '#fff7e6', stroke: '#fa8c16' },
      label: { fill: '#fa8c16' }
    },
    'end': {
      body: { fill: '#fff1f0', stroke: '#f5222d' },
      label: { fill: '#f5222d' }
    }
  }
  
  return typeAttrs[nodeType] || {}
}
```

### 2.2 èŠ‚ç‚¹æ ·å¼ç®¡ç†ç³»ç»Ÿ

#### ğŸ¨ NodeStyleService æ ·å¼æœåŠ¡

**æ ¸å¿ƒèŒè´£ï¼š**
- èŠ‚ç‚¹æ ·å¼ä¸»é¢˜ç®¡ç†
- åŠ¨æ€æ ·å¼æ›´æ–°
- æ ·å¼çŠ¶æ€ç®¡ç†ï¼ˆé€‰ä¸­ã€æ‚¬åœã€ç¦ç”¨ç­‰ï¼‰
- è‡ªå®šä¹‰æ ·å¼æ”¯æŒ

**å…³é”®åŠŸèƒ½ï¼š**

```javascript
class NodeStyleService {
  constructor(graph) {
    this.graph = graph
    this.themeManager = new ThemeManager()
    this.styleCache = new Map()
  }
  
  // åº”ç”¨èŠ‚ç‚¹æ ·å¼
  applyNodeStyle(nodeId, styleConfig = {}) {
    const node = this.graph.getCellById(nodeId)
    if (!node) {
      console.error('[NodeStyleService] èŠ‚ç‚¹ä¸å­˜åœ¨:', nodeId)
      return false
    }
    
    try {
      // è·å–å½“å‰ä¸»é¢˜æ ·å¼
      const themeStyle = this.themeManager.getNodeThemeStyle(node.getData().type)
      
      // åˆå¹¶æ ·å¼é…ç½®
      const finalStyle = this.mergeStyles(themeStyle, styleConfig)
      
      // åº”ç”¨æ ·å¼åˆ°èŠ‚ç‚¹
      node.setAttrs(finalStyle)
      
      // ç¼“å­˜æ ·å¼
      this.styleCache.set(nodeId, finalStyle)
      
      console.log('[NodeStyleService] âœ… æ ·å¼åº”ç”¨æˆåŠŸ:', nodeId)
      return true
      
    } catch (error) {
      console.error('[NodeStyleService] âŒ æ ·å¼åº”ç”¨å¤±è´¥:', error)
      return false
    }
  }
  
  // æ›´æ–°èŠ‚ç‚¹çŠ¶æ€æ ·å¼
  updateNodeState(nodeId, state, active = true) {
    const node = this.graph.getCellById(nodeId)
    if (!node) return false
    
    const stateStyles = {
      selected: {
        body: { stroke: '#1890ff', strokeWidth: 2 }
      },
      hover: {
        body: { stroke: '#40a9ff', strokeWidth: 1.5 }
      },
      disabled: {
        body: { opacity: 0.5 },
        label: { opacity: 0.5 }
      },
      error: {
        body: { stroke: '#f5222d', strokeWidth: 2 }
      }
    }
    
    if (active && stateStyles[state]) {
      node.setAttrs(stateStyles[state])
    } else {
      // æ¢å¤åŸå§‹æ ·å¼
      const originalStyle = this.styleCache.get(nodeId)
      if (originalStyle) {
        node.setAttrs(originalStyle)
      }
    }
    
    return true
  }
  
  // æ‰¹é‡æ›´æ–°æ ·å¼
  batchUpdateStyles(nodeIds, styleConfig) {
    const results = nodeIds.map(nodeId => {
      return this.applyNodeStyle(nodeId, styleConfig)
    })
    
    const successCount = results.filter(Boolean).length
    console.log(`[NodeStyleService] æ‰¹é‡æ ·å¼æ›´æ–°å®Œæˆ: ${successCount}/${nodeIds.length}`)
    
    return results
  }
}
```

### 2.3 èŠ‚ç‚¹ç«¯å£ç³»ç»Ÿ

#### âœ… ç«¯å£é…ç½®ç³»ç»Ÿ

**å®é™…å®ç°æ–¹å¼ï¼š**
- ä½¿ç”¨ `PortConfigurationFactory.js` è¿›è¡Œç«¯å£é…ç½®
- é€šè¿‡ `portConfigFactory.js` ç®¡ç†ç«¯å£åˆ›å»º
- åœ¨ X6 å›¾å½¢å¼•æ“å±‚é¢å¤„ç†ç«¯å£äº¤äº’
- ç«¯å£è¿æ¥éªŒè¯é€šè¿‡ç”»å¸ƒéªŒè¯ç³»ç»Ÿå®ç°

#### âš ï¸ ã€ä¸¥é‡é—®é¢˜ã€‘èŠ‚ç‚¹ç±»å‹å®šä¹‰ä¸ä¸€è‡´æ€§åˆ†æ

**é—®é¢˜æ¦‚è¿°ï¼š**
ç»è¿‡æ·±å…¥åˆ†æï¼Œå‘ç°ç³»ç»Ÿä¸­å­˜åœ¨ä¸¥é‡çš„èŠ‚ç‚¹ç±»å‹å®šä¹‰ä¸ä¸€è‡´é—®é¢˜ï¼Œè¿™å¯èƒ½å¯¼è‡´ç«¯å£é…ç½®é”™è¯¯ã€åŠŸèƒ½å¼‚å¸¸å’Œç»´æŠ¤å›°éš¾ã€‚

**1. å®é™…ç”»å¸ƒæ”¯æŒçš„èŠ‚ç‚¹ç±»å‹**ï¼ˆæ¥è‡ª `nodeTypes.js` å’Œæµ‹è¯•é…ç½®ï¼‰ï¼š
```javascript
const ACTUAL_SUPPORTED_TYPES = [
  'start',           // å¼€å§‹èŠ‚ç‚¹
  'audience-split',  // äººç¾¤åˆ†æµ
  'event-split',     // äº‹ä»¶åˆ†æµ
  'sms',            // çŸ­ä¿¡è§¦è¾¾
  'email',          // é‚®ä»¶è§¦è¾¾
  'wechat',         // å¾®ä¿¡è§¦è¾¾
  'ai-call',        // AIå¤–å‘¼
  'manual-call',    // äººå·¥å¤–å‘¼
  'ab-test',        // ABæµ‹è¯•
  'condition',      // æ¡ä»¶åˆ¤æ–­
  'wait',           // ç­‰å¾…èŠ‚ç‚¹
  'benefit',        // æƒç›ŠèŠ‚ç‚¹
  'end'             // ç»“æŸèŠ‚ç‚¹
]
```

**2. PortConfigurationFactoryä¸­å®šä¹‰çš„é»˜è®¤èŠ‚ç‚¹ç±»å‹**ï¼š
```javascript
const PORT_FACTORY_TYPES = [
  'start', 'end', 'action', 'condition', 'delay', 'webhook',
  'audience-split', 'event-split', 'ab-test', 'email', 'sms'
]
```

**3. TypeScriptç±»å‹å®šä¹‰æ–‡ä»¶ `canvas.d.ts` ä¸­çš„NodeType**ï¼š
```typescript
export type NodeType = 
  | 'start' | 'end' | 'audience-split' | 'event-split' 
  | 'ab-test' | 'message' | 'delay' | 'condition'
```

**4. NodePortServiceç¤ºä¾‹ä»£ç ä¸­ä½¿ç”¨çš„ç±»å‹**ï¼š
```javascript
const EXAMPLE_TYPES = ['start', 'process', 'decision', 'end']
```

#### ğŸš¨ å‘ç°çš„å…·ä½“ä¸ä¸€è‡´é—®é¢˜

| é—®é¢˜ç±»å‹ | å…·ä½“é—®é¢˜ | å½±å“èŒƒå›´ |
|---------|---------|----------|
| **ç¼ºå¤±ç±»å‹** | PortConfigurationFactoryç¼ºå°‘ï¼š`ai-call`, `manual-call`, `wechat`, `wait`, `benefit` | è¿™äº›èŠ‚ç‚¹çš„ç«¯å£é…ç½®å¯èƒ½å¤±æ•ˆ |
| **å¤šä½™ç±»å‹** | PortConfigurationFactoryåŒ…å«ï¼š`action`, `delay`, `webhook` | æ— ç”¨çš„é…ç½®ä»£ç ï¼Œå¢åŠ ç»´æŠ¤è´Ÿæ‹… |
| **å‘½åä¸ä¸€è‡´** | canvas.d.tsä¸­çš„`message`å¯¹åº”å®é™…çš„`sms` | ç±»å‹æ£€æŸ¥å¤±æ•ˆ |
| **ç±»å‹ä¸ä¸€è‡´** | ä¸åŒæ–‡ä»¶ä¸­èŠ‚ç‚¹ç±»å‹å®šä¹‰å­˜åœ¨å·®å¼‚ | åŠŸèƒ½ä¸ä¸€è‡´ï¼Œç»´æŠ¤å›°éš¾ |

#### ğŸ”§ æ ‡å‡†åŒ–ä¿®å¤æ–¹æ¡ˆ

**1. ç»Ÿä¸€èŠ‚ç‚¹ç±»å‹å®šä¹‰**
```javascript
// å»ºè®®çš„æ ‡å‡†èŠ‚ç‚¹ç±»å‹å®šä¹‰
export const STANDARD_NODE_TYPES = {
  // æµç¨‹æ§åˆ¶èŠ‚ç‚¹
  START: 'start',
  END: 'end',
  
  // åˆ†æµèŠ‚ç‚¹
  AUDIENCE_SPLIT: 'audience-split',
  EVENT_SPLIT: 'event-split',
  AB_TEST: 'ab-test',
  CONDITION: 'condition',
  
  // è§¦è¾¾èŠ‚ç‚¹
  SMS: 'sms',
  EMAIL: 'email',
  WECHAT: 'wechat',
  AI_CALL: 'ai-call',
  MANUAL_CALL: 'manual-call',
  
  // åŠŸèƒ½èŠ‚ç‚¹
  WAIT: 'wait',
  BENEFIT: 'benefit'
}
```

**2. æ›´æ–°PortConfigurationFactory**
```javascript
// ä¿®å¤åçš„é»˜è®¤èŠ‚ç‚¹ç±»å‹é…ç½®
const CORRECTED_DEFAULT_TYPES = [
  'start', 'end', 'audience-split', 'event-split', 'ab-test',
  'condition', 'sms', 'email', 'wechat', 'ai-call', 'manual-call',
  'wait', 'benefit'
]
```

**3. æ›´æ–°TypeScriptç±»å‹å®šä¹‰**
```typescript
// ä¿®å¤åçš„NodeTypeå®šä¹‰
export type NodeType = 
  | 'start' | 'end'
  | 'audience-split' | 'event-split' | 'ab-test' | 'condition'
  | 'sms' | 'email' | 'wechat' | 'ai-call' | 'manual-call'
  | 'wait' | 'benefit'
```

#### ğŸ“‹ ä¿®å¤ä¼˜å…ˆçº§å’Œå»ºè®®

**é«˜ä¼˜å…ˆçº§ä¿®å¤ï¼š**
1. âœ… æ›´æ–° `PortConfigurationFactory.js` ä¸­çš„é»˜è®¤èŠ‚ç‚¹ç±»å‹åˆ—è¡¨
2. âœ… ä¿®å¤ `canvas.d.ts` ä¸­çš„ TypeScript ç±»å‹å®šä¹‰
3. âœ… æ›´æ–°æ‰€æœ‰ç¤ºä¾‹ä»£ç ä¸­çš„èŠ‚ç‚¹ç±»å‹å¼•ç”¨

**ä¸­ä¼˜å…ˆçº§ä¿®å¤ï¼š**
1. ğŸ”„ åˆ›å»ºç»Ÿä¸€çš„èŠ‚ç‚¹ç±»å‹å¸¸é‡æ–‡ä»¶
2. ğŸ”„ æ·»åŠ èŠ‚ç‚¹ç±»å‹éªŒè¯ä¸­é—´ä»¶
3. ğŸ”„ æ›´æ–°ç›¸å…³æµ‹è¯•ç”¨ä¾‹

**ä½ä¼˜å…ˆçº§æ”¹è¿›ï¼š**
1. ğŸ“ å®Œå–„èŠ‚ç‚¹ç±»å‹æ–‡æ¡£
2. ğŸ“ æ·»åŠ ç±»å‹è¿ç§»æŒ‡å—
3. ğŸ“ å»ºç«‹ç±»å‹å®šä¹‰ç»´æŠ¤è§„èŒƒ

#### ğŸ¨ æ ·å¼é…ç½®æ–‡ä»¶ä¸­çš„èŠ‚ç‚¹ç±»å‹ä¸€è‡´æ€§åˆ†æ

**å‘ç°çš„æ ·å¼é…ç½®æ–‡ä»¶ï¼š**

**1. `/src/utils/nodeTypes.js` - èŠ‚ç‚¹æ ·å¼ä¸»é…ç½®æ–‡ä»¶**
```javascript
// âœ… æ­£ç¡®ï¼šåŒ…å«å®Œæ•´çš„å®é™…æ”¯æŒèŠ‚ç‚¹ç±»å‹
const STYLE_SUPPORTED_TYPES = [
  'start', 'audience-split', 'event-split', 'sms', 'email', 'wechat',
  'ai-call', 'manual-call', 'ab-test', 'condition', 'wait', 'benefit', 
  'task', 'end'
]
```

**2. `/src/pages/marketing/tasks/utils/canvas/canvasConfig.js` - ç”»å¸ƒé…ç½®æ–‡ä»¶**
```javascript
// âœ… æ­£ç¡®ï¼šé€šè¿‡å¼•ç”¨å…¶ä»–é…ç½®æ–‡ä»¶ä¿æŒä¸€è‡´æ€§
import { createPortConfig } from './portConfigFactory.js'
const { getPortGroups } = require('./x6Config.js')
```

**3. `/src/pages/marketing/tasks/utils/canvas/x6Config.js` - X6å¼•æ“é…ç½®æ–‡ä»¶**
```javascript
// âœ… æ­£ç¡®ï¼šé€šç”¨é…ç½®ï¼Œä¸ä¾èµ–ç‰¹å®šèŠ‚ç‚¹ç±»å‹
export const getNodeStyles = (nodeType, nodeConfig) => {
  // åŠ¨æ€å¤„ç†ä»»ä½•èŠ‚ç‚¹ç±»å‹
}
```

#### ğŸ” æ ·å¼é…ç½®ä¸€è‡´æ€§è¯„ä¼°

| é…ç½®æ–‡ä»¶ | èŠ‚ç‚¹ç±»å‹å®šä¹‰æ–¹å¼ | ä¸€è‡´æ€§çŠ¶æ€ | é—®é¢˜æè¿° |
|---------|-----------------|-----------|----------|
| **nodeTypes.js** | âœ… å®Œæ•´æšä¸¾æ‰€æœ‰ç±»å‹ | ğŸŸ¢ è‰¯å¥½ | åŒ…å«æ‰€æœ‰å®é™…æ”¯æŒçš„èŠ‚ç‚¹ç±»å‹ |
| **canvasConfig.js** | âœ… å¼•ç”¨å…¶ä»–é…ç½® | ğŸŸ¢ è‰¯å¥½ | é€šè¿‡å¼•ç”¨ä¿æŒä¸€è‡´æ€§ |
| **x6Config.js** | âœ… åŠ¨æ€å¤„ç† | ğŸŸ¢ è‰¯å¥½ | ä¸ç¡¬ç¼–ç èŠ‚ç‚¹ç±»å‹ |
| **PortConfigurationFactory** | âŒ ç¡¬ç¼–ç éƒ¨åˆ†ç±»å‹ | ğŸ”´ ä¸¥é‡ | ç¼ºå°‘æ–°å¢èŠ‚ç‚¹ç±»å‹ |
| **canvas.d.ts** | âŒ ç±»å‹å®šä¹‰ä¸å®Œæ•´ | ğŸ”´ ä¸¥é‡ | TypeScriptç±»å‹è¿‡æ—¶ |

#### ğŸ¯ æ ·å¼ç³»ç»Ÿä¿®å¤å»ºè®®

**1. å»ºç«‹ç»Ÿä¸€çš„èŠ‚ç‚¹ç±»å‹å¸¸é‡æ–‡ä»¶**
```javascript
// å»ºè®®åˆ›å»ºï¼š/src/constants/nodeTypes.js
export const NODE_TYPES = {
  // æµç¨‹æ§åˆ¶
  START: 'start',
  END: 'end',
  
  // åˆ†æµèŠ‚ç‚¹  
  AUDIENCE_SPLIT: 'audience-split',
  EVENT_SPLIT: 'event-split',
  AB_TEST: 'ab-test',
  CONDITION: 'condition',
  
  // è§¦è¾¾èŠ‚ç‚¹
  SMS: 'sms',
  EMAIL: 'email', 
  WECHAT: 'wechat',
  AI_CALL: 'ai-call',
  MANUAL_CALL: 'manual-call',
  
  // åŠŸèƒ½èŠ‚ç‚¹
  WAIT: 'wait',
  BENEFIT: 'benefit',
  TASK: 'task'
}

export const NODE_TYPE_ARRAY = Object.values(NODE_TYPES)
```

**2. æ›´æ–°æ‰€æœ‰é…ç½®æ–‡ä»¶å¼•ç”¨ç»Ÿä¸€å¸¸é‡**
```javascript
// nodeTypes.js ä¸­ä½¿ç”¨
import { NODE_TYPES } from '../constants/nodeTypes.js'

export const nodeTypes = {
  [NODE_TYPES.START]: { /* é…ç½® */ },
  [NODE_TYPES.SMS]: { /* é…ç½® */ },
  // ...
}
```

**3. æ·»åŠ èŠ‚ç‚¹ç±»å‹éªŒè¯ä¸­é—´ä»¶**
```javascript
// å»ºè®®åˆ›å»ºï¼š/src/utils/nodeTypeValidator.js
import { NODE_TYPE_ARRAY } from '../constants/nodeTypes.js'

export const validateNodeType = (nodeType) => {
  if (!NODE_TYPE_ARRAY.includes(nodeType)) {
    throw new Error(`ä¸æ”¯æŒçš„èŠ‚ç‚¹ç±»å‹: ${nodeType}`)
  }
  return true
}
```

#### ğŸ“Š ä¿®å¤å½±å“è¯„ä¼°

| ä¿®å¤é¡¹ç›® | å½±å“èŒƒå›´ | é£é™©ç­‰çº§ | é¢„è®¡å·¥ä½œé‡ |
|---------|---------|---------|-----------|
| ç»Ÿä¸€èŠ‚ç‚¹ç±»å‹å¸¸é‡ | ğŸ”´ å…¨ç³»ç»Ÿ | ğŸŸ¡ ä¸­ç­‰ | 2-3å°æ—¶ |
| æ›´æ–°PortConfigurationFactory | ğŸŸ¡ ç«¯å£é…ç½® | ğŸŸ¢ ä½ | 1å°æ—¶ |
| ä¿®å¤TypeScriptç±»å‹å®šä¹‰ | ğŸŸ¡ ç±»å‹æ£€æŸ¥ | ğŸŸ¢ ä½ | 30åˆ†é’Ÿ |
| æ·»åŠ ç±»å‹éªŒè¯ | ğŸŸ¢ é”™è¯¯é¢„é˜² | ğŸŸ¢ ä½ | 1å°æ—¶ |

#### âœ… æ ·å¼ç³»ç»Ÿä¼˜åŠ¿

**å½“å‰æ ·å¼ç³»ç»Ÿçš„ä¼˜ç‚¹ï¼š**
1. **nodeTypes.js é…ç½®å®Œæ•´** - åŒ…å«æ‰€æœ‰å®é™…æ”¯æŒçš„èŠ‚ç‚¹ç±»å‹
2. **åŠ¨æ€æ ·å¼å¤„ç†** - x6Config.js æ”¯æŒä»»æ„èŠ‚ç‚¹ç±»å‹çš„æ ·å¼ç”Ÿæˆ
3. **é…ç½®åˆ†ç¦»è‰¯å¥½** - æ ·å¼ã€ç«¯å£ã€ç”»å¸ƒé…ç½®åˆ†åˆ«ç®¡ç†
4. **æ‰©å±•æ€§å¼º** - æ–°å¢èŠ‚ç‚¹ç±»å‹åªéœ€åœ¨ nodeTypes.js ä¸­æ·»åŠ é…ç½®

**éœ€è¦æ”¹è¿›çš„åœ°æ–¹ï¼š**
1. **ç±»å‹å®šä¹‰æ»å** - TypeScript ç±»å‹å®šä¹‰éœ€è¦åŒæ­¥æ›´æ–°
2. **ç«¯å£é…ç½®ä¸å®Œæ•´** - PortConfigurationFactory ç¼ºå°‘æ–°èŠ‚ç‚¹ç±»å‹
3. **ç¼ºå°‘ç»Ÿä¸€å¸¸é‡** - å„æ–‡ä»¶ä¸­ç¡¬ç¼–ç èŠ‚ç‚¹ç±»å‹å­—ç¬¦ä¸²

**ç«¯å£é…ç½®ç”Ÿæˆï¼š**

**ç«¯å£é…ç½®å®ç°ï¼š**

```javascript
// å®é™…ç«¯å£åŠŸèƒ½é€šè¿‡ PortConfigurationFactory å®ç°
// ä½ç½®ï¼šsrc/pages/marketing/tasks/utils/canvas/PortConfigurationFactory.js
export class PortConfigurationFactory {
  static createPortConfig(nodeType, options = {}) {
    // æ ¹æ®èŠ‚ç‚¹ç±»å‹åˆ›å»ºç«¯å£é…ç½®
    return this.getPortConfigByType(nodeType, options)
  }
  
  static getPortConfigByType(nodeType, options) {
    // æ”¯æŒçš„èŠ‚ç‚¹ç±»å‹ï¼šstart, end, audience-split, event-split, sms, ai-call, manual-call, ab-test, wait
    const configs = {
      'start': { /* å¼€å§‹èŠ‚ç‚¹ç«¯å£é…ç½® */ },
      'end': { /* ç»“æŸèŠ‚ç‚¹ç«¯å£é…ç½® */ },
      'audience-split': { /* äººç¾¤åˆ†æµç«¯å£é…ç½® */ },
      'event-split': { /* äº‹ä»¶åˆ†æµç«¯å£é…ç½® */ },
      'sms': { /* çŸ­ä¿¡è§¦è¾¾ç«¯å£é…ç½® */ },
      'ai-call': { /* AIå¤–å‘¼ç«¯å£é…ç½® */ },
      'manual-call': { /* äººå·¥å¤–å‘¼ç«¯å£é…ç½® */ },
      'ab-test': { /* ABå®éªŒç«¯å£é…ç½® */ },
      'wait': { /* ç­‰å¾…èŠ‚ç‚¹ç«¯å£é…ç½® */ }
    }
    
    return configs[nodeType] || configs['start']
  }
}
```

### 2.4 èŠ‚ç‚¹åæ ‡è®¡ç®—ç³»ç»Ÿ

#### ğŸ“ NodeCoordinateService åæ ‡æœåŠ¡

**æ ¸å¿ƒèŒè´£ï¼š**
- èŠ‚ç‚¹ä½ç½®è®¡ç®—å’Œç®¡ç†
- è‡ªåŠ¨å¸ƒå±€ç®—æ³•
- åæ ‡å˜æ¢å’Œç¼©æ”¾
- ç¢°æ’æ£€æµ‹å’Œé¿è®©

**å…³é”®åŠŸèƒ½ï¼š**

```javascript
class NodeCoordinateService {
  constructor(graph) {
    this.graph = graph
    this.layoutEngine = new LayoutEngine()
    this.gridSize = 20
    this.snapToGrid = true
  }
  
  // è®¡ç®—èŠ‚ç‚¹ä½ç½®
  calculateNodePosition(nodeData, options = {}) {
    let position = { x: 0, y: 0 }
    
    if (nodeData.position) {
      position = { ...nodeData.position }
    } else if (options.autoPosition) {
      position = this.calculateAutoPosition(nodeData.type, options)
    } else {
      position = this.getDefaultPosition(nodeData.type)
    }
    
    // ç½‘æ ¼å¯¹é½
    if (this.snapToGrid) {
      position = this.snapPositionToGrid(position)
    }
    
    // ç¢°æ’æ£€æµ‹
    if (options.avoidCollision) {
      position = this.avoidCollision(position, nodeData)
    }
    
    return position
  }
  
  // è‡ªåŠ¨ä½ç½®è®¡ç®—
  calculateAutoPosition(nodeType, options) {
    const existingNodes = this.graph.getNodes()
    
    if (existingNodes.length === 0) {
      return { x: 100, y: 100 }
    }
    
    // æ ¹æ®èŠ‚ç‚¹ç±»å‹ç¡®å®šä½ç½®ç­–ç•¥
    switch (nodeType) {
      case 'start':
        return this.calculateStartNodePosition()
      case 'end':
        return this.calculateEndNodePosition()
      default:
        return this.calculateProcessNodePosition(options)
    }
  }
  
  // èµ·å§‹èŠ‚ç‚¹ä½ç½®è®¡ç®—
  calculateStartNodePosition() {
    const startNodes = this.graph.getNodes().filter(node => 
      node.getData().type === 'start'
    )
    
    if (startNodes.length === 0) {
      return { x: 50, y: 200 }
    }
    
    // å¦‚æœå·²æœ‰èµ·å§‹èŠ‚ç‚¹ï¼Œåœ¨ä¸‹æ–¹åˆ›å»ºæ–°çš„
    const lastStartNode = startNodes[startNodes.length - 1]
    const lastPosition = lastStartNode.getPosition()
    
    return {
      x: lastPosition.x,
      y: lastPosition.y + 150
    }
  }
  
  // å¤„ç†èŠ‚ç‚¹ä½ç½®è®¡ç®—
  calculateProcessNodePosition(options) {
    const { referenceNodeId, direction = 'right', offset = 200 } = options
    
    if (referenceNodeId) {
      const referenceNode = this.graph.getCellById(referenceNodeId)
      if (referenceNode) {
        const refPosition = referenceNode.getPosition()
        const refSize = referenceNode.getSize()
        
        const directionOffsets = {
          right: { x: refSize.width + offset, y: 0 },
          left: { x: -offset, y: 0 },
          bottom: { x: 0, y: refSize.height + offset },
          top: { x: 0, y: -offset }
        }
        
        const offsetVector = directionOffsets[direction] || directionOffsets.right
        
        return {
          x: refPosition.x + offsetVector.x,
          y: refPosition.y + offsetVector.y
        }
      }
    }
    
    // é»˜è®¤ä½ç½®è®¡ç®—
    return this.calculateDefaultProcessPosition()
  }
  
  // ç½‘æ ¼å¯¹é½
  snapPositionToGrid(position) {
    return {
      x: Math.round(position.x / this.gridSize) * this.gridSize,
      y: Math.round(position.y / this.gridSize) * this.gridSize
    }
  }
  
  // ç¢°æ’é¿è®©
  avoidCollision(position, nodeData) {
    const nodeSize = {
      width: nodeData.width || 120,
      height: nodeData.height || 60
    }
    
    const existingNodes = this.graph.getNodes()
    let adjustedPosition = { ...position }
    let attempts = 0
    const maxAttempts = 50
    
    while (attempts < maxAttempts) {
      const hasCollision = existingNodes.some(node => {
        const nodePos = node.getPosition()
        const nodeSize = node.getSize()
        
        return this.checkRectangleCollision(
          adjustedPosition, nodeSize,
          nodePos, nodeSize
        )
      })
      
      if (!hasCollision) {
        break
      }
      
      // è°ƒæ•´ä½ç½®
      adjustedPosition.x += this.gridSize
      if (adjustedPosition.x > 800) {
        adjustedPosition.x = position.x
        adjustedPosition.y += this.gridSize * 2
      }
      
      attempts++
    }
    
    return adjustedPosition
  }
  
  // çŸ©å½¢ç¢°æ’æ£€æµ‹
  checkRectangleCollision(pos1, size1, pos2, size2) {
    const margin = 10 // æœ€å°é—´è·
    
    return !(
      pos1.x + size1.width + margin < pos2.x ||
      pos2.x + size2.width + margin < pos1.x ||
      pos1.y + size1.height + margin < pos2.y ||
      pos2.y + size2.height + margin < pos1.y
    )
  }
}
```

### 2.5 èŠ‚ç‚¹åˆ é™¤ç³»ç»Ÿ

#### ğŸ—‘ï¸ èŠ‚ç‚¹åˆ é™¤æœåŠ¡

**æ ¸å¿ƒåŠŸèƒ½ï¼š**

```javascript
class NodeDeletionService {
  constructor(graph, unifiedEdgeManager) {
    this.graph = graph
    this.unifiedEdgeManager = unifiedEdgeManager
  }
  
  // åˆ é™¤å•ä¸ªèŠ‚ç‚¹
  async deleteNode(nodeId, options = {}) {
    try {
      const node = this.graph.getCellById(nodeId)
      if (!node) {
        console.warn('[NodeDeletionService] èŠ‚ç‚¹ä¸å­˜åœ¨:', nodeId)
        return false
      }
      
      // 1. æ¸…ç†ç›¸å…³è¿æ¥
      await this.cleanupNodeConnections(nodeId)
      
      // 2. æ¸…ç†é¢„è§ˆçº¿
      await this.cleanupNodePreviewLines(nodeId)
      
      // 3. æ¸…ç†èŠ‚ç‚¹é…ç½®
      await this.cleanupNodeConfig(nodeId)
      
      // 4. ä»ç”»å¸ƒç§»é™¤èŠ‚ç‚¹
      this.graph.removeCell(node)
      
      console.log('[NodeDeletionService] âœ… èŠ‚ç‚¹åˆ é™¤æˆåŠŸ:', nodeId)
      return true
      
    } catch (error) {
      console.error('[NodeDeletionService] âŒ èŠ‚ç‚¹åˆ é™¤å¤±è´¥:', error)
      return false
    }
  }
  
  // æ¸…ç†èŠ‚ç‚¹è¿æ¥
  async cleanupNodeConnections(nodeId) {
    const connectedEdges = this.graph.getConnectedEdges(nodeId)
    
    for (const edge of connectedEdges) {
      try {
        this.graph.removeCell(edge)
        console.log('[NodeDeletionService] æ¸…ç†è¿æ¥:', edge.id)
      } catch (error) {
        console.error('[NodeDeletionService] æ¸…ç†è¿æ¥å¤±è´¥:', error)
      }
    }
  }
  
  // æ¸…ç†èŠ‚ç‚¹é¢„è§ˆçº¿
  async cleanupNodePreviewLines(nodeId) {
    if (!this.unifiedEdgeManager) {
      console.warn('[NodeDeletionService] UnifiedEdgeManagerä¸å¯ç”¨')
      return
    }
    
    try {
      await this.unifiedEdgeManager.cleanupNodePreviewLines(nodeId)
      console.log('[NodeDeletionService] âœ… é¢„è§ˆçº¿æ¸…ç†æˆåŠŸ:', nodeId)
    } catch (error) {
      console.error('[NodeDeletionService] âŒ é¢„è§ˆçº¿æ¸…ç†å¤±è´¥:', error)
    }
  }
  
  // æ‰¹é‡åˆ é™¤èŠ‚ç‚¹
  async batchDeleteNodes(nodeIds, options = {}) {
    const results = []
    
    for (const nodeId of nodeIds) {
      const result = await this.deleteNode(nodeId, options)
      results.push({ nodeId, success: result })
    }
    
    const successCount = results.filter(r => r.success).length
    console.log(`[NodeDeletionService] æ‰¹é‡åˆ é™¤å®Œæˆ: ${successCount}/${nodeIds.length}`)
    
    return results
  }
}
```

### 2.6 èŠ‚ç‚¹é…ç½®ç³»ç»Ÿ

#### âš™ï¸ NodeConfigService é…ç½®æœåŠ¡

**æ ¸å¿ƒåŠŸèƒ½ï¼š**

```javascript
class NodeConfigService {
  constructor(graph) {
    this.graph = graph
    this.configDrawer = null
    this.configCache = new Map()
  }
  
  // æ‰“å¼€èŠ‚ç‚¹é…ç½®
  openNodeConfig(nodeId) {
    const node = this.graph.getCellById(nodeId)
    if (!node) {
      console.error('[NodeConfigService] èŠ‚ç‚¹ä¸å­˜åœ¨:', nodeId)
      return false
    }
    
    try {
      const nodeData = node.getData()
      const configSchema = this.getConfigSchema(nodeData.type)
      
      // æ‰“å¼€é…ç½®æŠ½å±‰
      if (this.configDrawer) {
        this.configDrawer.open({
          nodeId,
          nodeData,
          configSchema,
          onSave: (updatedConfig) => this.saveNodeConfig(nodeId, updatedConfig),
          onCancel: () => this.configDrawer.close()
        })
      }
      
      return true
    } catch (error) {
      console.error('[NodeConfigService] æ‰“å¼€é…ç½®å¤±è´¥:', error)
      return false
    }
  }
  
  // ä¿å­˜èŠ‚ç‚¹é…ç½®
  saveNodeConfig(nodeId, configData) {
    const node = this.graph.getCellById(nodeId)
    if (!node) return false
    
    try {
      // éªŒè¯é…ç½®æ•°æ®
      const validatedConfig = this.validateConfigData(configData)
      
      // æ›´æ–°èŠ‚ç‚¹æ•°æ®
      node.setData({
        ...node.getData(),
        ...validatedConfig
      })
      
      // æ›´æ–°èŠ‚ç‚¹æ ·å¼ï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (validatedConfig.style) {
        node.setAttrs(validatedConfig.style)
      }
      
      // ç¼“å­˜é…ç½®
      this.configCache.set(nodeId, validatedConfig)
      
      console.log('[NodeConfigService] âœ… é…ç½®ä¿å­˜æˆåŠŸ:', nodeId)
      return true
      
    } catch (error) {
      console.error('[NodeConfigService] âŒ é…ç½®ä¿å­˜å¤±è´¥:', error)
      return false
    }
  }
  
  // è·å–é…ç½®æ¨¡å¼
  getConfigSchema(nodeType) {
    const schemas = {
      'start': {
        title: 'å¼€å§‹èŠ‚ç‚¹é…ç½®',
        fields: [
          { key: 'name', label: 'èŠ‚ç‚¹åç§°', type: 'text', required: true },
          { key: 'description', label: 'æè¿°', type: 'textarea' }
        ]
      },
      'process': {
        title: 'å¤„ç†èŠ‚ç‚¹é…ç½®',
        fields: [
          { key: 'name', label: 'èŠ‚ç‚¹åç§°', type: 'text', required: true },
          { key: 'description', label: 'æè¿°', type: 'textarea' },
          { key: 'timeout', label: 'è¶…æ—¶æ—¶é—´(ç§’)', type: 'number' },
          { key: 'retryCount', label: 'é‡è¯•æ¬¡æ•°', type: 'number' }
        ]
      },
      'decision': {
        title: 'å†³ç­–èŠ‚ç‚¹é…ç½®',
        fields: [
          { key: 'name', label: 'èŠ‚ç‚¹åç§°', type: 'text', required: true },
          { key: 'condition', label: 'åˆ¤æ–­æ¡ä»¶', type: 'text', required: true },
          { key: 'trueLabel', label: 'çœŸå€¼æ ‡ç­¾', type: 'text' },
          { key: 'falseLabel', label: 'å‡å€¼æ ‡ç­¾', type: 'text' }
        ]
      }
    }
    
    return schemas[nodeType] || schemas['process']
  }
}
```

## ğŸ”„ ç³»ç»Ÿé›†æˆä¸äº¤äº’

### 3.1 ä¸ç”»å¸ƒç³»ç»Ÿé›†æˆ

```javascript
// èŠ‚ç‚¹ç®¡ç†å™¨ä¸ç”»å¸ƒç³»ç»Ÿçš„é›†æˆ
class NodeCanvasIntegration {
  constructor(graph, canvasServiceManager) {
    this.graph = graph
    this.canvasServiceManager = canvasServiceManager
    this.nodeManager = new NodeManager(graph)
    
    this.initializeIntegration()
  }
  
  initializeIntegration() {
    // æ³¨å†ŒèŠ‚ç‚¹æœåŠ¡åˆ°ç”»å¸ƒæœåŠ¡ç®¡ç†å™¨
    this.canvasServiceManager.register('NodeCreationService', this.nodeManager.creationService)
    this.canvasServiceManager.register('NodeStyleService', this.nodeManager.styleService)
    this.canvasServiceManager.register('PortConfigurationFactory', this.portConfigFactory)
    this.canvasServiceManager.register('NodeCoordinateService', this.nodeManager.coordinateService)
    this.canvasServiceManager.register('NodeConfigService', this.nodeManager.configService)
    
    // ç›‘å¬ç”»å¸ƒäº‹ä»¶
    this.setupCanvasEventListeners()
  }
  
  setupCanvasEventListeners() {
    // èŠ‚ç‚¹åˆ›å»ºäº‹ä»¶
    this.graph.on('node:added', ({ node }) => {
      console.log('[NodeCanvasIntegration] èŠ‚ç‚¹å·²æ·»åŠ :', node.id)
      this.nodeManager.onNodeAdded(node)
    })
    
    // èŠ‚ç‚¹åˆ é™¤äº‹ä»¶
    this.graph.on('node:removed', ({ node }) => {
      console.log('[NodeCanvasIntegration] èŠ‚ç‚¹å·²åˆ é™¤:', node.id)
      this.nodeManager.onNodeRemoved(node)
    })
    
    // èŠ‚ç‚¹é€‰æ‹©äº‹ä»¶
    this.graph.on('node:selected', ({ node }) => {
      this.nodeManager.styleService.updateNodeState(node.id, 'selected', true)
    })
    
    // èŠ‚ç‚¹å–æ¶ˆé€‰æ‹©äº‹ä»¶
    this.graph.on('node:unselected', ({ node }) => {
      this.nodeManager.styleService.updateNodeState(node.id, 'selected', false)
    })
  }
}
```

### 3.2 ä¸é¢„è§ˆçº¿ç³»ç»Ÿäº¤äº’

```javascript
// èŠ‚ç‚¹ä¸é¢„è§ˆçº¿ç³»ç»Ÿçš„äº¤äº’
class NodePreviewLineIntegration {
  constructor(nodeManager, unifiedEdgeManager) {
    this.nodeManager = nodeManager
    this.unifiedEdgeManager = unifiedEdgeManager
    
    this.setupPreviewLineIntegration()
  }
  
  setupPreviewLineIntegration() {
    // èŠ‚ç‚¹ç«¯å£è¿æ¥å¼€å§‹æ—¶åˆ›å»ºé¢„è§ˆçº¿
    this.nodeManager.portService.on('port:connect:start', async ({ sourceNodeId, sourcePortId }) => {
      try {
        await this.unifiedEdgeManager.createPreviewLine(sourceNodeId, {
          sourcePortId,
          interactive: true
        })
      } catch (error) {
        console.error('[NodePreviewLineIntegration] é¢„è§ˆçº¿åˆ›å»ºå¤±è´¥:', error)
      }
    })
    
    // èŠ‚ç‚¹åˆ é™¤æ—¶æ¸…ç†ç›¸å…³é¢„è§ˆçº¿
    this.nodeManager.on('node:before:delete', async ({ nodeId }) => {
      try {
        await this.unifiedEdgeManager.cleanupNodePreviewLines(nodeId)
      } catch (error) {
        console.error('[NodePreviewLineIntegration] é¢„è§ˆçº¿æ¸…ç†å¤±è´¥:', error)
      }
    })
  }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 4.1 èŠ‚ç‚¹æ¸²æŸ“ä¼˜åŒ–

```javascript
// èŠ‚ç‚¹æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–
class NodeRenderOptimizer {
  constructor(graph) {
    this.graph = graph
    this.renderQueue = []
    this.isRendering = false
    this.batchSize = 10
  }
  
  // æ‰¹é‡æ¸²æŸ“èŠ‚ç‚¹
  batchRenderNodes(nodes) {
    this.renderQueue.push(...nodes)
    
    if (!this.isRendering) {
      this.processRenderQueue()
    }
  }
  
  async processRenderQueue() {
    this.isRendering = true
    
    while (this.renderQueue.length > 0) {
      const batch = this.renderQueue.splice(0, this.batchSize)
      
      await Promise.all(batch.map(node => this.renderNode(node)))
      
      // è®©å‡ºæ§åˆ¶æƒï¼Œé¿å…é˜»å¡UI
      await new Promise(resolve => setTimeout(resolve, 0))
    }
    
    this.isRendering = false
  }
  
  async renderNode(nodeData) {
    try {
      const node = await this.nodeManager.creationService.createNode(nodeData)
      return node
    } catch (error) {
      console.error('[NodeRenderOptimizer] èŠ‚ç‚¹æ¸²æŸ“å¤±è´¥:', error)
      return null
    }
  }
}
```

## ğŸ¯ æ€»ç»“

èŠ‚ç‚¹æ ¸å¿ƒåŠŸèƒ½ç³»ç»Ÿé€šè¿‡æ¨¡å—åŒ–çš„æ¶æ„è®¾è®¡ï¼Œå®ç°äº†ï¼š

### âœ… æ ¸å¿ƒä¼˜åŠ¿
- **å®Œæ•´çš„èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šä»åˆ›å»ºåˆ°åˆ é™¤çš„å…¨æµç¨‹æ”¯æŒ
- **çµæ´»çš„æ ·å¼ç³»ç»Ÿ**ï¼šæ”¯æŒä¸»é¢˜ã€çŠ¶æ€å’Œè‡ªå®šä¹‰æ ·å¼
- **æ™ºèƒ½çš„åæ ‡è®¡ç®—**ï¼šè‡ªåŠ¨å¸ƒå±€ã€ç¢°æ’é¿è®©ã€ç½‘æ ¼å¯¹é½
- **å¼ºå¤§çš„ç«¯å£ç³»ç»Ÿ**ï¼šç±»å‹éªŒè¯ã€è¿æ¥ç®¡ç†ã€äº¤äº’æ”¯æŒ
- **ç»Ÿä¸€çš„é…ç½®ç®¡ç†**ï¼šå¯æ‰©å±•çš„é…ç½®æ¨¡å¼å’ŒéªŒè¯æœºåˆ¶
- **é«˜æ€§èƒ½æ¸²æŸ“**ï¼šæ‰¹é‡å¤„ç†ã€å¼‚æ­¥æ¸²æŸ“ã€èµ„æºä¼˜åŒ–

### ğŸ”§ æŠ€æœ¯ç‰¹ç‚¹
- **æœåŠ¡åŒ–æ¶æ„**ï¼šå„åŠŸèƒ½æ¨¡å—ç‹¬ç«‹ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•
- **äº‹ä»¶é©±åŠ¨**ï¼šå“åº”å¼çš„äº¤äº’å’ŒçŠ¶æ€ç®¡ç†
- **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„æ•°æ®éªŒè¯å’Œé”™è¯¯å¤„ç†
- **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰¹é‡æ“ä½œã€ç¼“å­˜æœºåˆ¶ã€å¼‚æ­¥å¤„ç†

### ğŸš€ æ‰©å±•æ€§
- **æ’ä»¶åŒ–ç«¯å£ç±»å‹**ï¼šæ”¯æŒè‡ªå®šä¹‰ç«¯å£ç±»å‹å’ŒéªŒè¯è§„åˆ™
- **å¯é…ç½®æ ·å¼ä¸»é¢˜**ï¼šæ”¯æŒå¤šä¸»é¢˜åˆ‡æ¢å’Œè‡ªå®šä¹‰ä¸»é¢˜
- **çµæ´»çš„å¸ƒå±€ç®—æ³•**ï¼šæ”¯æŒå¤šç§è‡ªåŠ¨å¸ƒå±€ç­–ç•¥
- **å¯æ‰©å±•é…ç½®æ¨¡å¼**ï¼šæ”¯æŒåŠ¨æ€é…ç½®å­—æ®µå’ŒéªŒè¯è§„åˆ™

è¯¥èŠ‚ç‚¹æ ¸å¿ƒåŠŸèƒ½ç³»ç»Ÿä¸ºç”»å¸ƒåº”ç”¨æä¾›äº†å®Œæ•´ã€é«˜æ•ˆã€å¯æ‰©å±•çš„èŠ‚ç‚¹ç®¡ç†è§£å†³æ–¹æ¡ˆã€‚