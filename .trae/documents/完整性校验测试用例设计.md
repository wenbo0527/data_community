1# 完整性校验测试用例设计

## 1. 测试目标

### 1.1 主要目标
- 验证所有节点坐标完整性（X和Y坐标都不能为NaN或undefined）
- 确保预览线有有效的源节点
- 验证连接线有完整的两个节点（source和target）
- 修复audience-split等特殊类型节点的Y坐标NaN问题

### 1.2 测试范围
- 节点坐标计算和设置
- 预览线管理和完整性
- 连接线完整性验证
- 布局引擎核心功能
- 异常情况处理

## 2. 测试用例分类

### 2.1 单节点测试用例

#### TC001: 基础节点坐标测试
**测试目的**: 验证单个节点的坐标计算正确性
**测试步骤**:
1. 创建单个start节点
2. 触发布局计算
3. 验证节点X、Y坐标为有效数值
**预期结果**: X、Y坐标均为有效数值，不为NaN或undefined

#### TC002: audience-split节点测试
**测试目的**: 验证audience-split节点的特殊坐标计算
**测试步骤**:
1. 创建audience-split节点
2. 触发布局计算
3. 验证节点坐标和层级分配
**预期结果**: audience-split节点正确分配到第2层，Y坐标有效

#### TC003: 各种节点类型测试
**测试目的**: 验证所有支持的节点类型坐标计算
**测试数据**:
- start节点
- audience-split节点
- manual-call节点
- ai-call节点
- event-split节点
- endpoint节点
**预期结果**: 所有节点类型都能正确计算坐标

### 2.2 多节点测试用例

#### TC004: 线性流程测试
**测试目的**: 验证线性连接的多节点布局
**测试场景**: start → audience-split → manual-call → endpoint
**验证点**:
- 节点层级分配正确
- Y坐标递增且有效
- 连接线完整性

#### TC005: 分支流程测试
**测试目的**: 验证分支结构的布局计算
**测试场景**: 
```
start → audience-split → manual-call → endpoint
                    → ai-call → endpoint
```
**验证点**:
- 分支节点正确布局
- 同层节点Y坐标一致
- 所有连接线有效

#### TC006: 复杂嵌套测试
**测试目的**: 验证复杂嵌套结构的布局
**测试场景**: 包含多层嵌套和多个分支点
**验证点**:
- 深层嵌套节点坐标正确
- 层级关系清晰
- 预览线和连接线完整

### 2.3 预览线测试用例

#### TC007: 预览线源节点验证
**测试目的**: 确保预览线有有效的源节点
**测试步骤**:
1. 创建预览线
2. 验证源节点存在且有效
3. 检查源节点坐标完整性
**预期结果**: 预览线源节点存在且坐标有效

#### TC008: 预览线终点坐标测试
**测试目的**: 验证预览线终点坐标计算
**测试步骤**:
1. 创建预览线并设置终点
2. 验证终点坐标计算正确性
3. 检查坐标更新机制
**预期结果**: 预览线终点坐标有效且实时更新

#### TC009: 预览线完整性校验
**测试目的**: 验证预览线完整性校验机制
**测试步骤**:
1. 触发预览线完整性校验
2. 检查校验结果和错误报告
3. 验证自动修复机制
**预期结果**: 完整性问题被正确识别和修复

### 2.4 连接线测试用例

#### TC010: 连接线双节点验证
**测试目的**: 确保连接线有完整的source和target节点
**测试步骤**:
1. 创建节点间连接
2. 验证连接线source和target属性
3. 检查节点引用有效性
**预期结果**: 连接线包含有效的source和target节点

#### TC011: 连接线坐标同步测试
**测试目的**: 验证连接线与节点坐标同步
**测试步骤**:
1. 移动节点位置
2. 检查连接线坐标更新
3. 验证视觉效果正确性
**预期结果**: 连接线坐标与节点位置保持同步

### 2.5 边界情况测试用例

#### TC012: 空图测试
**测试目的**: 验证空图状态下的系统稳定性
**测试步骤**:
1. 初始化空图
2. 触发布局计算
3. 检查系统状态
**预期结果**: 系统稳定运行，无错误抛出

#### TC013: 单节点图测试
**测试目的**: 验证只有一个节点时的布局计算
**测试步骤**:
1. 创建单个节点
2. 触发布局计算
3. 验证节点坐标
**预期结果**: 单节点正确定位，坐标有效

#### TC014: 大规模节点测试
**测试目的**: 验证大量节点时的性能和正确性
**测试数据**: 100+节点的复杂图
**验证点**:
- 所有节点坐标有效
- 布局计算性能可接受
- 内存使用合理

### 2.6 异常情况测试用例

#### TC015: 无效节点数据测试
**测试目的**: 验证系统对无效节点数据的处理
**测试数据**:
- 缺少必要属性的节点
- 无效节点类型
- 损坏的节点数据
**预期结果**: 系统优雅处理异常，提供有意义的错误信息

#### TC016: 循环引用测试
**测试目的**: 验证系统对循环引用的处理
**测试场景**: 创建节点间的循环连接
**预期结果**: 系统检测并处理循环引用，避免无限递归

#### TC017: 内存泄漏测试
**测试目的**: 验证长时间运行时的内存稳定性
**测试步骤**:
1. 持续创建和删除节点
2. 监控内存使用情况
3. 检查是否存在内存泄漏
**预期结果**: 内存使用稳定，无明显泄漏

## 3. 测试数据准备

### 3.1 标准测试图数据
```javascript
const testGraphData = {
  nodes: [
    { id: 'start', type: 'start', x: 100, y: 100 },
    { id: 'audience-split', type: 'audience-split', x: 200, y: NaN }, // 故意设置NaN测试修复
    { id: 'manual-call', type: 'manual-call', x: 300, y: 200 },
    { id: 'ai-call', type: 'ai-call', x: 300, y: 300 },
    { id: 'endpoint', type: 'endpoint', x: 400, y: 250 }
  ],
  edges: [
    { source: 'start', target: 'audience-split' },
    { source: 'audience-split', target: 'manual-call' },
    { source: 'audience-split', target: 'ai-call' },
    { source: 'manual-call', target: 'endpoint' },
    { source: 'ai-call', target: 'endpoint' }
  ]
};
```

### 3.2 异常测试数据
```javascript
const invalidTestData = {
  nodes: [
    { id: 'invalid1', type: 'unknown-type', x: NaN, y: undefined },
    { id: 'invalid2', x: 100 }, // 缺少type和y
    { id: 'invalid3', type: 'start', x: 'invalid', y: 'invalid' }
  ],
  edges: [
    { source: 'nonexistent', target: 'invalid1' },
    { source: 'invalid1' }, // 缺少target
    { target: 'invalid2' } // 缺少source
  ]
};
```

## 4. 测试执行策略

### 4.1 自动化测试
- 单元测试：针对核心计算方法
- 集成测试：验证组件间协作
- 端到端测试：完整流程验证

### 4.2 手动测试
- 浏览器控制台测试脚本
- 可视化验证
- 性能监控

### 4.3 回归测试
- 修复后的完整测试套件执行
- 性能基准对比
- 稳定性长期监控

## 5. 成功标准

### 5.1 功能标准
- 所有节点坐标为有效数值（非NaN、非undefined）
- 预览线源节点存在且有效
- 连接线包含完整的source和target节点
- 特殊节点类型（如audience-split）正确处理

### 5.2 性能标准
- 布局计算时间 < 100ms（100节点以内）
- 内存使用稳定，无明显泄漏
- 实时更新响应时间 < 50ms

### 5.3 稳定性标准
- 异常情况优雅处理，无系统崩溃
- 错误信息清晰有用
- 自动恢复机制有效

## 6. 测试工具和环境

### 6.1 测试工具
- Jest：单元测试框架
- 浏览器开发者工具：手动测试和调试
- 自定义测试脚本：完整性校验

### 6.2 测试环境
- 开发环境：Chrome浏览器
- 测试数据：模拟真实业务场景
- 监控工具：性能和内存监控

## 7. 风险评估

### 7.1 高风险区域
- Y坐标计算逻辑（已知问题区域）
- 层级索引计算
- 预览线管理
- 异常数据处理

### 7.2 缓解措施
- 增加详细日志记录
- 实施渐进式修复
- 保留回滚机制
- 持续监控和验证

---

**文档版本**: 1.0  
**创建时间**: 2025-01-24  
**最后更新**: 2025-01-24  
**负责人**: SOLO Coding