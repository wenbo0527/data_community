# 统一事件系统开发指南

## 概述

本指南描述了营销画布项目中统一事件系统的架构和使用方法。该系统旨在解决事件管理分散、重复绑定、难以维护的问题，通过集中式的事件管理提供一致的事件处理体验。

## 架构设计

### 核心组件

1. **统一事件总线 (UnifiedEventBus)**
   - 提供全局事件发布/订阅功能
   - 支持事件优先级管理
   - 支持事件命名空间

2. **事件类型定义 (EventTypes)**
   - 集中定义所有事件类型
   - 提供TypeScript类型支持
   - 避免硬编码事件名称

3. **键盘事件处理器 (KeyboardEventHandler)**
   - 统一的键盘事件管理
   - 支持快捷键注册和注销
   - 提供防抖和节流功能

4. **生命周期管理器 (LifecycleManager)**
   - 管理组件生命周期事件
   - 确保事件正确绑定和解绑
   - 防止内存泄漏

## 使用方法

### 1. 事件类型定义

```typescript
// 在统一位置定义事件类型
export const EventTypes = {
  CANVAS: {
    KEYDOWN: 'canvas:keydown',
    RESIZE: 'canvas:resize',
    BEFORE_UNLOAD: 'window:beforeunload',
    VISIBILITY_CHANGE: 'window:visibilitychange'
  },
  NODE: {
    SELECT: 'node:select',
    DELETE: 'node:delete'
  }
} as const
```

### 2. 使用统一事件总线

```typescript
import { useUnifiedEventBus } from '@/composables/canvas/unified/useUnifiedEventBus'
import { EventTypes } from '@/composables/canvas/unified/EventTypes'

// 在组件中注册事件
const eventBus = useUnifiedEventBus()

// 监听事件
const unsubscribe = eventBus.on(EventTypes.CANVAS.KEYDOWN, (event) => {
  console.log('键盘事件:', event)
})

// 触发自定义事件
eventBus.emit(EventTypes.NODE.SELECT, { nodeId: '123' })

// 组件卸载时注销事件
onUnmounted(() => {
  unsubscribe()
})
```

### 3. 键盘事件处理

```typescript
import { useKeyboardEventHandler } from '@/composables/canvas/unified/useKeyboardEventHandler'

const keyboardHandler = useKeyboardEventHandler()

// 注册快捷键
keyboardHandler.registerShortcut('ctrl+s', () => {
  console.log('保存快捷键被触发')
})

// 注册带条件的快捷键
keyboardHandler.registerConditionalShortcut('delete', () => {
  return hasSelectedNodes.value // 只有在有选中节点时才响应
}, () => {
  deleteSelectedNodes()
})
```

### 4. 生命周期管理

```typescript
import { useCanvasLifecycle } from '@/composables/canvas/useCanvasLifecycle'

const { 
  initialize,
  destroy,
  registerKeyboardShortcuts,
  registerContextAwareShortcuts 
} = useCanvasLifecycle()

// 初始化事件系统
await initialize()

// 注册组件特定的键盘快捷键
registerKeyboardShortcuts({
  'ctrl+z': undo,
  'ctrl+y': redo
})

// 组件卸载时清理
onUnmounted(() => {
  destroy()
})
```

## 迁移指南

### 从旧的事件绑定迁移

**旧的实现方式：**
```typescript
// 不推荐 - 直接绑定到DOM
document.addEventListener('keydown', handleKeydown)
window.addEventListener('resize', handleResize)
window.addEventListener('beforeunload', handleBeforeUnload)

// 组件卸载时需要手动解绑
onUnmounted(() => {
  document.removeEventListener('keydown', handleKeydown)
  window.removeEventListener('resize', handleResize)
  window.removeEventListener('beforeunload', handleBeforeUnload)
})
```

**新的实现方式：**
```typescript
// 推荐 - 使用统一事件系统
const eventBus = useUnifiedEventBus()
const keyboardHandler = useKeyboardEventHandler()

// 注册事件监听器
const unsubscribeKeydown = eventBus.on(EventTypes.CANVAS.KEYDOWN, handleKeydown)
const unsubscribeResize = eventBus.on(EventTypes.CANVAS.RESIZE, handleResize)
const unsubscribeBeforeUnload = eventBus.on(EventTypes.CANVAS.BEFORE_UNLOAD, handleBeforeUnload)

// 注册键盘快捷键
keyboardHandler.registerShortcut('delete', handleDelete)

// 组件卸载时自动清理
onUnmounted(() => {
  // 统一事件系统会自动清理
})
```

## 最佳实践

### 1. 事件命名规范
- 使用命名空间格式：`模块:事件名`
- 保持命名的一致性
- 使用动词描述事件动作

### 2. 事件处理规范
- 优先使用声明式事件注册
- 避免在事件处理器中执行耗时操作
- 使用防抖和节流优化高频事件

### 3. 错误处理
- 事件处理器应该包含错误处理逻辑
- 使用try-catch捕获可能的异常
- 记录错误日志便于调试

### 4. 性能优化
- 及时注销不需要的事件监听
- 避免重复注册相同的事件
- 使用事件委托减少监听器数量

## 常见问题

### Q: 如何调试事件系统？
A: 使用浏览器开发者工具的Event Listeners面板，或使用统一事件总线提供的调试模式。

### Q: 事件处理顺序如何控制？
A: 通过事件优先级系统，高优先级的事件会先被处理。

### Q: 如何处理跨组件的事件通信？
A: 使用统一事件总线的发布/订阅模式，避免直接的组件间引用。

## 维护记录

- 2024-01: 初始版本发布
- 2024-02: 添加键盘事件处理器
- 2024-03: 优化事件优先级系统