# 旧版画布连线到横版端口映射方案（保证与原图一致）

## 1. 背景与问题

横版画布（`apps/horizontal-canvas`）的节点出端口采用 `out-0/out-1/...` 的“按行”策略；旧版画布数据里，常见的 `connections` 仅包含 `{ source, target, label }`，并不包含端口信息，因此在横版加载时必须“推断”每条边应绑定哪个 `out-N`。

如果不显式做映射，横版当前加载逻辑会按“遍历顺序 + 找第一个未占用 out 端口”分配，导致：
- 同一个源节点的多条出边，`out-N` 绑定取决于 `connections` 数组顺序；
- 一旦导入/存储过程改变了 `connections` 的顺序，就可能出现“分支走错线/端口对应错行”的问题；
- 分流/AB 节点的分支校验依赖 `edge.data.branchId`，旧数据缺失时更容易不稳定。

本方案的目标：在不依赖加载时“猜测”的前提下，将旧版连接稳定映射为横版所需的端口字段，使加载后的连线语义与原图一致、可复现。

## 2. 现有实现与关键事实（用于对齐方案）

### 2.1 横版端口命名与数量规则

横版节点端口生成规则（重点）：
- 入端口：固定为 `in`（除 start 节点无入端口）
- 出端口：按展示行生成 `out-0/out-1/...`（start 固定 `out-0`；end 无出端口）
- 出端口数量由 `buildDisplayLines(nodeType, config)` 生成的 `rows` 决定（多数节点为 1；分流/AB 多行）

参考实现：
- 节点规格与 outIds：`apps/horizontal-canvas/src/pages/marketing/tasks/horizontal/createVueShapeNode.js`
- 端口工厂：`apps/horizontal-canvas/src/pages/marketing/tasks/horizontal/utils/portConfigFactoryHorizontal.js`

### 2.2 横版加载旧 connections 的“隐式映射”行为

横版加载时的连线创建（简化描述）：
- 若 `connectionData.sourcePort/sourcePortId` 缺失，默认使用 `'out'`
- 但横版 out 端口实际为 `out-0/out-1/...`，因此 `'out'` 通常不存在，会触发“回填”：
  - 读取源节点所有 out 端口
  - 查找该节点当前已占用端口
  - 选择第一个未占用 out 端口作为本条边的 `sourcePort`

参考实现：
- `apps/horizontal-canvas/src/pages/marketing/tasks/horizontal/persistence/PersistenceService.ts` 的 `loadCanvasData`

结论：如果旧数据不带端口，端口分配对 `connections` 遍历顺序敏感，无法保证与原图一致。

## 3. 旧版数据形态（需要兼容）

旧版常见边结构：
- `connections[i] = { source: string, target: string, label?: string }`

示例（任务列表 mock 数据）：
- `src/pages/marketing/tasks/index.vue`

也可能出现的扩展字段（视历史版本而定）：
- `id`
- `sourcePort/targetPort`（旧版若曾支持端口）
- `sourcePortId/targetPortId`（部分中间版本）
- `data.branchId` 或 `branchId`（分支标识）

## 4. 总体原则（保证“与原图一致”）

### 4.1 不把“端口选择”交给加载时推断

要保证一致性，必须在迁移阶段把每条边明确变成：
- `targetPortId = 'in'`
- `sourcePortId = 'out-k'`（k 为确定的整数）
- 对分支节点，尽量补齐 `branchId`（可选但强烈建议）

这样横版加载会直接使用给定端口，不再依赖遍历顺序。

### 4.2 端口的“语义”优先于“形状/坐标”

横版 out 端口与“展示行（rows）”绑定，本质语义是：
- `out-0` 对应第 1 行
- `out-1` 对应第 2 行
- …

因此“与原图一致”应理解为：原图每条分支/路径对应到横版的同一语义分支，而不是单纯保持连线外观一致。

### 4.3 端口映射必须基于“原图可识别的分支标识”

对于分流/AB 节点，多条出边的“哪个分支”必须能被识别：
- 最理想：旧边/旧节点已经携带 branchId（或能还原 branchId）
- 次理想：旧边的 label 可与节点配置中的分支名称一一对应
- 最后兜底：需要确定性排序规则，保证每次迁移得到同样的 out-k

## 5. 映射流程（建议执行顺序）

### Step 0：先完成节点侧的“分支信息标准化”

因为 out 端口数量与顺序由 `buildDisplayLines(nodeType, config)` 决定，所以必须先确保：
- 节点 `type` 与 `config` 已迁移到横版可识别形态
- 分支列表来源明确（例如 `config.branches`、`config.crowdLayers`、`variants/versions` 等）

否则会出现：你先给边分配了 `out-2`，但节点实际只生成了 `out-0/out-1`，最终仍会回填到别的端口。

### Step 1：为每条边补齐目标端口

规则：
- `targetPortId = 'in'`（start 节点无入端口时需要跳过/特殊处理，但 start 一般不会作为 target）

### Step 2：为每条边计算源端口 sourcePortId（核心）

按节点类型分两类：

#### A) 单出边节点（绝大多数）

规则：
- `sourcePortId = 'out-0'`

适用：
- start（固定 out-0）
- sms/wait/benefit/ai-call/manual-call…（通常仅一条 out 行）

#### B) 多出边节点（分流/AB/事件分流）

适用：
- `crowd-split / audience-split / event-split / ab-test`（以及历史别名）

映射优先级（从高到低）：

1) **优先使用 branchId（强一致）**
   - 若边已有 `branchId` 或 `edge.data.branchId`
   - 在源节点分支数组中找到 `branch.id === branchId` 的索引 `k`
   - `sourcePortId = 'out-' + k`

2) **使用 label 匹配分支名称（中一致）**
   - 若边没有 branchId，但有 `label`
   - 将 `label` 与源节点分支名称匹配得到索引 `k`
   - `sourcePortId = 'out-' + k`

   分支名称来源建议（与横版行展示一致）：
   - 人群分流：`config.crowdLayers[].crowdName/name` 或 `config.branches[].name`
   - 事件分流：业务定义的分支名（例如 “发生/未发生”、“成功/失败”）
   - AB：`branches/variants/versions[].name`

3) **确定性兜底分配（弱一致但可复现）**
   - 对同一 source 节点的多条出边，进行确定性排序，然后按序号分配 out-0/out-1/…
   - 推荐排序 key（保证稳定）：
     1. `target` 节点在 `nodes` 数组中的索引（或 target 的 x/y：先 x 再 y）
     2. `target` 字符串字典序
     3. `edge.id`（如存在）

> 注意：兜底策略只能保证“迁移结果可复现”，但不一定保证“分支语义与原图一致”。要做到语义一致，必须能用 branchId 或 label 对齐。

### Step 3（推荐）：补齐 branchId 以通过分支完整性校验

对于 AB/分流节点，如果你已经确定了 `sourcePortId = out-k`，且源节点分支数组存在第 k 个分支：
- 令 `branchId = branches[k].id`

这样后续横版的分支完整性校验（“每个分支必须有连线”）能稳定工作。

## 6. 如何分配 out 端口才能保证与原图一致（详细规则）

这一节回答“怎样分配 out 才能保证图和原图一致”的核心：**必须还原原图的‘分支→连线’对应关系**。

### 6.1 定义“原图一致”的判定口径

对分流/AB 节点，原图一致等价于：
- 原图的“黑名单/高响应/中响应/低响应”等分支，迁移后仍连接到相同的下游节点集合；
- 横版 `out-k` 对应的行文本（分支名）与该分支出边一致。

### 6.2 推荐的“强一致”方式：分支 ID 驱动

只要你能做到：
- 节点分支数组每个分支都有稳定的 `branch.id`
- 每条边都携带该 `branchId`

那么：
- `out-k` 只需要绑定到 `branches[k]`
- 边的 `sourcePortId` 通过 `branchId -> index` 映射

这在“分支重命名/排序调整”场景也能保持语义一致（因为靠 id 不是靠 label）。

### 6.3 次优方式：分支 label 驱动（必须有严格规范）

如果历史数据里只有 `label`，要保证一致，需要保证：
- `label` 与节点配置中的分支名称完全一致（或在规范化后可一致）
- 同一节点下分支 label 唯一（否则无法确定 out-k）

建议在迁移前做 label 规范化（仅方案建议，不涉及修改现有代码）：
- trim、统一全角/半角、统一标点、去掉多余空格
- 对常见事件分支设定标准词典（如 “短信发送成功/失败”）

### 6.4 兜底方式：确定性排序（仅保证“形态稳定”，不保证“语义正确”）

当既没有 branchId，也无法 label 匹配时：
- 你无法从旧图可靠推断“哪条边属于哪个语义分支”
- 这时“与原图一致”只能退化为“每次迁移后 out 端口分配一致，不会漂移”

兜底规则（建议）：
- 对同一 source 节点的所有出边，按 (targetX, targetY, targetId) 排序
  - 若无坐标，则按 (nodes 数组顺序, targetId) 排序
- 排序后第 i 条边分配 `sourcePortId = out-i`

## 7. 参考伪代码（用于实现迁移器/导入器）

```js
function normalizeOldCanvasToHorizontalPorts(canvasData) {
  const nodesById = new Map(canvasData.nodes.map(n => [String(n.id), n]))
  const nodeIndex = new Map(canvasData.nodes.map((n, i) => [String(n.id), i]))

  // 按 source 分组
  const edgesBySource = new Map()
  for (const e of canvasData.connections || []) {
    const s = String(e.source || '')
    if (!edgesBySource.has(s)) edgesBySource.set(s, [])
    edgesBySource.get(s).push(e)
  }

  for (const [sourceId, edges] of edgesBySource.entries()) {
    const sourceNode = nodesById.get(sourceId)
    const sourceType = sourceNode?.type
    const sourceCfg = sourceNode?.config || sourceNode?.data?.config || {}

    // 统一 targetPortId
    edges.forEach(e => { e.targetPortId = 'in' })

    if (!isMultiOutNode(sourceType, sourceCfg)) {
      edges.forEach(e => { e.sourcePortId = 'out-0' })
      continue
    }

    const branches = getBranches(sourceType, sourceCfg) // 返回 [{id, name/label}, ...]，顺序与 rows 一致

    // 优先：branchId 映射
    for (const e of edges) {
      const bid = e.branchId || e?.data?.branchId
      if (!bid) continue
      const k = branches.findIndex(b => String(b.id) === String(bid))
      if (k >= 0) e.sourcePortId = `out-${k}`
    }

    // 次优：label 映射
    for (const e of edges) {
      if (e.sourcePortId) continue
      const lbl = (e.label || '').trim()
      if (!lbl) continue
      const k = matchBranchByLabel(branches, lbl)
      if (k >= 0) e.sourcePortId = `out-${k}`
    }

    // 兜底：确定性排序分配
    const remaining = edges.filter(e => !e.sourcePortId)
    remaining.sort((a, b) => {
      const ta = String(a.target || '')
      const tb = String(b.target || '')
      const ia = nodeIndex.get(ta) ?? 1e9
      const ib = nodeIndex.get(tb) ?? 1e9
      if (ia !== ib) return ia - ib
      if (ta !== tb) return ta < tb ? -1 : 1
      const ida = String(a.id || '')
      const idb = String(b.id || '')
      return ida < idb ? -1 : ida > idb ? 1 : 0
    })
    remaining.forEach((e, i) => { e.sourcePortId = `out-${i}` })

    // 推荐：同步 branchId（若可得）
    edges.forEach(e => {
      if (e.branchId || e?.data?.branchId) return
      const m = /^out-(\d+)$/.exec(String(e.sourcePortId || ''))
      if (!m) return
      const k = Number(m[1])
      const b = branches[k]
      if (b?.id) e.branchId = b.id
    })
  }

  return canvasData
}
```

## 8. 验收清单（确保“与原图一致”）

对每个分流/AB 节点，检查：
- 分支数组（用于显示的行）与旧图的分支语义一致
- 每条旧边能唯一对应某个分支（branchId 或 label 唯一命中）
- 每个分支对应的 `out-k` 都被正确占用（不串线、不互换）
- 若启用发布校验：`branchId` 能与分支 id 对齐（避免“分支未连接”误报）

## 9. 备注

本文件描述的是“迁移/导入阶段”的数据处理方案，核心思想是：让 `connections` 自带端口绑定信息，从而避免横版加载阶段的“推断分配”带来的不确定性。

