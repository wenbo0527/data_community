# 外数生命周期技术实施方案

## 1. 技术架构现状分析

### 1.1 现有技术栈

**前端技术栈：**
```
Vue 3.3+ (Composition API)
├── TypeScript 5.0+
├── Vite 4.0+ (构建工具)
├── Vue Router 4.0+ (路由管理)
├── Pinia (状态管理)
├── Arco Design Vue 2.0+ (UI组件库)
├── AntV X6 (图形引擎)
├── AntV G2Plot (数据可视化)
└── Axios (HTTP客户端)
```

**后端服务：**
```
Supabase (BaaS平台)
├── PostgreSQL 14+ (数据库)
├── Authentication (认证服务)
├── Storage (文件存储)
└── Real-time (实时订阅)
```

### 1.2 现有代码结构分析

```
src/
├── api/                    # API接口层
│   ├── external/          # 外数相关API
│   ├── budget/            # 预算管理API
│   └── ...
├── components/            # 公共组件
│   ├── common/            # 通用组件
│   ├── layout/            # 布局组件
│   └── ...
├── pages/                  # 页面组件
│   ├── budget/            # 预算管理页面
│   ├── external-data-archive/ # 外数档案页面
│   └── ...
├── stores/                 # 状态管理
│   ├── modules/           # 模块状态
│   └── index.js           # 状态入口
├── router/                 # 路由配置
├── utils/                  # 工具函数
└── main.js                 # 应用入口
```

## 2. 技术实施方案

### 2.1 架构升级方案

#### 2.1.1 前端架构优化

**模块化架构设计：**
```
src/
├── modules/               # 业务模块（新增）
│   ├── lifecycle/        # 生命周期模块
│   │   ├── components/   # 模块组件
│   │   ├── stores/       # 模块状态
│   │   ├── services/     # 模块服务
│   │   └── utils/        # 模块工具
│   ├── budget/           # 预算管理模块
│   ├── archive/          # 档案管理模块
│   ├── evaluation/       # 评估中心模块
│   └── service/          # 服务管理模块
├── shared/               # 共享资源（新增）
│   ├── components/       # 共享组件
│   ├── utils/           # 共享工具
│   ├── types/           # TypeScript类型
│   └── constants/       # 常量定义
└── core/                 # 核心功能（新增）
    ├── api/             # API封装
    ├── auth/            # 认证相关
    ├── cache/           # 缓存管理
    └── error/           # 错误处理
```

**状态管理架构：**
```typescript
// 模块状态管理示例
export const useLifecycleStore = defineStore('lifecycle', {
  state: () => ({
    // 生命周期数据
    lifecycles: [] as Lifecycle[],
    currentLifecycle: null as Lifecycle | null,
    
    // 统计数据
    statistics: {
      totalCount: 0,
      categoryStats: {},
      statusStats: {},
      healthStats: {}
    },
    
    // UI状态
    loading: false,
    error: null as string | null
  }),
  
  getters: {
    // 计算属性
    activeLifecycles: (state) => 
      state.lifecycles.filter(item => item.status === 'active'),
    
    // 四金额汇总计算
    budgetSummary: (state) => 
      calculateBudgetSummary(state.lifecycles)
  },
  
  actions: {
    // 异步操作
    async fetchLifecycles(params: FetchParams) {
      this.loading = true
      try {
        const data = await lifecycleApi.getList(params)
        this.lifecycles = data.items
        this.statistics = data.statistics
      } catch (error) {
        this.error = error.message
      } finally {
        this.loading = false
      }
    }
  }
})
```

#### 2.1.2 API层封装优化

**统一的API客户端：**
```typescript
// core/api/client.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosError } from 'axios'

class ApiClient {
  private client: AxiosInstance
  
  constructor() {
    this.client = axios.create({
      baseURL: import.meta.env.VITE_API_BASE_URL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    })
    
    this.setupInterceptors()
  }
  
  private setupInterceptors() {
    // 请求拦截器
    this.client.interceptors.request.use(
      (config) => {
        // 添加认证token
        const token = useAuthStore().token
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        
        // 参数清理
        if (config.params) {
          config.params = cleanParams(config.params)
        }
        
        return config
      },
      (error) => Promise.reject(error)
    )
    
    // 响应拦截器
    this.client.interceptors.response.use(
      (response) => response.data,
      (error: AxiosError) => {
        // 统一错误处理
        handleApiError(error)
        return Promise.reject(error)
      }
    )
  }
  
  // 封装常用方法
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    return this.client.get(url, config)
  }
  
  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    return this.client.post(url, data, config)
  }
  
  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    return this.client.put(url, data, config)
  }
  
  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    return this.client.delete(url, config)
  }
}

export const apiClient = new ApiClient()
```

**业务API封装：**
```typescript
// modules/lifecycle/api/lifecycle.ts
import { apiClient } from '@/core/api/client'
import type { 
  Lifecycle, 
  FetchParams, 
  CreateParams, 
  UpdateParams 
} from '../types/lifecycle'

export const lifecycleApi = {
  // 获取生命周期列表
  async getList(params: FetchParams): Promise<PaginatedResponse<Lifecycle>> {
    return apiClient.get('/api/lifecycles', { params })
  },
  
  // 获取生命周期详情
  async getDetail(id: string): Promise<Lifecycle> {
    return apiClient.get(`/api/lifecycles/${id}`)
  },
  
  // 创建生命周期
  async create(data: CreateParams): Promise<Lifecycle> {
    return apiClient.post('/api/lifecycles', data)
  },
  
  // 更新生命周期
  async update(id: string, data: UpdateParams): Promise<Lifecycle> {
    return apiClient.put(`/api/lifecycles/${id}`, data)
  },
  
  // 删除生命周期
  async delete(id: string): Promise<void> {
    return apiClient.delete(`/api/lifecycles/${id}`)
  },
  
  // 获取统计数据
  async getStatistics(): Promise<LifecycleStatistics> {
    return apiClient.get('/api/lifecycles/statistics')
  }
}
```

### 2.2 核心功能实现

#### 2.2.1 四金额计算引擎

```typescript
// shared/utils/budgetCalculator.ts
export interface BudgetAmounts {
  budgetAmount: number        // 预算金额
  contractAmount: number      // 合同金额
  actualConsumption: number   // 实际消耗
  writeOffAmount: number      // 核销金额
}

export interface BudgetMetrics {
  remaining: number          // 预算剩余
  usageRate: number          // 预算使用率
  contractCoverage: number    // 合同覆盖率
  contractExecution: number   // 合同执行率
  healthScore: '正常' | '超支' | '消耗过慢'
}

export class BudgetCalculator {
  /**
   * 计算预算相关指标
   */
  static calculateMetrics(amounts: BudgetAmounts): BudgetMetrics {
    const remaining = this.calculateRemaining(amounts)
    const usageRate = this.calculateUsageRate(amounts)
    const contractCoverage = this.calculateContractCoverage(amounts)
    const contractExecution = this.calculateContractExecution(amounts)
    const healthScore = this.calculateHealthScore(amounts)
    
    return {
      remaining,
      usageRate,
      contractCoverage,
      contractExecution,
      healthScore
    }
  }
  
  /**
   * 计算预算剩余
   */
  private static calculateRemaining(amounts: BudgetAmounts): number {
    return amounts.budgetAmount - amounts.writeOffAmount
  }
  
  /**
   * 计算预算使用率
   */
  private static calculateUsageRate(amounts: BudgetAmounts): number {
    if (amounts.budgetAmount === 0) return 0
    return amounts.writeOffAmount / amounts.budgetAmount
  }
  
  /**
   * 计算合同覆盖率
   */
  private static calculateContractCoverage(amounts: BudgetAmounts): number {
    if (amounts.budgetAmount === 0) return 0
    return amounts.contractAmount / amounts.budgetAmount
  }
  
  /**
   * 计算合同执行率
   */
  private static calculateContractExecution(amounts: BudgetAmounts): number {
    if (amounts.contractAmount === 0) return 0
    return amounts.writeOffAmount / amounts.contractAmount
  }
  
  /**
   * 计算预算健康度
   */
  private static calculateHealthScore(amounts: BudgetAmounts): '正常' | '超支' | '消耗过慢' {
    const usageRate = this.calculateUsageRate(amounts)
    const timeProgress = this.calculateTimeProgress()
    
    if (usageRate > timeProgress * 1.2) return '超支'
    if (usageRate < timeProgress * 0.5) return '消耗过慢'
    return '正常'
  }
  
  /**
   * 计算时间进度（基于当前时间）
   */
  private static calculateTimeProgress(): number {
    const now = new Date()
    const year = now.getFullYear()
    const startOfYear = new Date(year, 0, 1)
    const endOfYear = new Date(year + 1, 0, 1)
    
    const totalDays = endOfYear.getTime() - startOfYear.getTime()
    const elapsedDays = now.getTime() - startOfYear.getTime()
    
    return elapsedDays / totalDays
  }
  
  /**
   * 批量计算预算指标
   */
  static batchCalculateMetrics(budgets: BudgetAmounts[]): BudgetMetrics[] {
    return budgets.map(amounts => this.calculateMetrics(amounts))
  }
  
  /**
   * 计算汇总统计
   */
  static calculateSummary(budgets: BudgetAmounts[]) {
    const totalBudget = budgets.reduce((sum, b) => sum + b.budgetAmount, 0)
    const totalContract = budgets.reduce((sum, b) => sum + b.contractAmount, 0)
    const totalConsumption = budgets.reduce((sum, b) => sum + b.actualConsumption, 0)
    const totalWriteOff = budgets.reduce((sum, b) => sum + b.writeOffAmount, 0)
    
    return {
      totalBudget,
      totalContract,
      totalConsumption,
      totalWriteOff,
      averageUsageRate: totalWriteOff / totalBudget,
      averageContractCoverage: totalContract / totalBudget
    }
  }
}
```

#### 2.2.2 生命周期流程图组件

```typescript
// modules/lifecycle/components/LifecycleFlowChart.vue
<template>
  <div ref="containerRef" class="lifecycle-flow-chart">
    <div class="chart-toolbar">
      <a-space>
        <a-button @click="fitToContent">适应内容</a-button>
        <a-button @click="resetZoom">重置缩放</a-button>
        <a-button @click="exportImage">导出图片</a-button>
      </a-space>
    </div>
    <div ref="graphRef" class="graph-container"></div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch } from 'vue'
import { Graph, Shape } from '@antv/x6'
import type { Lifecycle } from '../types/lifecycle'

interface Props {
  lifecycles: Lifecycle[]
  currentStage?: string
  onStageClick?: (stage: string) => void
}

const props = defineProps<Props>()

const containerRef = ref<HTMLElement>()
const graphRef = ref<HTMLElement>()
let graph: Graph | null = null

// 生命周期阶段定义
const STAGES = [
  { id: 'register', name: '注册', color: '#1890ff' },
  { id: 'evaluation', name: '评估', color: '#52c41a' },
  { id: 'approval', name: '审批', color: '#faad14' },
  { id: 'online', name: '上线', color: '#13c2c2' },
  { id: 'operation', name: '运维', color: '#722ed1' },
  { id: 'retirement', name: '下线', color: '#eb2f96' }
]

onMounted(() => {
  initGraph()
  renderStages()
})

onUnmounted(() => {
  if (graph) {
    graph.dispose()
  }
})

watch(() => props.lifecycles, () => {
  updateStageStatus()
}, { deep: true })

function initGraph() {
  if (!graphRef.value) return
  
  graph = new Graph({
    container: graphRef.value,
    width: 800,
    height: 400,
    background: {
      color: '#f5f5f5'
    },
    grid: {
      visible: true,
      type: 'dot',
      size: 20
    },
    interacting: {
      nodeMovable: false,
      edgeMovable: false
    },
    connecting: {
      router: {
        name: 'manhattan',
        args: {
          padding: 20
        }
      },
      connector: {
        name: 'rounded',
        args: {
          radius: 10
        }
      }
    }
  })
}

function renderStages() {
  if (!graph) return
  
  const nodeWidth = 120
  const nodeHeight = 60
  const spacing = 40
  const startX = 50
  const startY = 150
  
  // 创建阶段节点
  STAGES.forEach((stage, index) => {
    const x = startX + index * (nodeWidth + spacing)
    const y = startY
    
    const node = graph!.addNode({
      id: stage.id,
      shape: 'rect',
      x,
      y,
      width: nodeWidth,
      height: nodeHeight,
      attrs: {
        body: {
          fill: stage.color,
          stroke: '#fff',
          strokeWidth: 2,
          rx: 8,
          ry: 8
        },
        label: {
          text: stage.name,
          fill: '#fff',
          fontSize: 14,
          fontWeight: 'bold'
        }
      },
      data: { stage }
    })
    
    // 添加点击事件
    node.on('click', () => {
      props.onStageClick?.(stage.id)
    })
    
    // 添加状态指示器
    const status = getStageStatus(stage.id)
    addStatusIndicator(stage.id, status)
  })
  
  // 创建连接线
  for (let i = 0; i < STAGES.length - 1; i++) {
    graph.addEdge({
      source: STAGES[i].id,
      target: STAGES[i + 1].id,
      attrs: {
        line: {
          stroke: '#8c8c8c',
          strokeWidth: 2,
          targetMarker: {
            name: 'classic',
            size: 8
          }
        }
      }
    })
  }
  
  // 适应内容
  graph.fitToContent({ padding: 20 })
}

function getStageStatus(stageId: string): 'pending' | 'active' | 'completed' {
  const lifecycle = props.lifecycles[0] // 示例：取第一个生命周期
  if (!lifecycle) return 'pending'
  
  // 根据生命周期当前状态判断各阶段状态
  const stageOrder = STAGES.map(s => s.id)
  const currentStageIndex = stageOrder.indexOf(lifecycle.currentStage)
  const stageIndex = stageOrder.indexOf(stageId)
  
  if (stageIndex < currentStageIndex) return 'completed'
  if (stageIndex === currentStageIndex) return 'active'
  return 'pending'
}

function addStatusIndicator(stageId: string, status: 'pending' | 'active' | 'completed') {
  if (!graph) return
  
  const node = graph.getCellById(stageId)
  if (!node) return
  
  const position = node.getPosition()
  const size = node.getSize()
  
  const indicatorColor = {
    pending: '#d9d9d9',
    active: '#1890ff',
    completed: '#52c41a'
  }[status]
  
  graph.addNode({
    shape: 'circle',
    x: position.x + size.width - 15,
    y: position.y - 15,
    width: 30,
    height: 30,
    attrs: {
      body: {
        fill: indicatorColor,
        stroke: '#fff',
        strokeWidth: 2
      }
    }
  })
}

function updateStageStatus() {
  if (!graph) return
  
  // 更新所有节点的状态指示器
  STAGES.forEach(stage => {
    const status = getStageStatus(stage.id)
    // 这里可以实现更复杂的状态更新逻辑
  })
}

function fitToContent() {
  graph?.fitToContent({ padding: 20 })
}

function resetZoom() {
  graph?.zoomToFit({ padding: 20 })
}

function exportImage() {
  if (!graph) return
  
  graph.toPNG(
    (dataUri: string) => {
      // 下载图片
      const link = document.createElement('a')
      link.download = 'lifecycle-flow-chart.png'
      link.href = dataUri
      link.click()
    },
    {
      backgroundColor: '#ffffff',
      padding: 20
    }
  )
}
</script>

<style scoped>
.lifecycle-flow-chart {
  width: 100%;
  height: 100%;
  position: relative;
}

.chart-toolbar {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 10;
}

.graph-container {
  width: 100%;
  height: 100%;
  min-height: 400px;
}
</style>
```

#### 2.2.3 数据联动机制

```typescript
// shared/services/dataSync.ts
import { useLifecycleStore } from '@/modules/lifecycle/stores/lifecycle'
import { useBudgetStore } from '@/modules/budget/stores/budget'
import { useArchiveStore } from '@/modules/archive/stores/archive'
import { useEvaluationStore } from '@/modules/evaluation/stores/evaluation'
import { useServiceStore } from '@/modules/service/stores/service'

/**
 * 数据联动管理器
 */
export class DataSyncManager {
  private stores = {
    lifecycle: useLifecycleStore(),
    budget: useBudgetStore(),
    archive: useArchiveStore(),
    evaluation: useEvaluationStore(),
    service: useServiceStore()
  }
  
  /**
   * 初始化数据联动监听
   */
  init() {
    this.setupBudgetSync()
    this.setupEvaluationSync()
    this.setupContractSync()
    this.setupServiceSync()
  }
  
  /**
   * 预算数据联动
   */
  private setupBudgetSync() {
    // 监听预算变更，更新生命周期状态
    this.stores.budget.$onAction(({ name, args, after }) => {
      if (name === 'updateBudget') {
        after(async (result) => {
          // 更新相关生命周期状态
          await this.stores.lifecycle.refreshLifecycle(result.lifecycleId)
          
          // 触发预算预警检查
          this.checkBudgetAlert(result)
        })
      }
    })
  }
  
  /**
   * 评估数据联动
   */
  private setupEvaluationSync() {
    // 监听评估完成，更新档案状态
    this.stores.evaluation.$onAction(({ name, args, after }) => {
      if (name === 'completeEvaluation') {
        after(async (result) => {
          // 更新档案评估状态
          await this.stores.archive.updateEvaluationStatus({
            archiveId: result.archiveId,
            evaluationScore: result.score,
            evaluationStatus: result.status
          })
          
          // 如果评估不通过，暂停相关服务
          if (result.score < 0.6) {
            await this.stores.service.pauseServices(result.archiveId)
          }
        })
      }
    })
  }
  
  /**
   * 合同数据联动
   */
  private setupContractSync() {
    // 监听合同状态变更
    this.stores.budget.$onAction(({ name, args, after }) => {
      if (name === 'updateContractStatus') {
        after(async (result) => {
          // 合同到期提醒
          if (result.status === 'expiring') {
            await this.createExpiringAlert(result)
          }
          
          // 合同终止，更新相关服务状态
          if (result.status === 'terminated') {
            await this.stores.service.terminateServices(result.contractId)
          }
        })
      }
    })
  }
  
  /**
   * 服务数据联动
   */
  private setupServiceSync() {
    // 监听服务调用数据，更新使用统计
    this.stores.service.$onAction(({ name, args, after }) => {
      if (name === 'recordServiceUsage') {
        after(async (result) => {
          // 更新服务使用统计
          await this.stores.archive.updateUsageStats({
            serviceId: result.serviceId,
            callCount: result.callCount,
            avgResponseTime: result.avgResponseTime
          })
          
          // 更新价值评估参数
          await this.stores.evaluation.updateValueParams({
            archiveId: result.archiveId,
            usageFrequency: result.usageFrequency,
            performanceScore: result.performanceScore
          })
        })
      }
    })
  }
  
  /**
   * 预算预警检查
   */
  private checkBudgetAlert(budget: any) {
    const metrics = BudgetCalculator.calculateMetrics({
      budgetAmount: budget.budgetAmount,
      contractAmount: budget.contractAmount,
      actualConsumption: budget.actualConsumption,
      writeOffAmount: budget.writeOffAmount
    })
    
    if (metrics.healthScore !== '正常') {
      // 创建预警记录
      this.stores.lifecycle.createAlert({
        type: 'budget_health',
        level: metrics.healthScore === '超支' ? 'high' : 'medium',
        message: `预算${metrics.healthScore}预警：使用率${(metrics.usageRate * 100).toFixed(1)}%`,
        relatedId: budget.id
      })
    }
  }
  
  /**
   * 创建合同到期提醒
   */
  private async createExpiringAlert(contract: any) {
    await this.stores.lifecycle.createAlert({
      type: 'contract_expiring',
      level: 'medium',
      message: `合同即将到期：${contract.name}（${contract.daysToExpire}天）`,
      relatedId: contract.id,
      expireAt: contract.expireDate
    })
  }
}

// 创建单例实例
export const dataSyncManager = new DataSyncManager()
```

### 2.3 数据库设计优化

#### 2.3.1 核心数据表结构

```sql
-- 生命周期主表（已存在，优化）
ALTER TABLE lifecycles 
ADD COLUMN IF NOT EXISTS current_stage VARCHAR(50) DEFAULT 'register',
ADD COLUMN IF NOT EXISTS stage_history JSONB DEFAULT '[]',
ADD COLUMN IF NOT EXISTS health_score VARCHAR(20) DEFAULT 'normal',
ADD COLUMN IF NOT EXISTS alert_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS last_evaluated_at TIMESTAMP WITH TIME ZONE;

-- 创建复合索引
CREATE INDEX IF NOT EXISTS idx_lifecycles_stage_health 
ON lifecycles(current_stage, health_score);

CREATE INDEX IF NOT EXISTS idx_lifecycles_evaluated 
ON lifecycles(last_evaluated_at DESC);

-- 预算表优化（已存在，添加索引）
CREATE INDEX IF NOT EXISTS idx_budgets_amounts 
ON budgets(budget_amount, contract_amount, actual_consumption_amount, write_off_amount);

CREATE INDEX IF NOT EXISTS idx_budgets_health 
ON budgets(budget_amount - write_off_amount); -- 预算剩余索引

-- 预警记录表（新增）
CREATE TABLE lifecycle_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lifecycle_id UUID REFERENCES lifecycles(id) ON DELETE CASCADE,
  type VARCHAR(50) NOT NULL, -- budget_health, contract_expiring, evaluation_failed等
  level VARCHAR(20) NOT NULL CHECK (level IN ('low', 'medium', 'high', 'critical')),
  title VARCHAR(255) NOT NULL,
  message TEXT,
  status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'acknowledged', 'resolved')),
  acknowledged_by UUID REFERENCES auth.users(id),
  acknowledged_at TIMESTAMP WITH TIME ZONE,
  resolved_by UUID REFERENCES auth.users(id),
  resolved_at TIMESTAMP WITH TIME ZONE,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expire_at TIMESTAMP WITH TIME ZONE
);

-- 预警表索引
CREATE INDEX idx_alerts_lifecycle ON lifecycle_alerts(lifecycle_id);
CREATE INDEX idx_alerts_type ON lifecycle_alerts(type);
CREATE INDEX idx_alerts_status ON lifecycle_alerts(status);
CREATE INDEX idx_alerts_level ON lifecycle_alerts(level);
CREATE INDEX idx_alerts_created ON lifecycle_alerts(created_at DESC);

-- 数据联动日志表（新增）
CREATE TABLE sync_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  source_type VARCHAR(50) NOT NULL, -- budget, evaluation, contract, service
  source_id UUID NOT NULL,
  target_type VARCHAR(50) NOT NULL,
  target_id UUID NOT NULL,
  action VARCHAR(100) NOT NULL,
  changes JSONB DEFAULT '{}',
  status VARCHAR(20) DEFAULT 'success',
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_sync_logs_source ON sync_logs(source_type, source_id);
CREATE INDEX idx_sync_logs_target ON sync_logs(target_type, target_id);
CREATE INDEX idx_sync_logs_created ON sync_logs(created_at DESC);
```

#### 2.3.2 Supabase RLS策略优化

```sql
-- 生命周期表RLS策略优化
ALTER TABLE lifecycles ENABLE ROW LEVEL SECURITY;

-- 查看策略（保持现有）
CREATE POLICY "Public view active lifecycles" ON lifecycles
    FOR SELECT USING (status IN ('evaluating', 'serving'));

-- 创建策略（认证用户）
CREATE POLICY "Authenticated users can create lifecycles" ON lifecycles
    FOR INSERT WITH CHECK (auth.uid() = owner_id);

-- 更新策略（拥有者或管理员）
CREATE POLICY "Owners can update lifecycles" ON lifecycles
    FOR UPDATE USING (
        auth.uid() = owner_id OR 
        auth.jwt() ->> 'role' = 'admin'
    );

-- 预警表RLS策略
ALTER TABLE lifecycle_alerts ENABLE ROW LEVEL SECURITY;

-- 查看策略
CREATE POLICY "Users can view lifecycle alerts" ON lifecycle_alerts
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM lifecycles 
            WHERE id = lifecycle_alerts.lifecycle_id 
            AND (
                owner_id = auth.uid() OR 
                status = 'active' OR
                auth.jwt() ->> 'role' = 'admin'
            )
        )
    );

-- 更新策略（acknowledge和resolve）
CREATE POLICY "Users can update lifecycle alerts" ON lifecycle_alerts
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM lifecycles 
            WHERE id = lifecycle_alerts.lifecycle_id 
            AND (
                owner_id = auth.uid() OR 
                auth.jwt() ->> 'role' = 'admin'
            )
        )
    );

-- 数据联动日志RLS策略
ALTER TABLE sync_logs ENABLE ROW LEVEL SECURITY;

-- 管理员查看所有日志
CREATE POLICY "Admin can view all sync logs" ON sync_logs
    FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

-- 普通用户查看相关日志
CREATE POLICY "Users can view related sync logs" ON sync_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM lifecycles 
            WHERE (
                (sync_logs.source_type = 'lifecycle' AND lifecycles.id = sync_logs.source_id) OR
                (sync_logs.target_type = 'lifecycle' AND lifecycles.id = sync_logs.target_id)
            )
            AND lifecycles.owner_id = auth.uid()
        )
    );
```

### 2.4 性能优化方案

#### 2.4.1 前端性能优化

**组件懒加载：**
```typescript
// router/modules/lifecycle.ts
import { RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
  {
    path: '/lifecycle',
    name: 'LifecycleOverview',
    component: () => import('@/modules/lifecycle/views/Overview.vue'),
    meta: {
      title: '生命周期总览',
      requiresAuth: true
    }
  },
  {
    path: '/lifecycle/archive/:id',
    name: 'ArchiveDetail',
    component: () => import('@/modules/archive/views/Detail.vue'),
    meta: {
      title: '档案详情',
      requiresAuth: true
    }
  }
]

export default routes
```

**虚拟滚动优化：**
```typescript
// shared/components/VirtualTable.vue
<template>
  <div ref="containerRef" class="virtual-table-container">
    <div class="virtual-table-header">
      <table>
        <thead>
          <tr>
            <th v-for="column in columns" :key="column.key" :width="column.width">
              {{ column.title }}
            </th>
          </tr>
        </thead>
      </table>
    </div>
    <div class="virtual-table-body" :style="{ height: bodyHeight + 'px' }">
      <div class="virtual-table-content" :style="{ transform: `translateY(${offsetY}px)` }">
        <table>
          <tbody>
            <tr v-for="row in visibleData" :key="rowKey(row)">
              <td v-for="column in columns" :key="column.key">
                <slot :name="column.key" :row="row" :value="row[column.key]">
                  {{ formatValue(row[column.key], column) }}
                </slot>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue'

interface Props {
  data: any[]
  columns: any[]
  rowHeight: number
  bufferSize: number
}

const props = withDefaults(defineProps<Props>(), {
  rowHeight: 50,
  bufferSize: 10
})

const containerRef = ref<HTMLElement>()
const scrollTop = ref(0)
const containerHeight = ref(0)

const totalHeight = computed(() => props.data.length * props.rowHeight)
const startIndex = computed(() => Math.floor(scrollTop.value / props.rowHeight))
const endIndex = computed(() => {
  const visibleCount = Math.ceil(containerHeight.value / props.rowHeight)
  return Math.min(startIndex.value + visibleCount + props.bufferSize, props.data.length)
})

const visibleData = computed(() => {
  const start = Math.max(0, startIndex.value - props.bufferSize)
  const end = endIndex.value
  return props.data.slice(start, end)
})

const offsetY = computed(() => startIndex.value * props.rowHeight)
const bodyHeight = computed(() => Math.min(totalHeight.value, containerHeight.value))

function handleScroll() {
  if (containerRef.value) {
    scrollTop.value = containerRef.value.scrollTop
  }
}

function updateContainerHeight() {
  if (containerRef.value) {
    containerHeight.value = containerRef.value.clientHeight
  }
}

function formatValue(value: any, column: any): string {
  if (column.formatter) {
    return column.formatter(value)
  }
  return String(value ?? '')
}

function rowKey(row: any): string {
  return row.id || JSON.stringify(row)
}

onMounted(() => {
  updateContainerHeight()
  window.addEventListener('resize', updateContainerHeight)
})

onUnmounted(() => {
  window.removeEventListener('resize', updateContainerHeight)
})
</script>

<style scoped>
.virtual-table-container {
  height: 100%;
  overflow: auto;
}

.virtual-table-header {
  position: sticky;
  top: 0;
  background: #fff;
  z-index: 10;
}

.virtual-table-body {
  overflow: hidden;
  position: relative;
}

.virtual-table-content {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

table {
  width: 100%;
  border-collapse: collapse;
}

th, td {
  padding: 12px;
  text-align: left;
  border-bottom: 1px solid #f0f0f0;
}

th {
  background: #fafafa;
  font-weight: 600;
}
</style>
```

#### 2.4.2 数据缓存策略

```typescript
// core/cache/cacheManager.ts
interface CacheConfig {
  maxAge: number           // 最大缓存时间（毫秒）
  maxSize: number          // 最大缓存数量
  strategy: 'memory' | 'localStorage' | 'indexedDB'
}

interface CacheItem<T = any> {
  data: T
  timestamp: number
  expires: number
}

export class CacheManager {
  private memoryCache = new Map<string, CacheItem>()
  private config: CacheConfig
  
  constructor(config: Partial<CacheConfig> = {}) {
    this.config = {
      maxAge: 5 * 60 * 1000, // 5分钟
      maxSize: 100,
      strategy: 'memory',
      ...config
    }
  }
  
  /**
   * 获取缓存
   */
  async get<T>(key: string): Promise<T | null> {
    // 内存缓存
    const memoryItem = this.memoryCache.get(key)
    if (memoryItem && this.isValid(memoryItem)) {
      return memoryItem.data
    }
    
    // 本地存储缓存
    if (this.config.strategy === 'localStorage') {
      const localItem = await this.getFromLocalStorage<T>(key)
      if (localItem && this.isValid(localItem)) {
        // 同步到内存缓存
        this.memoryCache.set(key, localItem)
        return localItem.data
      }
    }
    
    return null
  }
  
  /**
   * 设置缓存
   */
  async set<T>(key: string, data: T, maxAge?: number): Promise<void> {
    const expires = Date.now() + (maxAge || this.config.maxAge)
    const item: CacheItem<T> = {
      data,
      timestamp: Date.now(),
      expires
    }
    
    // 内存缓存
    this.memoryCache.set(key, item)
    this.cleanupMemoryCache()
    
    // 本地存储缓存
    if (this.config.strategy === 'localStorage') {
      await this.setToLocalStorage(key, item)
    }
  }
  
  /**
   * 删除缓存
   */
  async delete(key: string): Promise<void> {
    this.memoryCache.delete(key)
    
    if (this.config.strategy === 'localStorage') {
      localStorage.removeItem(`cache:${key}`)
    }
  }
  
  /**
   * 清空缓存
   */
  async clear(): Promise<void> {
    this.memoryCache.clear()
    
    if (this.config.strategy === 'localStorage') {
      const keys = Object.keys(localStorage)
        .filter(key => key.startsWith('cache:'))
      
      keys.forEach(key => localStorage.removeItem(key))
    }
  }
  
  /**
   * 检查缓存是否有效
   */
  private isValid(item: CacheItem): boolean {
    return Date.now() < item.expires
  }
  
  /**
   * 清理内存缓存
   */
  private cleanupMemoryCache() {
    if (this.memoryCache.size > this.config.maxSize) {
      // 删除最旧的缓存项
      const entries = Array.from(this.memoryCache.entries())
      const sortedEntries = entries.sort((a, b) => a[1].timestamp - b[1].timestamp)
      const toDelete = sortedEntries.slice(0, this.config.maxSize / 2)
      
      toDelete.forEach(([key]) => {
        this.memoryCache.delete(key)
      })
    }
  }
  
  /**
   * 从本地存储获取缓存
   */
  private async getFromLocalStorage<T>(key: string): Promise<CacheItem<T> | null> {
    try {
      const itemStr = localStorage.getItem(`cache:${key}`)
      if (!itemStr) return null
      
      return JSON.parse(itemStr)
    } catch (error) {
      console.warn('Failed to get cache from localStorage:', error)
      return null
    }
  }
  
  /**
   * 设置本地存储缓存
   */
  private async setToLocalStorage<T>(key: string, item: CacheItem<T>): Promise<void> {
    try {
      localStorage.setItem(`cache:${key}`, JSON.stringify(item))
    } catch (error) {
      console.warn('Failed to set cache to localStorage:', error)
    }
  }
}

// 创建缓存管理器实例
export const cacheManager = new CacheManager({
  maxAge: 10 * 60 * 1000, // 10分钟
  maxSize: 200,
  strategy: 'localStorage'
})
```

### 2.5 错误处理与监控

#### 2.5.1 全局错误处理

```typescript
// core/error/errorHandler.ts
import { Message } from '@arco-design/web-vue'

export interface ErrorInfo {
  type: 'api' | 'validation' | 'business' | 'system'
  code: string
  message: string
  details?: any
  timestamp: number
  context?: any
}

export class ErrorHandler {
  private errorLog: ErrorInfo[] = []
  private maxLogSize = 100
  
  /**
   * 处理错误
   */
  handleError(error: any, context?: any): ErrorInfo {
    const errorInfo = this.parseError(error, context)
    
    // 记录错误日志
    this.logError(errorInfo)
    
    // 显示错误提示
    this.showErrorMessage(errorInfo)
    
    // 上报错误（生产环境）
    if (import.meta.env.PROD) {
      this.reportError(errorInfo)
    }
    
    return errorInfo
  }
  
  /**
   * 解析错误
   */
  private parseError(error: any, context?: any): ErrorInfo {
    // API错误
    if (error.response) {
      const { status, data } = error.response
      
      return {
        type: 'api',
        code: `API_${status}`,
        message: this.getApiErrorMessage(data, status),
        details: data,
        timestamp: Date.now(),
        context
      }
    }
    
    // 验证错误
    if (error.name === 'ValidationError') {
      return {
        type: 'validation',
        code: 'VALIDATION_ERROR',
        message: this.getValidationErrorMessage(error),
        details: error.errors,
        timestamp: Date.now(),
        context
      }
    }
    
    // 业务错误
    if (error.code && error.message) {
      return {
        type: 'business',
        code: error.code,
        message: error.message,
        details: error.details,
        timestamp: Date.now(),
        context
      }
    }
    
    // 系统错误
    return {
      type: 'system',
      code: 'SYSTEM_ERROR',
      message: '系统错误，请稍后重试',
      details: error.message || error,
      timestamp: Date.now(),
      context
    }
  }
  
  /**
   * 获取API错误消息
   */
  private getApiErrorMessage(data: any, status: number): string {
    const errorMessages: Record<number, string> = {
      400: '请求参数错误',
      401: '未授权，请重新登录',
      403: '没有权限执行此操作',
      404: '请求的资源不存在',
      409: '数据冲突',
      422: '数据验证失败',
      500: '服务器错误',
      502: '服务暂不可用',
      503: '服务维护中'
    }
    
    // 优先使用服务器返回的错误消息
    if (data.message) {
      return data.message
    }
    
    return errorMessages[status] || '请求失败'
  }
  
  /**
   * 获取验证错误消息
   */
  private getValidationErrorMessage(error: any): string {
    if (error.errors && Array.isArray(error.errors)) {
      return error.errors.map((e: any) => e.message).join('；')
    }
    
    return error.message || '数据验证失败'
  }
  
  /**
   * 显示错误消息
   */
  private showErrorMessage(errorInfo: ErrorInfo) {
    const { type, message } = errorInfo
    
    // 根据错误类型选择不同的显示方式
    switch (type) {
      case 'validation':
        Message.warning(message)
        break
      case 'business':
        Message.info(message)
        break
      case 'api':
      case 'system':
        Message.error(message)
        break
      default:
        Message.error(message)
    }
  }
  
  /**
   * 记录错误日志
   */
  private logError(errorInfo: ErrorInfo) {
    this.errorLog.push(errorInfo)
    
    // 限制日志大小
    if (this.errorLog.length > this.maxLogSize) {
      this.errorLog = this.errorLog.slice(-this.maxLogSize)
    }
    
    // 控制台输出（开发环境）
    if (import.meta.env.DEV) {
      console.error('Error Info:', errorInfo)
    }
  }
  
  /**
   * 上报错误（生产环境）
   */
  private reportError(errorInfo: ErrorInfo) {
    // 这里可以集成错误监控服务，如Sentry、LogRocket等
    // 示例：Sentry.captureException(errorInfo)
    
    // 也可以发送到自建的错误收集服务
    navigator.sendBeacon('/api/errors', JSON.stringify(errorInfo))
  }
  
  /**
   * 获取错误日志
   */
  getErrorLog(): ErrorInfo[] {
    return [...this.errorLog]
  }
  
  /**
   * 清空错误日志
   */
  clearErrorLog() {
    this.errorLog = []
  }
}

// 创建错误处理器实例
export const errorHandler = new ErrorHandler()
```

#### 2.5.2 性能监控

```typescript
// core/monitoring/performanceMonitor.ts
export interface PerformanceMetrics {
  pageLoadTime: number
  apiResponseTime: number
  renderTime: number
  resourceLoadTime: number
  memoryUsage: number
}

export class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    pageLoadTime: 0,
    apiResponseTime: 0,
    renderTime: 0,
    resourceLoadTime: 0,
    memoryUsage: 0
  }
  
  private listeners: Array<(metrics: PerformanceMetrics) => void> = []
  
  /**
   * 初始化性能监控
   */
  init() {
    this.measurePageLoadTime()
    this.measureApiResponseTime()
    this.measureRenderTime()
    this.measureMemoryUsage()
    
    // 定期上报性能数据
    setInterval(() => {
      this.reportMetrics()
    }, 30000) // 30秒上报一次
  }
  
  /**
   * 测量页面加载时间
   */
  private measurePageLoadTime() {
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
      this.metrics.pageLoadTime = navigation.loadEventEnd - navigation.fetchStart
      
      this.notifyListeners()
    })
  }
  
  /**
   * 测量API响应时间
   */
  private measureApiResponseTime() {
    const originalFetch = window.fetch
    
    window.fetch = async (input: RequestInfo, init?: RequestInit) => {
      const startTime = performance.now()
      
      try {
        const response = await originalFetch(input, init)
        const endTime = performance.now()
        
        this.metrics.apiResponseTime = endTime - startTime
        this.notifyListeners()
        
        return response
      } catch (error) {
        const endTime = performance.now()
        this.metrics.apiResponseTime = endTime - startTime
        this.notifyListeners()
        
        throw error
      }
    }
  }
  
  /**
   * 测量渲染时间
   */
  private measureRenderTime() {
    // 使用 Performance Observer 监听渲染相关指标
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'paint') {
            if (entry.name === 'first-contentful-paint') {
              this.metrics.renderTime = entry.startTime
              this.notifyListeners()
            }
          }
        }
      })
      
      observer.observe({ entryTypes: ['paint'] })
    }
  }
  
  /**
   * 测量内存使用情况
   */
  private measureMemoryUsage() {
    if ('memory' in performance) {
      setInterval(() => {
        const memoryInfo = (performance as any).memory
        this.metrics.memoryUsage = memoryInfo.usedJSHeapSize
        this.notifyListeners()
      }, 10000) // 10秒测量一次
    }
  }
  
  /**
   * 上报性能指标
   */
  private reportMetrics() {
    const metrics = this.getMetrics()
    
    // 使用 sendBeacon 上报，避免影响页面性能
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/metrics/performance', JSON.stringify(metrics))
    }
  }
  
  /**
   * 获取性能指标
   */
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics }
  }
  
  /**
   * 添加监听器
   */
  addListener(listener: (metrics: PerformanceMetrics) => void) {
    this.listeners.push(listener)
  }
  
  /**
   * 移除监听器
   */
  removeListener(listener: (metrics: PerformanceMetrics) => void) {
    const index = this.listeners.indexOf(listener)
    if (index > -1) {
      this.listeners.splice(index, 1)
    }
  }
  
  /**
   * 通知监听器
   */
  private notifyListeners() {
    const metrics = this.getMetrics()
    this.listeners.forEach(listener => {
      try {
        listener(metrics)
      } catch (error) {
        console.error('Error in performance listener:', error)
      }
    })
  }
}

// 创建性能监控器实例
export const performanceMonitor = new PerformanceMonitor()
```

## 3. 实施计划与里程碑

### 3.1 技术实施阶段

#### 阶段1：基础架构升级（第1周）
- ✅ 模块化架构设计实现
- ✅ API客户端封装优化
- ✅ 四金额计算引擎开发
- ✅ 错误处理机制完善

#### 阶段2：核心功能开发（第2周）
- ✅ 生命周期流程图组件
- ✅ 数据联动机制实现
- ✅ 性能监控集成
- ✅ 缓存策略实施

#### 阶段3：性能优化（第3周）
- ✅ 虚拟滚动组件开发
- ✅ 数据库索引优化
- ✅ 前端性能优化
- ✅ 监控告警完善

#### 阶段4：测试与优化（第4周）
- ✅ 单元测试编写
- ✅ 性能测试执行
- ✅ 代码审查
- ✅ 文档完善

### 3.2 技术验收标准

#### 3.2.1 性能指标
- 页面加载时间：<1.5秒
- API响应时间：<300ms
- 图表渲染时间：<800ms
- 内存使用率：<200MB

#### 3.2.2 代码质量
- 单元测试覆盖率：>80%
- TypeScript类型覆盖率：>95%
- 代码规范符合率：>90%
- 性能监控覆盖率：>95%

#### 3.2.3 系统稳定性
- 错误率：<0.1%
- 可用性：>99.9%
- 并发支持：>100用户
- 数据一致性：100%

## 4. 风险评估与应对

### 4.1 技术风险

| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|----------|
| AntV X6性能问题 | 中 | 高 | 提前测试，准备降级方案 |
| 缓存一致性 | 中 | 中 | 实现缓存失效机制 |
| 内存泄漏 | 低 | 高 | 代码审查，性能监控 |
| 浏览器兼容性 | 低 | 中 | 渐进增强，polyfill |

### 4.2 应对策略

1. **技术预研**：提前验证关键技术方案
2. **代码审查**：建立严格的代码审查机制
3. **自动化测试**：完善的测试覆盖
4. **监控告警**：实时监控和告警机制
5. **渐进实施**：分阶段实施，降低风险

通过本技术实施方案，将构建一个高性能、高可用、易维护的外数生命周期管理系统，为业务提供强有力的技术支撑。