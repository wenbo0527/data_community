## 目标
- 采用“从右向左车道回推”的新算法：先锁定最右层（叶子/输出层）车道顺序与Y基线，再逐层向左回推分配车道并计算坐标，确保同一分支跨层保持同一水平线，不与其他分支交叉。
- 不改变连线：`router: 'normal'` + `connector: 'smooth'`，不写 `edge.vertices`；布局后统一清理控制点。

## 数据准备
- 从 X6 图获取：`nodes = graph.getNodes()`、`edges = graph.getEdges()`。
- 构建邻接表：`outAdj[id]`（后继）、`inAdj[id]`（前驱）；入度表 `indeg[id]`。
- 叶子（最右层）集合：`sinks = outAdj[id].length === 0`。

## 车道锁定（右端）
- 对 `sinks` 按业务优先级/端口顺序/ID数值排序，生成稳定 `laneId`：`laneOf[idSink] = index`。
- 计算车道基线：`laneY[laneId] = startY + laneId * laneGapY`（`laneGapY ≥ 节点高度 + 20`）。

## 右→左回推
- 层级 `rank` 推断：
  - 若已有 `rank` 或 `dagre` 输出可用，直接用；否则通过自根/多根 BFS 序列化得到 `rank`（不可达节点回退到 0）。
- 回推规则：
  - 从 `sinks` 向左层回溯：对于每个节点 `id`，其 `laneId` 由子节点的多数车道决定；若无子（叶子），保持既定 `laneId`；若有冲突，选靠中心或业务优先车道。
  - 兄弟分支（同一分支点的多出边）在初始分支点处分配唯一车道，并沿路径继承，禁止覆写种子车道。

## 坐标计算与应用
- 横向列坐标：`x = startX + rank * colSpacing`（`colSpacing` 建议 280）。
- 纵向车道坐标：`y = laneY[laneId]`；同层同车道多个节点用 `rowOffset`（±offset）微调，仍保持在走廊内。
- 批量应用：`node.position(x, y)`；遍历所有边 `e.setVertices([])`，确保无控制点。

## 代码改动点
- 在 `src/pages/marketing/tasks/horizontal/utils/quickLayout.js` 新增：
  - `computeSinksAndOrder(nodes, edges)`：叶子排序生成初始车道
  - `propagateLaneRightToLeft(outAdj, inAdj, laneOf)`：逐层回推分配车道
  - `buildRanksBFS(nodes, inAdj)`：安全计算 `rank`
  - `applyGridPositions(graph, rankOf, laneOf, config)`：按层列网格+车道走廊应用坐标
- 在 `src/pages/marketing/tasks/horizontal/index.vue` 快速布局入口调用：
  - `await quickLayout.value.executeRightToLeftLaneLayout(graph, { startX: 80, startY: 120, colSpacing: 280, laneGapY: 240, rowOffset: 16, laneOrder: 'idNumeric' })`

## 验证
- 多层分支示例：顶层分支形成多条平行走廊，后续层保持同一 Y 基线；横向各层对齐；连线平滑无控制点。
- 输出日志：车道数、各层节点分布、被多数回推的节点计数、最终布局统计。

## 参数
- `laneGapY`、`colSpacing`、`rowOffset`、`startX/startY` 可调；
- 车道排序策略：`idNumeric | portIndex | typePriority`（默认 `idNumeric`）。

确认后我将按该方案改造实现，并在快速布局中完成验证。