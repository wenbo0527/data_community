# TaskFlowCanvas 功能加载时序图与评估方案

## 1. 系统初始化时序图

### 1.1 整体初始化流程

```mermaid
sequenceDiagram
    participant User as 用户
    participant Vue as Vue组件
    participant Canvas as TaskFlowCanvas
    participant X6 as X6图形引擎
    participant Layout as 布局引擎
    participant Preview as PreviewLineSystem
    participant Drag as 拖拽系统

    User->>Vue: 访问页面
    Vue->>Canvas: 组件挂载(onMounted)
    
    Note over Canvas: 阶段1: 基础初始化
    Canvas->>X6: 创建Graph实例
    X6-->>Canvas: Graph创建完成
    Canvas->>Canvas: 注册自定义节点形状
    Canvas->>Canvas: 配置画布选项
    
    Note over Canvas: 阶段2: 插件初始化
    Canvas->>X6: 注册MiniMap插件
    Canvas->>X6: 注册Export插件
    Canvas->>X6: 注册History插件
    Canvas->>X6: 注册Snapline插件
    
    Note over Canvas: 阶段3: 事件监听器设置
    Canvas->>X6: 绑定节点事件监听器
    Canvas->>X6: 绑定连接事件监听器
    Canvas->>X6: 绑定画布事件监听器
    
    Note over Canvas: 阶段4: 数据加载
    Canvas->>Canvas: 加载初始节点数据
    Canvas->>Canvas: 加载初始连接数据
    
    Note over Canvas: 阶段5: 布局引擎初始化
    Canvas->>Layout: 创建UnifiedStructuredLayoutEngine
    Layout-->>Canvas: 布局引擎就绪
    
    Note over Canvas: 阶段6: 预览线系统初始化
    Canvas->>Preview: 创建PreviewLineSystem实例
    Preview->>Preview: 初始化核心模块
    Preview->>Preview: 设置布局引擎引用
    Preview-->>Canvas: 预览线系统就绪
    
    Note over Canvas: 阶段7: 拖拽系统启用
    Canvas->>Drag: 启用节点拖拽
    Canvas->>Drag: 配置拖拽约束
    Drag-->>Canvas: 拖拽系统就绪
    
    Canvas-->>Vue: 初始化完成
    Vue-->>User: 页面可交互
```

### 1.2 PreviewLineSystem 详细初始化流程

```mermaid
sequenceDiagram
    participant Canvas as TaskFlowCanvas
    participant PLS as PreviewLineSystem
    participant EM as EventManager
    participant SM as StateManager
    participant CM as ConfigManager
    participant PLM as PreviewLineManager
    participant Renderer as 渲染器

    Canvas->>PLS: new PreviewLineSystem()
    
    Note over PLS: 构造函数初始化
    PLS->>EM: 创建EventManager
    PLS->>SM: 创建StateManager
    PLS->>CM: 创建ConfigManager
    PLS->>PLM: 创建PreviewLineManager
    PLS->>Renderer: 创建渲染器模块
    
    Canvas->>PLS: init()
    
    Note over PLS: 初始化流程
    PLS->>EM: 初始化事件管理器
    PLS->>SM: 初始化状态管理器
    PLS->>CM: 加载配置
    PLS->>PLM: 初始化预览线管理器
    PLS->>Renderer: 初始化渲染器
    
    Note over PLS: 设置依赖关系
    Canvas->>PLS: setLayoutEngine(layoutEngine)
    PLS->>PLM: 传递布局引擎引用
    
    Note over PLS: 事件监听器设置
    PLS->>EM: 绑定图形事件
    PLS->>EM: 绑定节点事件
    PLS->>EM: 绑定连接事件
    
    PLS-->>Canvas: 初始化完成
```

## 2. 功能加载流程图

### 2.1 节点加载流程

```mermaid
flowchart TD
    A[开始加载节点] --> B{检查初始节点数据}
    B -->|有数据| C[遍历节点数据]
    B -->|无数据| D[创建默认开始节点]
    
    C --> E[验证节点配置]
    E --> F{配置有效?}
    F -->|是| G[创建X6节点实例]
    F -->|否| H[使用默认配置]
    H --> G
    
    G --> I[添加到画布]
    I --> J[更新节点数组]
    J --> K[触发节点创建事件]
    
    D --> L[创建开始节点配置]
    L --> G
    
    K --> M{还有节点?}
    M -->|是| C
    M -->|否| N[节点加载完成]
    
    N --> O[触发预览线生成]
    O --> P[结束]
```

### 2.2 连接线加载流程

```mermaid
flowchart TD
    A[开始加载连接] --> B{检查连接数据}
    B -->|有数据| C[遍历连接数据]
    B -->|无数据| D[跳过连接加载]
    
    C --> E[验证源节点存在]
    E --> F{源节点有效?}
    F -->|否| G[记录错误并跳过]
    F -->|是| H[验证目标节点存在]
    
    H --> I{目标节点有效?}
    I -->|否| G
    I -->|是| J[创建连接配置]
    
    J --> K[验证连接配置]
    K --> L{配置有效?}
    L -->|否| G
    L -->|是| M[创建X6边实例]
    
    M --> N[添加到画布]
    N --> O[更新连接数组]
    O --> P[触发连接创建事件]
    
    G --> Q{还有连接?}
    P --> Q
    Q -->|是| C
    Q -->|否| R[连接加载完成]
    
    D --> R
    R --> S[结束]
```

### 2.3 预览线生成流程

```mermaid
flowchart TD
    A[触发预览线生成] --> B{PreviewLineSystem就绪?}
    B -->|否| C[等待系统初始化]
    C --> D{超时?}
    D -->|是| E[记录错误并退出]
    D -->|否| B
    
    B -->|是| F[获取所有节点]
    F --> G[遍历节点]
    G --> H[检查节点类型]
    H --> I{支持预览线?}
    I -->|否| J[跳过该节点]
    I -->|是| K[获取节点配置]
    
    K --> L[计算预览线位置]
    L --> M[创建预览线实例]
    M --> N[添加到画布]
    N --> O[注册到管理器]
    
    J --> P{还有节点?}
    O --> P
    P -->|是| G
    P -->|否| Q[预览线生成完成]
    
    E --> R[结束]
    Q --> R
```

## 3. 异常情况处理方案

### 3.1 初始化超时处理

```mermaid
flowchart TD
    A[开始初始化] --> B[设置超时定时器]
    B --> C[执行初始化步骤]
    C --> D{初始化完成?}
    D -->|是| E[清除定时器]
    D -->|否| F{超时?}
    F -->|否| C
    F -->|是| G[触发超时处理]
    
    G --> H[记录超时错误]
    H --> I[尝试降级初始化]
    I --> J{降级成功?}
    J -->|是| K[部分功能可用]
    J -->|否| L[显示错误提示]
    
    E --> M[初始化成功]
    K --> N[继续运行]
    L --> O[禁用相关功能]
    
    M --> P[结束]
    N --> P
    O --> P
```

### 3.2 组件加载失败处理

| 失败组件 | 检测方式 | 处理策略 | 降级方案 |
|---------|---------|---------|---------|
| X6图形引擎 | 实例创建检查 | 重试3次，间隔1秒 | 显示静态图片 |
| 布局引擎 | 方法调用检查 | 使用默认布局 | 手动布局模式 |
| PreviewLineSystem | 初始化状态检查 | 重新初始化 | 禁用预览线功能 |
| 拖拽系统 | 事件绑定检查 | 重新绑定事件 | 只读模式 |
| 小地图插件 | 插件注册检查 | 跳过插件加载 | 隐藏小地图按钮 |

### 3.3 预览线系统异常处理

```javascript
// 预览线系统异常处理示例
const handlePreviewLineError = (error, context) => {
  const errorTypes = {
    INITIALIZATION_TIMEOUT: {
      message: '预览线系统初始化超时',
      action: () => {
        // 重新初始化
        previewLineSystem = null
        initializePreviewLineSystem()
      }
    },
    LAYOUT_ENGINE_NOT_READY: {
      message: '布局引擎未就绪',
      action: () => {
        // 等待布局引擎就绪后重试
        waitForLayoutEngine().then(() => {
          previewLineSystem.setLayoutEngine(layoutEngine)
        })
      }
    },
    METHOD_NOT_FOUND: {
      message: '预览线方法不存在',
      action: () => {
        // 检查系统版本兼容性
        checkSystemCompatibility()
      }
    }
  }
  
  const errorHandler = errorTypes[error.type] || {
    message: '未知预览线错误',
    action: () => console.error('未处理的预览线错误:', error)
  }
  
  console.error(`[PreviewLineSystem] ${errorHandler.message}:`, error)
  errorHandler.action()
}
```

## 4. 性能评估指标

### 4.1 加载时间指标

| 指标名称 | 目标值 | 测量方式 | 优化建议 |
|---------|--------|---------|---------|
| 组件挂载时间 | < 100ms | performance.mark() | 减少同步操作 |
| X6初始化时间 | < 200ms | 构造函数计时 | 延迟插件加载 |
| 预览线系统初始化 | < 300ms | init()方法计时 | 异步初始化 |
| 首次渲染时间 | < 500ms | 首屏渲染完成 | 虚拟滚动 |
| 交互就绪时间 | < 800ms | 事件绑定完成 | 优先级加载 |

### 4.2 内存使用指标

```javascript
// 内存监控示例
const memoryMonitor = {
  baseline: 0,
  checkpoints: {},
  
  record(checkpoint) {
    if (performance.memory) {
      this.checkpoints[checkpoint] = {
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit,
        timestamp: Date.now()
      }
    }
  },
  
  analyze() {
    const results = {}
    Object.entries(this.checkpoints).forEach(([name, data]) => {
      results[name] = {
        memoryUsed: `${(data.used / 1024 / 1024).toFixed(2)}MB`,
        memoryGrowth: this.baseline ? 
          `${((data.used - this.baseline) / 1024 / 1024).toFixed(2)}MB` : '0MB'
      }
    })
    return results
  }
}

// 使用示例
memoryMonitor.record('component-mount')
memoryMonitor.record('x6-initialized')
memoryMonitor.record('preview-system-ready')
```

### 4.3 渲染性能指标

| 指标名称 | 目标值 | 测量方式 | 关键因素 |
|---------|--------|---------|---------|
| 帧率(FPS) | > 30fps | requestAnimationFrame | 节点数量、动画复杂度 |
| 节点渲染时间 | < 16ms | 单个节点渲染耗时 | 节点复杂度、样式计算 |
| 预览线渲染时间 | < 10ms | 预览线生成耗时 | 算法复杂度、节点数量 |
| 拖拽响应时间 | < 5ms | 鼠标事件响应 | 事件处理复杂度 |

## 5. 测试验证方案

### 5.1 单元测试方案

```javascript
// TaskFlowCanvas 单元测试示例
describe('TaskFlowCanvas 初始化测试', () => {
  let wrapper
  
  beforeEach(() => {
    wrapper = mount(TaskFlowCanvas, {
      props: {
        initialNodes: [],
        initialConnections: []
      }
    })
  })
  
  test('应该正确初始化X6图形引擎', async () => {
    await nextTick()
    expect(wrapper.vm.graph).toBeDefined()
    expect(wrapper.vm.graph.constructor.name).toBe('Graph')
  })
  
  test('应该正确初始化预览线系统', async () => {
    await nextTick()
    await new Promise(resolve => setTimeout(resolve, 500))
    expect(wrapper.vm.previewLineSystem).toBeDefined()
    expect(wrapper.vm.isInitializationComplete).toBe(true)
  })
  
  test('应该正确处理初始化超时', async () => {
    // 模拟初始化超时
    const consoleSpy = vi.spyOn(console, 'warn')
    wrapper.vm.initializationTimeout = 100
    
    await new Promise(resolve => setTimeout(resolve, 200))
    expect(consoleSpy).toHaveBeenCalledWith(
      expect.stringContaining('初始化超时')
    )
  })
})
```

### 5.2 集成测试方案

```javascript
// 预览线系统集成测试
describe('PreviewLineSystem 集成测试', () => {
  let canvas, previewSystem, layoutEngine
  
  beforeEach(async () => {
    canvas = mount(TaskFlowCanvas)
    await nextTick()
    
    previewSystem = canvas.vm.previewLineSystem
    layoutEngine = canvas.vm.layoutEngine
  })
  
  test('预览线系统应该与布局引擎正确集成', () => {
    expect(previewSystem.getLayoutEngine()).toBe(layoutEngine)
    expect(previewSystem.isLayoutEngineReady()).toBe(true)
  })
  
  test('节点移动应该触发预览线更新', async () => {
    const spy = vi.spyOn(previewSystem, 'updatePreviewLinePosition')
    
    // 模拟节点移动
    const node = canvas.vm.graph.addNode({
      id: 'test-node',
      x: 100,
      y: 100
    })
    
    node.setPosition({ x: 200, y: 200 })
    await nextTick()
    
    expect(spy).toHaveBeenCalledWith(node)
  })
})
```

### 5.3 端到端测试方案

```javascript
// E2E 测试示例 (使用 Playwright)
test('完整的节点创建和连接流程', async ({ page }) => {
  await page.goto('/marketing/tasks')
  
  // 等待画布加载完成
  await page.waitForSelector('.task-flow-canvas')
  await page.waitForFunction(() => window.previewLineSystem !== undefined)
  
  // 创建节点
  await page.click('[data-testid="add-sms-node"]')
  await page.click('.canvas-container', { position: { x: 200, y: 200 } })
  
  // 验证节点创建
  const nodes = await page.locator('.vue-shape').count()
  expect(nodes).toBeGreaterThan(0)
  
  // 验证预览线生成
  const previewLines = await page.locator('[id*="preview"]').count()
  expect(previewLines).toBeGreaterThan(0)
  
  // 测试节点拖拽
  await page.dragAndDrop(
    '.vue-shape:first-child',
    '.canvas-container',
    { targetPosition: { x: 300, y: 300 } }
  )
  
  // 验证拖拽后预览线更新
  await page.waitForTimeout(100)
  const updatedPreviewLines = await page.locator('[id*="preview"]').count()
  expect(updatedPreviewLines).toBeGreaterThan(0)
})
```

### 5.4 性能测试方案

```javascript
// 性能测试示例
describe('TaskFlowCanvas 性能测试', () => {
  test('大量节点加载性能', async () => {
    const startTime = performance.now()
    
    const nodes = Array.from({ length: 100 }, (_, i) => ({
      id: `node-${i}`,
      type: 'sms',
      position: { x: (i % 10) * 150, y: Math.floor(i / 10) * 100 }
    }))
    
    const wrapper = mount(TaskFlowCanvas, {
      props: { initialNodes: nodes }
    })
    
    await nextTick()
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    const endTime = performance.now()
    const loadTime = endTime - startTime
    
    expect(loadTime).toBeLessThan(2000) // 2秒内完成加载
    expect(wrapper.vm.nodes.length).toBe(100)
  })
  
  test('预览线生成性能', async () => {
    const wrapper = mount(TaskFlowCanvas)
    await nextTick()
    
    const startTime = performance.now()
    
    // 触发预览线生成
    await wrapper.vm.previewLineSystem.forceRegeneratePreviewLines()
    
    const endTime = performance.now()
    const generateTime = endTime - startTime
    
    expect(generateTime).toBeLessThan(500) // 500ms内完成生成
  })
})
```

## 6. 监控和调试方案

### 6.1 实时监控指标

```javascript
// 实时监控系统
const monitoringSystem = {
  metrics: {
    initializationTime: 0,
    renderingFPS: 0,
    memoryUsage: 0,
    errorCount: 0,
    previewLineCount: 0
  },
  
  startMonitoring() {
    // FPS监控
    let frameCount = 0
    let lastTime = performance.now()
    
    const measureFPS = () => {
      frameCount++
      const currentTime = performance.now()
      
      if (currentTime - lastTime >= 1000) {
        this.metrics.renderingFPS = frameCount
        frameCount = 0
        lastTime = currentTime
      }
      
      requestAnimationFrame(measureFPS)
    }
    
    measureFPS()
    
    // 内存监控
    setInterval(() => {
      if (performance.memory) {
        this.metrics.memoryUsage = performance.memory.usedJSHeapSize
      }
    }, 5000)
  },
  
  reportMetrics() {
    return {
      ...this.metrics,
      timestamp: Date.now()
    }
  }
}
```

### 6.2 错误追踪和日志

```javascript
// 错误追踪系统
const errorTracker = {
  errors: [],
  
  track(error, context) {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      context: context,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    }
    
    this.errors.push(errorInfo)
    
    // 发送到监控服务
    this.sendToMonitoring(errorInfo)
  },
  
  sendToMonitoring(errorInfo) {
    // 发送错误信息到监控服务
    fetch('/api/errors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(errorInfo)
    }).catch(console.error)
  }
}
```

## 7. 优化建议

### 7.1 初始化优化

1. **分阶段初始化**: 将初始化过程分为关键路径和非关键路径
2. **异步加载**: 非关键组件使用异步加载，避免阻塞主线程
3. **预加载策略**: 预加载常用的节点类型和配置
4. **缓存机制**: 缓存初始化结果，避免重复计算

### 7.2 性能优化

1. **虚拟化渲染**: 大量节点时使用虚拟化技术
2. **防抖节流**: 对频繁触发的事件进行防抖处理
3. **内存管理**: 及时清理不需要的对象引用
4. **批量更新**: 将多个DOM操作合并为批量更新

### 7.3 用户体验优化

1. **加载指示器**: 显示详细的加载进度
2. **错误恢复**: 提供错误恢复机制和用户指导
3. **降级方案**: 在功能不可用时提供替代方案
4. **性能提示**: 在性能较差时给出优化建议

这个完整的评估方案涵盖了TaskFlowCanvas系统的各个方面，从初始化时序到性能监控，为系统的稳定运行和持续优化提供了全面的指导。