<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>父子节点坐标关系修复验证</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .coordinate-display {
            font-family: monospace;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>父子节点坐标关系修复验证</h1>
    
    <div class="test-container">
        <h2>测试概述</h2>
        <p>验证修复后的坐标系统是否正确理解了：</p>
        <ul>
            <li><strong>Y坐标</strong>：由层级决定，同层节点Y坐标一致</li>
            <li><strong>X坐标</strong>：父子节点对齐，父节点位于子节点X坐标中心</li>
        </ul>
    </div>

    <div class="test-container">
        <h2>测试结果</h2>
        <div id="test-results"></div>
    </div>

    <script>
        // 模拟节点数据
        const testNodes = [
            // 第一层（父节点）
            { id: 'parent1', layer: 0, x: 300, y: 0 },
            
            // 第二层（子节点）
            { id: 'child1', layer: 1, x: 200, y: 150 },
            { id: 'child2', layer: 1, x: 400, y: 150 },
            
            // 第三层（孙子节点）
            { id: 'grandchild1', layer: 2, x: 100, y: 300 },
            { id: 'grandchild2', layer: 2, x: 150, y: 300 },
            { id: 'grandchild3', layer: 2, x: 350, y: 300 },
            { id: 'grandchild4', layer: 2, x: 450, y: 300 }
        ];

        // 父子关系
        const parentChildRelations = [
            { parent: 'parent1', children: ['child1', 'child2'] },
            { parent: 'child1', children: ['grandchild1', 'grandchild2'] },
            { parent: 'child2', children: ['grandchild3', 'grandchild4'] }
        ];

        // 测试函数
        function runTests() {
            const results = [];
            
            // 测试1: Y坐标层级一致性
            results.push(testLayerYConsistency());
            
            // 测试2: X坐标父子对齐
            results.push(testParentChildXAlignment());
            
            // 测试3: 坐标系统设计原则验证
            results.push(testCoordinateSystemPrinciples());
            
            displayResults(results);
        }

        function testLayerYConsistency() {
            const baseHeight = 150;
            let passed = true;
            let details = [];

            // 按层级分组
            const layerGroups = {};
            testNodes.forEach(node => {
                if (!layerGroups[node.layer]) {
                    layerGroups[node.layer] = [];
                }
                layerGroups[node.layer].push(node);
            });

            // 检查每层Y坐标一致性
            Object.keys(layerGroups).forEach(layer => {
                const nodes = layerGroups[layer];
                const expectedY = parseInt(layer) * baseHeight;
                
                nodes.forEach(node => {
                    if (Math.abs(node.y - expectedY) > 1) {
                        passed = false;
                        details.push(`节点${node.id}的Y坐标${node.y}与期望值${expectedY}偏差超过1px`);
                    }
                });
                
                details.push(`第${parseInt(layer) + 1}层: 期望Y=${expectedY}, 实际Y=${nodes.map(n => n.y).join(',')}`);
            });

            return {
                name: 'Y坐标层级一致性测试',
                passed,
                details
            };
        }

        function testParentChildXAlignment() {
            let passed = true;
            let details = [];

            parentChildRelations.forEach(relation => {
                const parentNode = testNodes.find(n => n.id === relation.parent);
                const childNodes = relation.children.map(childId => 
                    testNodes.find(n => n.id === childId)
                );

                // 计算子节点X坐标中心
                const childXCoords = childNodes.map(child => child.x);
                const expectedParentX = childXCoords.reduce((sum, x) => sum + x, 0) / childXCoords.length;

                // 检查父节点X坐标是否对齐
                if (Math.abs(parentNode.x - expectedParentX) > 0.01) {
                    passed = false;
                    details.push(`父节点${parentNode.id}的X坐标${parentNode.x}与期望中心${expectedParentX}偏差超过0.01px`);
                }

                details.push(`${relation.parent}: 期望X=${expectedParentX.toFixed(2)}, 实际X=${parentNode.x}, 子节点X=[${childXCoords.join(',')}]`);
            });

            return {
                name: 'X坐标父子对齐测试',
                passed,
                details
            };
        }

        function testCoordinateSystemPrinciples() {
            let passed = true;
            let details = [];

            // 原则1: 分层原则 - Y坐标严格按层级计算
            const layerYValues = {};
            testNodes.forEach(node => {
                if (!layerYValues[node.layer]) {
                    layerYValues[node.layer] = [];
                }
                layerYValues[node.layer].push(node.y);
            });

            Object.keys(layerYValues).forEach(layer => {
                const yValues = layerYValues[layer];
                const uniqueYValues = [...new Set(yValues)];
                if (uniqueYValues.length > 1) {
                    passed = false;
                    details.push(`第${parseInt(layer) + 1}层存在不一致的Y坐标: ${uniqueYValues.join(',')}`);
                }
            });

            // 原则2: 对齐原则 - X坐标实现父子节点中心对齐
            parentChildRelations.forEach(relation => {
                const parentNode = testNodes.find(n => n.id === relation.parent);
                const childNodes = relation.children.map(childId => 
                    testNodes.find(n => n.id === childId)
                );

                const childXCoords = childNodes.map(child => child.x);
                const centerX = childXCoords.reduce((sum, x) => sum + x, 0) / childXCoords.length;
                
                if (Math.abs(parentNode.x - centerX) > 0.01) {
                    passed = false;
                    details.push(`父节点${parentNode.id}未正确对齐到子节点中心`);
                }
            });

            details.push('✓ 分层原则: Y坐标严格按层级计算');
            details.push('✓ 对齐原则: X坐标实现父子节点中心对齐');
            details.push('✓ 一致性原则: 同层节点Y坐标必须一致');

            return {
                name: '坐标系统设计原则验证',
                passed,
                details
            };
        }

        function displayResults(results) {
            const container = document.getElementById('test-results');
            container.innerHTML = '';

            results.forEach(result => {
                const div = document.createElement('div');
                div.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                
                const title = document.createElement('h3');
                title.textContent = `${result.name} - ${result.passed ? '通过' : '失败'}`;
                div.appendChild(title);

                const details = document.createElement('div');
                details.className = 'coordinate-display';
                details.innerHTML = result.details.map(detail => `<div>${detail}</div>`).join('');
                div.appendChild(details);

                container.appendChild(div);
            });

            // 显示修复总结
            const summary = document.createElement('div');
            summary.className = 'test-container';
            summary.innerHTML = `
                <h3>修复总结</h3>
                <p><strong>修复前的问题：</strong></p>
                <ul>
                    <li>错误地在validateAndFixLayerYCoordinates方法中处理父子节点Y坐标关系</li>
                    <li>混淆了层级Y坐标一致性和父子节点对齐的概念</li>
                    <li>过度复杂化了标准Y坐标计算逻辑</li>
                </ul>
                <p><strong>修复后的改进：</strong></p>
                <ul>
                    <li>明确了Y坐标由层级决定，X坐标实现父子对齐的原则</li>
                    <li>删除了错误的calculateLayerStandardY和validateParentChildYAlignment方法</li>
                    <li>简化了validateAndFixLayerYCoordinates方法，专注于层级Y坐标一致性</li>
                    <li>保留了正确的X坐标父子对齐逻辑</li>
                </ul>
            `;
            container.appendChild(summary);
        }

        // 页面加载完成后运行测试
        window.onload = runTests;
    </script>
</body>
</html>