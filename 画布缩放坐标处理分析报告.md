# 画布缩放坐标处理分析报告

## 问题概述

在画布放大缩小时，坐标处理涉及多个层面的转换，包括DOM坐标、逻辑坐标、以及拖拽新阶段时的坐标偏移问题。

## 坐标系统架构

### 1. 坐标系统管理器 (CoordinateSystemManager)

**文件位置**: `src/utils/CoordinateSystemManager.js`

**核心功能**:
- 逻辑坐标与DOM坐标的相互转换
- 画布变换状态获取
- 节点位置修正
- 拖拽点坐标修正

**关键方法**:

```javascript
// 逻辑坐标转DOM坐标
logicalToDOM(logicalX, logicalY) {
  const transform = this.getCanvasTransform();
  const scale = transform.scale;
  const translate = transform.translate;
  
  // 先缩放，再平移
  const domX = logicalX * scale.sx + translate.tx;
  const domY = logicalY * scale.sy + translate.ty;
  
  return { x: domX, y: domY };
}

// DOM坐标转逻辑坐标
DOMToLogical(domX, domY) {
  const transform = this.getCanvasTransform();
  const scale = transform.scale;
  const translate = transform.translate;
  
  // 逆变换：先减去平移，再除以缩放
  const logicalX = (domX - translate.tx) / scale.sx;
  const logicalY = (domY - translate.ty) / scale.sy;
  
  return { x: logicalX, y: logicalY };
}
```

### 2. 画布拖拽缩放管理器 (CanvasPanZoomManager)

**文件位置**: `src/utils/CanvasPanZoomManager.js`

**缩放处理**:
```javascript
// 在指定点缩放
zoomAtPoint(delta, clientX, clientY) {
  const currentScale = this.graph.zoom()
  const newScale = Math.max(this.minScale, Math.min(this.maxScale, currentScale + delta))
  
  if (newScale !== currentScale) {
    // 计算缩放中心点
    const graphPoint = this.graph.clientToLocal(clientX, clientY)
    
    // 应用缩放
    this.graph.zoom(newScale, { absolute: true })
    
    // 调整位置以保持缩放中心点不变
    const newGraphPoint = this.graph.clientToLocal(clientX, clientY)
    const dx = graphPoint.x - newGraphPoint.x
    const dy = graphPoint.y - newGraphPoint.y
    
    this.graph.translate(dx, dy)
  }
}
```

### 3. X6原生坐标转换

**使用场景**: 事件处理、拖拽操作

**关键API**:
- `graph.clientToLocal(clientX, clientY)` - 客户端坐标转画布坐标
- `graph.localToClient(localX, localY)` - 画布坐标转客户端坐标
- `graph.localToGraph(localX, localY)` - 本地坐标转图形坐标
- `graph.graphToLocal(graphX, graphY)` - 图形坐标转本地坐标

## 拖拽新阶段坐标处理流程

### 1. 拖拽事件处理

**文件位置**: `src/pages/marketing/tasks/create.vue`

```javascript
// 画布放置事件
const handleCanvasDrop = (event) => {
  event.preventDefault()
  const nodeType = event.dataTransfer.getData('nodeType')
  
  // 使用event.offsetX和event.offsetY获取相对于画布的坐标
  if (canvasRef.value) {
    canvasRef.value.addNode(nodeType, {
      x: event.offsetX,
      y: event.offsetY
    })
  }
}
```

### 2. 节点添加处理

**文件位置**: `src/pages/marketing/tasks/components/TaskFlowCanvas.vue`

```javascript
// 添加节点方法
const addNode = (nodeType, position) => {
  const nodeConfig = getNodeConfig(nodeType)
  if (!nodeConfig) return

  const newNodeData = {
    id: `node_${Date.now()}`,
    type: nodeType,
    label: nodeConfig.label,
    position: position || { x: 200, y: 200 }, // 使用传入的坐标
    data: {},
    config: nodeConfig
  }

  addNodeToGraph(newNodeData)
  return newNodeData
}
```

## 坐标偏移问题分析

### 1. 问题根源

1. **多重坐标系混用**: DOM坐标、逻辑坐标、客户端坐标之间的转换不一致
2. **缩放状态未考虑**: 拖拽时使用的`event.offsetX/Y`未考虑画布缩放状态
3. **坐标转换时机**: 在不同的事件处理阶段使用了不同的坐标转换方法

### 2. 具体表现

- 画布缩放后，拖拽新阶段的位置与鼠标位置不匹配
- 缩放比例越大，偏移越明显
- 不同浏览器可能有不同的表现

### 3. 解决方案

#### 方案1: 使用X6原生坐标转换

```javascript
const handleCanvasDrop = (event) => {
  event.preventDefault()
  const nodeType = event.dataTransfer.getData('nodeType')
  
  // 使用X6原生坐标转换
  const position = graph.clientToLocal(event.clientX, event.clientY)
  
  if (canvasRef.value) {
    canvasRef.value.addNode(nodeType, position)
  }
}
```

#### 方案2: 使用坐标系统管理器

```javascript
const handleCanvasDrop = (event) => {
  event.preventDefault()
  const nodeType = event.dataTransfer.getData('nodeType')
  
  // 获取画布容器的边界矩形
  const canvasRect = event.target.getBoundingClientRect()
  const domX = event.clientX - canvasRect.left
  const domY = event.clientY - canvasRect.top
  
  // 使用坐标系统管理器转换
  const position = coordinateManager.DOMToLogical(domX, domY)
  
  if (canvasRef.value) {
    canvasRef.value.addNode(nodeType, position)
  }
}
```

#### 方案3: 综合修正方案

```javascript
const handleCanvasDrop = (event) => {
  event.preventDefault()
  const nodeType = event.dataTransfer.getData('nodeType')
  
  let position
  
  // 优先使用X6原生方法
  if (graph && typeof graph.clientToLocal === 'function') {
    position = graph.clientToLocal(event.clientX, event.clientY)
  } else {
    // 备用方案：手动计算
    const canvasRect = event.target.getBoundingClientRect()
    const domX = event.clientX - canvasRect.left
    const domY = event.clientY - canvasRect.top
    
    if (coordinateManager) {
      position = coordinateManager.DOMToLogical(domX, domY)
    } else {
      // 最后备用：直接使用offset坐标
      position = { x: event.offsetX, y: event.offsetY }
    }
  }
  
  if (canvasRef.value) {
    canvasRef.value.addNode(nodeType, position)
  }
}
```

## 缩放监听和坐标更新

### 1. 缩放事件监听

**文件位置**: `src/pages/marketing/tasks/components/TaskFlowCanvas.vue`

```javascript
// 监听缩放变化
const watchZoomChange = () => {
  if (graph) {
    let scaleTimeout = null
    let isScaleEventProcessing = false

    graph.on('scale', () => {
      if (isScaleEventProcessing) return

      if (scaleTimeout) {
        clearTimeout(scaleTimeout)
      }

      scaleTimeout = setTimeout(() => {
        if (!isScaleEventProcessing) {
          isScaleEventProcessing = true
          try {
            updateCurrentScale()
            // 可以在这里添加坐标系统的更新逻辑
          } finally {
            setTimeout(() => {
              isScaleEventProcessing = false
            }, 50)
          }
        }
      }, 150)
    })
  }
}
```

### 2. 坐标系统同步

在缩放变化时，需要确保：
1. 坐标系统管理器的状态同步
2. 预览线位置的重新计算
3. 拖拽点位置的修正

## 推荐的修复方案

### 1. 立即修复 - 使用X6原生方法

修改 `create.vue` 中的 `handleCanvasDrop` 方法：

```javascript
const handleCanvasDrop = (event) => {
  event.preventDefault()
  const nodeType = event.dataTransfer.getData('nodeType')
  console.log('添加节点:', nodeType)
  
  // 获取画布组件的graph实例
  const graph = canvasRef.value?.graph
  if (graph && canvasRef.value) {
    // 使用X6原生坐标转换，自动处理缩放
    const position = graph.clientToLocal(event.clientX, event.clientY)
    canvasRef.value.addNode(nodeType, position)
  }
}
```

### 2. 长期优化 - 统一坐标处理

1. 在TaskFlowCanvas中暴露坐标转换方法
2. 统一使用坐标系统管理器
3. 添加坐标转换的调试和验证

## 测试验证方法

1. **基础测试**: 在不同缩放比例下拖拽新阶段，验证位置准确性
2. **边界测试**: 在最小/最大缩放比例下测试
3. **浏览器兼容性**: 在不同浏览器中测试
4. **性能测试**: 验证坐标转换不影响拖拽性能

## 相关文件清单

- `src/utils/CoordinateSystemManager.js` - 坐标系统管理器
- `src/utils/CanvasPanZoomManager.js` - 画布拖拽缩放管理器
- `src/pages/marketing/tasks/create.vue` - 任务创建页面
- `src/pages/marketing/tasks/components/TaskFlowCanvas.vue` - 画布组件
- `src/composables/useX6Events.js` - X6事件处理
- `src/utils/UnifiedPreviewLineManager.js` - 预览线管理器

## 总结

画布缩放时的坐标处理问题主要源于多重坐标系的混用和转换时机不当。通过使用X6原生的坐标转换方法，可以有效解决拖拽新阶段时的坐标偏移问题。建议优先采用X6原生方法，并在必要时结合坐标系统管理器进行精确控制。