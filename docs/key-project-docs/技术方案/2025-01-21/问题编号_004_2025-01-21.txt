# é¢„è§ˆçº¿åˆ·æ–°å’Œåˆ†æµç®¡ç†é‡æ„æ–¹æ¡ˆ

## é—®é¢˜èƒŒæ™¯

åœ¨å½“å‰çš„åæ ‡è®¡ç®—æµç¨‹ä¸­ï¼Œé¢„è§ˆçº¿æŒ‚è½½èŠ‚ç‚¹åçš„åˆ·æ–°ä½ç½®å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š

1. **é¢„è§ˆçº¿ä½ç½®ä¸åŒæ­¥**ï¼šèŠ‚ç‚¹æŒ‚è½½åï¼Œé¢„è§ˆçº¿ä½ç½®æœªèƒ½åŠæ—¶æ›´æ–°ï¼Œå¯¼è‡´è§†è§‰ä¸Šçš„ä¸ä¸€è‡´
2. **åˆ†æµæ–¹å¼å½±å“**ï¼šé¢„è§ˆçº¿ä½ç½®çš„ä¸å‡†ç¡®ç›´æ¥å½±å“åˆ†æµèŠ‚ç‚¹çš„å®é™…åˆ†æµæ–¹å¼
3. **ç¼ºä¹ç»Ÿä¸€ç®¡ç†**ï¼šé¢„è§ˆçº¿åˆ·æ–°é€»è¾‘åˆ†æ•£åœ¨å¤šä¸ªæ–‡ä»¶ä¸­ï¼Œç¼ºä¹ç»Ÿä¸€çš„ç®¡ç†æœºåˆ¶
4. **æ€§èƒ½é—®é¢˜**ï¼šé¢‘ç¹çš„é¢„è§ˆçº¿åˆ·æ–°å¯èƒ½å¯¼è‡´æ€§èƒ½é—®é¢˜

## ç°çŠ¶åˆ†æ

### å½“å‰é¢„è§ˆçº¿ç®¡ç†æœºåˆ¶

åŸºäºå¯¹ `UnifiedPreviewLineManager.js` çš„åˆ†æï¼Œå½“å‰ç³»ç»Ÿå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **updatePreviewLinePositionæ–¹æ³•**ï¼š
   - å¤„ç†å•æ¡å’Œåˆ†æ”¯é¢„è§ˆçº¿çš„ä½ç½®æ›´æ–°
   - åŒ…å«å¾…å¤„ç†é˜Ÿåˆ—æœºåˆ¶
   - æ”¯æŒéšè—é¢„è§ˆçº¿çš„è·³è¿‡é€»è¾‘

2. **refreshAllPreviewLinesæ–¹æ³•**ï¼š
   - æ”¯æŒæ™ºèƒ½å¸ƒå±€åçš„æ‰¹é‡åˆ·æ–°
   - å¤„ç†åˆ†æ”¯é¢„è§ˆçº¿çš„æ¢å¤å’Œæ›´æ–°
   - åŒ…å«è¯¦ç»†çš„æ—¥å¿—è®°å½•

3. **åˆ†æµèŠ‚ç‚¹å¤„ç†**ï¼š
   - æ”¯æŒå¤šåˆ†æ”¯é¢„è§ˆçº¿ç®¡ç†
   - åŒ…å«åˆ†æ”¯æ•°æ®æå–å’Œä½ç½®è®¡ç®—
   - å¤„ç†åˆ†æ”¯é¢„è§ˆçº¿çš„æ˜¾ç¤º/éšè—çŠ¶æ€

### å­˜åœ¨çš„é—®é¢˜

1. **æ—¶åºé—®é¢˜**ï¼šèŠ‚ç‚¹æŒ‚è½½å’Œé¢„è§ˆçº¿åˆ·æ–°çš„æ—¶åºä¸ä¸€è‡´
2. **çŠ¶æ€ç®¡ç†**ï¼šç¼ºä¹å¯¹èŠ‚ç‚¹æŒ‚è½½çŠ¶æ€çš„ç»Ÿä¸€è·Ÿè¸ª
3. **åˆ†æµåŒæ­¥**ï¼šåˆ†æµèŠ‚ç‚¹çš„é¢„è§ˆçº¿ä¸å®é™…è¿æ¥çŠ¶æ€ä¸åŒæ­¥
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼ºä¹æ‰¹é‡å¤„ç†å’Œå»¶è¿Ÿåˆ·æ–°æœºåˆ¶

## é‡æ„æ–¹æ¡ˆ

### 1. PreviewLineRefreshManagerï¼ˆé¢„è§ˆçº¿åˆ·æ–°ç®¡ç†å™¨ï¼‰

#### 1.1 æ ¸å¿ƒåŠŸèƒ½
- è·Ÿè¸ªèŠ‚ç‚¹æŒ‚è½½çŠ¶æ€
- ç®¡ç†é¢„è§ˆçº¿åˆ·æ–°é˜Ÿåˆ—
- å®ç°å»¶è¿Ÿåˆ·æ–°æœºåˆ¶
- å¤„ç†æ‰¹é‡åˆ·æ–°æ“ä½œ

#### 1.2 å®ç°ç»†èŠ‚

```javascript
class PreviewLineRefreshManager {
  constructor(previewLineManager) {
    this.previewLineManager = previewLineManager;
    this.mountedNodes = new Set();
    this.refreshQueue = new Map();
    this.refreshTimer = null;
    this.batchSize = 10;
    this.refreshDelay = 100; // 100mså»¶è¿Ÿ
  }

  // å¤„ç†èŠ‚ç‚¹æŒ‚è½½åçš„åˆ·æ–°
  async handlePostMountRefresh(endpointPositions) {
    const needsRefresh = new Map();
    
    for (const [nodeId, position] of endpointPositions) {
      if (this.isNodeMounted(nodeId)) {
        needsRefresh.set(nodeId, position);
      }
    }
    
    if (needsRefresh.size > 0) {
      console.log(`ğŸ”„ [é¢„è§ˆçº¿åˆ·æ–°] å¤„ç† ${needsRefresh.size} ä¸ªå·²æŒ‚è½½èŠ‚ç‚¹çš„é¢„è§ˆçº¿åˆ·æ–°`);
      await this.batchRefreshPreviewLines(needsRefresh);
    }
  }

  // æ‰¹é‡åˆ·æ–°é¢„è§ˆçº¿
  async batchRefreshPreviewLines(positions) {
    // å»¶è¿Ÿåˆ·æ–°ï¼Œç¡®ä¿DOMæ›´æ–°å®Œæˆ
    await new Promise(resolve => setTimeout(resolve, this.refreshDelay));
    
    const batches = this.createBatches(positions, this.batchSize);
    
    for (const batch of batches) {
      await Promise.all(
        batch.map(([nodeId, position]) => 
          this.refreshSinglePreviewLine(nodeId, position)
        )
      );
      
      // æ‰¹æ¬¡é—´çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…é˜»å¡UI
      await new Promise(resolve => setTimeout(resolve, 10));
    }
  }

  // åˆ·æ–°å•ä¸ªé¢„è§ˆçº¿
  async refreshSinglePreviewLine(nodeId, position) {
    try {
      const branchData = this.extractBranchData(nodeId);
      if (!branchData) return;
      
      // å¼ºåˆ¶åˆ·æ–°é¢„è§ˆçº¿ä½ç½®
      await this.previewLineManager.forceRefreshPreviewLine(
        branchData.sourceNodeId,
        branchData.branchId,
        position
      );
      
      console.log(`âœ… [é¢„è§ˆçº¿åˆ·æ–°] èŠ‚ç‚¹ ${nodeId} é¢„è§ˆçº¿åˆ·æ–°å®Œæˆ`);
    } catch (error) {
      console.error(`âŒ [é¢„è§ˆçº¿åˆ·æ–°] èŠ‚ç‚¹ ${nodeId} åˆ·æ–°å¤±è´¥:`, error);
    }
  }

  // æå–åˆ†æ”¯æ•°æ®
  extractBranchData(nodeId) {
    // ä»ç°æœ‰çš„é¢„è§ˆçº¿ç®¡ç†å™¨ä¸­æå–åˆ†æ”¯æ•°æ®
    const previewLines = this.previewLineManager.getAllPreviewLines();
    
    for (const [sourceNodeId, lineData] of previewLines) {
      if (lineData.branches) {
        for (const [branchId, branchInfo] of lineData.branches) {
          if (branchInfo.endpointNodeId === nodeId) {
            return {
              sourceNodeId,
              branchId,
              endpointNodeId: nodeId
            };
          }
        }
      }
    }
    
    return null;
  }

  // åˆ›å»ºæ‰¹æ¬¡
  createBatches(positions, batchSize) {
    const entries = Array.from(positions.entries());
    const batches = [];
    
    for (let i = 0; i < entries.length; i += batchSize) {
      batches.push(entries.slice(i, i + batchSize));
    }
    
    return batches;
  }

  // èŠ‚ç‚¹æŒ‚è½½çŠ¶æ€ç®¡ç†
  markNodeAsMounted(nodeId) {
    this.mountedNodes.add(nodeId);
    console.log(`ğŸ“Œ [é¢„è§ˆçº¿åˆ·æ–°] èŠ‚ç‚¹ ${nodeId} æ ‡è®°ä¸ºå·²æŒ‚è½½`);
  }

  unmarkNodeAsMounted(nodeId) {
    this.mountedNodes.delete(nodeId);
    console.log(`ğŸ“Œ [é¢„è§ˆçº¿åˆ·æ–°] èŠ‚ç‚¹ ${nodeId} å–æ¶ˆæŒ‚è½½æ ‡è®°`);
  }

  isNodeMounted(nodeId) {
    return this.mountedNodes.has(nodeId);
  }

  // æ¸…ç†èµ„æº
  cleanup() {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
    this.mountedNodes.clear();
    this.refreshQueue.clear();
  }
}
```

### 2. BranchFlowManagerï¼ˆåˆ†æµç®¡ç†å™¨ï¼‰

#### 2.1 æ ¸å¿ƒåŠŸèƒ½
- ç®¡ç†åˆ†æµèŠ‚ç‚¹çš„åˆ†æ”¯æ˜ å°„
- è·Ÿè¸ªåˆ†æµçŠ¶æ€å˜åŒ–
- åŒæ­¥é¢„è§ˆçº¿å’Œå®é™…è¿æ¥
- å¤„ç†åˆ†æµæ–¹å¼éªŒè¯

#### 2.2 å®ç°ç»†èŠ‚

```javascript
class BranchFlowManager {
  constructor() {
    this.branchMappings = new Map(); // åˆ†æ”¯æ˜ å°„
    this.flowStates = new Map(); // åˆ†æµçŠ¶æ€
    this.activeFlows = new Set(); // æ´»è·ƒåˆ†æµ
    this.stateChangeListeners = new Set(); // çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
  }

  // æ³¨å†Œåˆ†æ”¯åˆ†æµ
  registerBranchFlow(sourceNodeId, branchId, endpointNodeId, flowType = 'preview') {
    const key = `${sourceNodeId}-${branchId}`;
    const mapping = {
      sourceNodeId,
      branchId,
      endpointNodeId,
      flowType, // 'preview' | 'actual'
      isActive: true,
      lastUpdate: Date.now(),
      metadata: {}
    };
    
    this.branchMappings.set(key, mapping);
    this.activeFlows.add(key);
    
    console.log(`ğŸ”€ [åˆ†æµç®¡ç†] æ³¨å†Œåˆ†æµ: ${sourceNodeId} -> ${endpointNodeId} (${branchId})`);
    
    this.notifyStateChange('register', mapping);
  }

  // æ›´æ–°åˆ†æµçŠ¶æ€
  updateFlowState(sourceNodeId, branchId, state) {
    const key = `${sourceNodeId}-${branchId}`;
    const mapping = this.branchMappings.get(key);
    
    if (mapping) {
      const newState = {
        ...state,
        lastUpdate: Date.now(),
        previousState: this.flowStates.get(key)
      };
      
      this.flowStates.set(key, newState);
      mapping.lastUpdate = Date.now();
      
      console.log(`ğŸ”„ [åˆ†æµç®¡ç†] æ›´æ–°åˆ†æµçŠ¶æ€: ${key}`, newState);
      
      this.notifyStateChange('update', { mapping, state: newState });
    }
  }

  // è·å–å—å½±å“çš„ç«¯ç‚¹
  getAffectedEndpoints(sourceNodeId) {
    const affected = [];
    
    for (const [key, mapping] of this.branchMappings) {
      if (mapping.sourceNodeId === sourceNodeId && mapping.isActive) {
        affected.push({
          endpointNodeId: mapping.endpointNodeId,
          branchId: mapping.branchId,
          flowType: mapping.flowType
        });
      }
    }
    
    return affected;
  }

  // åŒæ­¥åˆ†æµçŠ¶æ€
  async syncFlowStates(sourceNodeId) {
    const affected = this.getAffectedEndpoints(sourceNodeId);
    const syncPromises = [];
    
    for (const endpoint of affected) {
      const syncPromise = this.syncSingleFlow(
        sourceNodeId,
        endpoint.branchId,
        endpoint.endpointNodeId
      );
      syncPromises.push(syncPromise);
    }
    
    const results = await Promise.allSettled(syncPromises);
    
    // å¤„ç†åŒæ­¥ç»“æœ
    results.forEach((result, index) => {
      const endpoint = affected[index];
      if (result.status === 'rejected') {
        console.error(`âŒ [åˆ†æµç®¡ç†] åŒæ­¥å¤±è´¥: ${sourceNodeId} -> ${endpoint.endpointNodeId}`, result.reason);
      } else {
        console.log(`âœ… [åˆ†æµç®¡ç†] åŒæ­¥æˆåŠŸ: ${sourceNodeId} -> ${endpoint.endpointNodeId}`);
      }
    });
    
    return results;
  }

  // åŒæ­¥å•ä¸ªåˆ†æµ
  async syncSingleFlow(sourceNodeId, branchId, endpointNodeId) {
    const key = `${sourceNodeId}-${branchId}`;
    const mapping = this.branchMappings.get(key);
    const state = this.flowStates.get(key);
    
    if (!mapping || !mapping.isActive) {
      throw new Error(`åˆ†æµæ˜ å°„ä¸å­˜åœ¨æˆ–å·²å¤±æ´»: ${key}`);
    }
    
    // éªŒè¯åˆ†æµæ–¹å¼
    const isValid = await this.validateFlowMethod(sourceNodeId, branchId, endpointNodeId);
    if (!isValid) {
      console.warn(`âš ï¸ [åˆ†æµç®¡ç†] åˆ†æµæ–¹å¼éªŒè¯å¤±è´¥: ${key}`);
    }
    
    // æ›´æ–°çŠ¶æ€
    this.updateFlowState(sourceNodeId, branchId, {
      ...state,
      syncTime: Date.now(),
      isValid
    });
    
    return { key, isValid, syncTime: Date.now() };
  }

  // éªŒè¯åˆ†æµæ–¹å¼
  async validateFlowMethod(sourceNodeId, branchId, endpointNodeId) {
    try {
      // æ£€æŸ¥é¢„è§ˆçº¿æ˜¯å¦å­˜åœ¨
      const hasPreviewLine = this.checkPreviewLineExists(sourceNodeId, branchId);
      
      // æ£€æŸ¥å®é™…è¿æ¥æ˜¯å¦å­˜åœ¨
      const hasActualConnection = this.checkActualConnectionExists(sourceNodeId, endpointNodeId);
      
      // æ£€æŸ¥åˆ†æµæ¡ä»¶æ˜¯å¦æ»¡è¶³
      const conditionsMet = this.checkFlowConditions(sourceNodeId, branchId);
      
      return hasPreviewLine && conditionsMet;
    } catch (error) {
      console.error(`âŒ [åˆ†æµç®¡ç†] éªŒè¯åˆ†æµæ–¹å¼å¤±è´¥:`, error);
      return false;
    }
  }

  // æ£€æŸ¥é¢„è§ˆçº¿æ˜¯å¦å­˜åœ¨
  checkPreviewLineExists(sourceNodeId, branchId) {
    // è¿™é‡Œéœ€è¦ä¸PreviewLineManageré›†æˆ
    // æš‚æ—¶è¿”å›trueï¼Œå®é™…å®ç°æ—¶éœ€è¦è°ƒç”¨é¢„è§ˆçº¿ç®¡ç†å™¨çš„æ–¹æ³•
    return true;
  }

  // æ£€æŸ¥å®é™…è¿æ¥æ˜¯å¦å­˜åœ¨
  checkActualConnectionExists(sourceNodeId, endpointNodeId) {
    // è¿™é‡Œéœ€è¦ä¸å›¾å½¢å¼•æ“é›†æˆ
    // æš‚æ—¶è¿”å›trueï¼Œå®é™…å®ç°æ—¶éœ€è¦æ£€æŸ¥X6å›¾å½¢ä¸­çš„å®é™…è¿æ¥
    return true;
  }

  // æ£€æŸ¥åˆ†æµæ¡ä»¶
  checkFlowConditions(sourceNodeId, branchId) {
    // è¿™é‡Œéœ€è¦æ£€æŸ¥åˆ†æµèŠ‚ç‚¹çš„é…ç½®æ¡ä»¶
    // æš‚æ—¶è¿”å›trueï¼Œå®é™…å®ç°æ—¶éœ€è¦éªŒè¯åˆ†æµæ¡ä»¶
    return true;
  }

  // æ¸…ç†éæ´»è·ƒåˆ†æµ
  cleanupInactiveFlows() {
    const now = Date.now();
    const timeout = 5 * 60 * 1000; // 5åˆ†é’Ÿè¶…æ—¶
    const toRemove = [];
    
    for (const [key, mapping] of this.branchMappings) {
      if (now - mapping.lastUpdate > timeout) {
        toRemove.push(key);
      }
    }
    
    toRemove.forEach(key => {
      this.branchMappings.delete(key);
      this.flowStates.delete(key);
      this.activeFlows.delete(key);
      console.log(`ğŸ—‘ï¸ [åˆ†æµç®¡ç†] æ¸…ç†éæ´»è·ƒåˆ†æµ: ${key}`);
    });
    
    return toRemove.length;
  }

  // æ·»åŠ çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
  addStateChangeListener(listener) {
    this.stateChangeListeners.add(listener);
  }

  // ç§»é™¤çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
  removeStateChangeListener(listener) {
    this.stateChangeListeners.delete(listener);
  }

  // é€šçŸ¥çŠ¶æ€å˜åŒ–
  notifyStateChange(type, data) {
    this.stateChangeListeners.forEach(listener => {
      try {
        listener(type, data);
      } catch (error) {
        console.error('âŒ [åˆ†æµç®¡ç†] çŠ¶æ€å˜åŒ–ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥:', error);
      }
    });
  }

  // è·å–åˆ†æµç»Ÿè®¡ä¿¡æ¯
  getFlowStatistics() {
    return {
      totalMappings: this.branchMappings.size,
      activeFlows: this.activeFlows.size,
      totalStates: this.flowStates.size,
      listeners: this.stateChangeListeners.size
    };
  }

  // æ¸…ç†èµ„æº
  cleanup() {
    this.branchMappings.clear();
    this.flowStates.clear();
    this.activeFlows.clear();
    this.stateChangeListeners.clear();
  }
}
```

### 3. é›†æˆæ–¹æ¡ˆ

#### 3.1 ä¸ç°æœ‰ç³»ç»Ÿé›†æˆ

```javascript
// åœ¨SyncManagerä¸­é›†æˆæ–°çš„ç®¡ç†å™¨
class SyncManager {
  constructor(previewLineManager) {
    this.previewLineManager = previewLineManager;
    this.syncQueue = new Map();
    this.lastSyncTime = 0;
    
    // æ–°å¢ç®¡ç†å™¨
    this.refreshManager = new PreviewLineRefreshManager(previewLineManager);
    this.branchFlowManager = new BranchFlowManager();
    
    // è®¾ç½®çŠ¶æ€å˜åŒ–ç›‘å¬
    this.branchFlowManager.addStateChangeListener(this.handleFlowStateChange.bind(this));
  }

  async syncEndpointPositions(endpointPositions) {
    console.log('ğŸ”„ [åŒæ­¥ç®¡ç†] å¼€å§‹åŒæ­¥Endpointä½ç½®');
    
    const syncPromises = [];
    
    for (const [nodeId, position] of endpointPositions) {
      const syncPromise = this.syncSingleEndpoint(nodeId, position);
      syncPromises.push(syncPromise);
    }
    
    await Promise.all(syncPromises);
    
    // å¤„ç†é¢„è§ˆçº¿æŒ‚è½½åçš„åˆ·æ–°
    await this.refreshManager.handlePostMountRefresh(endpointPositions);
    
    // åŒæ­¥åˆ†æµçŠ¶æ€
    await this.syncBranchFlows(endpointPositions);
    
    console.log('âœ… [åŒæ­¥ç®¡ç†] EndpointåŒæ­¥å®Œæˆ');
  }

  // åŒæ­¥åˆ†æµçŠ¶æ€
  async syncBranchFlows(endpointPositions) {
    const sourceNodes = new Set();
    
    // æ”¶é›†æ‰€æœ‰æºèŠ‚ç‚¹
    for (const [nodeId] of endpointPositions) {
      const affected = this.branchFlowManager.getAffectedEndpoints(nodeId);
      if (affected.length > 0) {
        sourceNodes.add(nodeId);
      }
    }
    
    // åŒæ­¥æ¯ä¸ªæºèŠ‚ç‚¹çš„åˆ†æµçŠ¶æ€
    for (const sourceNodeId of sourceNodes) {
      await this.branchFlowManager.syncFlowStates(sourceNodeId);
    }
  }

  // å¤„ç†åˆ†æµçŠ¶æ€å˜åŒ–
  handleFlowStateChange(type, data) {
    console.log(`ğŸ”€ [åŒæ­¥ç®¡ç†] åˆ†æµçŠ¶æ€å˜åŒ–: ${type}`, data);
    
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å¤„ç†é€»è¾‘
    // ä¾‹å¦‚ï¼šé€šçŸ¥å…¶ä»–ç»„ä»¶ã€æ›´æ–°UIç­‰
  }
}
```

#### 3.2 ä¸UnifiedPreviewLineManageré›†æˆ

```javascript
// æ‰©å±•UnifiedPreviewLineManager
class EnhancedUnifiedPreviewLineManager extends UnifiedPreviewLineManager {
  constructor(...args) {
    super(...args);
    this.refreshManager = new PreviewLineRefreshManager(this);
    this.branchFlowManager = new BranchFlowManager();
  }

  // é‡å†™updatePreviewLinePositionæ–¹æ³•
  async updatePreviewLinePosition(nodeId, branchId = null) {
    // è°ƒç”¨åŸæœ‰é€»è¾‘
    const result = await super.updatePreviewLinePosition(nodeId, branchId);
    
    // æ ‡è®°èŠ‚ç‚¹ä¸ºå·²æŒ‚è½½
    this.refreshManager.markNodeAsMounted(nodeId);
    
    // æ³¨å†Œåˆ†æµ
    if (branchId) {
      const endpointNodeId = this.getEndpointNodeId(nodeId, branchId);
      if (endpointNodeId) {
        this.branchFlowManager.registerBranchFlow(nodeId, branchId, endpointNodeId, 'preview');
      }
    }
    
    return result;
  }

  // å¼ºåˆ¶åˆ·æ–°é¢„è§ˆçº¿ï¼ˆæ–°å¢æ–¹æ³•ï¼‰
  async forceRefreshPreviewLine(sourceNodeId, branchId, position) {
    console.log(`ğŸ”„ [é¢„è§ˆçº¿ç®¡ç†] å¼ºåˆ¶åˆ·æ–°: ${sourceNodeId}-${branchId}`);
    
    try {
      // æ›´æ–°é¢„è§ˆçº¿ä½ç½®
      await this.updatePreviewLinePosition(sourceNodeId, branchId);
      
      // æ›´æ–°åˆ†æµçŠ¶æ€
      this.branchFlowManager.updateFlowState(sourceNodeId, branchId, {
        position,
        refreshTime: Date.now(),
        forced: true
      });
      
      return true;
    } catch (error) {
      console.error(`âŒ [é¢„è§ˆçº¿ç®¡ç†] å¼ºåˆ¶åˆ·æ–°å¤±è´¥:`, error);
      return false;
    }
  }

  // è·å–æ‰€æœ‰é¢„è§ˆçº¿ï¼ˆæ–°å¢æ–¹æ³•ï¼‰
  getAllPreviewLines() {
    // è¿”å›å½“å‰æ‰€æœ‰é¢„è§ˆçº¿çš„æ˜ å°„
    // è¿™ä¸ªæ–¹æ³•éœ€è¦æ ¹æ®å®é™…çš„æ•°æ®ç»“æ„æ¥å®ç°
    return this.previewLines || new Map();
  }

  // è·å–ç«¯ç‚¹èŠ‚ç‚¹IDï¼ˆè¾…åŠ©æ–¹æ³•ï¼‰
  getEndpointNodeId(sourceNodeId, branchId) {
    // æ ¹æ®å®é™…çš„æ•°æ®ç»“æ„æ¥è·å–ç«¯ç‚¹èŠ‚ç‚¹ID
    // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“å®ç°æ¥è°ƒæ•´
    return null;
  }
}
```

## å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šåŸºç¡€æ¶æ„ï¼ˆ1-2å¤©ï¼‰
1. åˆ›å»ºPreviewLineRefreshManagerç±»
2. åˆ›å»ºBranchFlowManagerç±»
3. ç¼–å†™åŸºç¡€å•å…ƒæµ‹è¯•

### é˜¶æ®µ2ï¼šé›†æˆå¼€å‘ï¼ˆ2-3å¤©ï¼‰
1. ä¿®æ”¹SyncManageré›†æˆæ–°ç®¡ç†å™¨
2. æ‰©å±•UnifiedPreviewLineManager
3. å®ç°çŠ¶æ€åŒæ­¥é€»è¾‘

### é˜¶æ®µ3ï¼šæµ‹è¯•éªŒè¯ï¼ˆ1-2å¤©ï¼‰
1. ç¼–å†™é›†æˆæµ‹è¯•
2. æµ‹è¯•åˆ†æµåœºæ™¯
3. æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–

### é˜¶æ®µ4ï¼šéƒ¨ç½²ä¸Šçº¿ï¼ˆ1å¤©ï¼‰
1. ä»£ç å®¡æŸ¥
2. ç°åº¦å‘å¸ƒ
3. ç›‘æ§å’Œè°ƒä¼˜

## é¢„æœŸæ•ˆæœ

1. **ä½ç½®åŒæ­¥å‡†ç¡®æ€§**ï¼šé¢„è§ˆçº¿ä½ç½®ä¸èŠ‚ç‚¹æŒ‚è½½çŠ¶æ€å®Œå…¨åŒæ­¥
2. **åˆ†æµæ–¹å¼å‡†ç¡®æ€§**ï¼šåˆ†æµèŠ‚ç‚¹çš„é¢„è§ˆçº¿ä¸å®é™…åˆ†æµæ–¹å¼ä¸€è‡´
3. **æ€§èƒ½æå‡**ï¼šé€šè¿‡æ‰¹é‡å¤„ç†å’Œå»¶è¿Ÿåˆ·æ–°æå‡æ€§èƒ½
4. **ä»£ç å¯ç»´æŠ¤æ€§**ï¼šç»Ÿä¸€çš„ç®¡ç†æœºåˆ¶ä¾¿äºç»´æŠ¤å’Œæ‰©å±•

## é£é™©è¯„ä¼°

1. **å…¼å®¹æ€§é£é™©**ï¼šä¸ç°æœ‰ä»£ç çš„é›†æˆå¯èƒ½å­˜åœ¨å…¼å®¹æ€§é—®é¢˜
2. **æ€§èƒ½é£é™©**ï¼šæ–°å¢çš„ç®¡ç†é€»è¾‘å¯èƒ½å½±å“æ€§èƒ½
3. **å¤æ‚æ€§é£é™©**ï¼šå¢åŠ äº†ç³»ç»Ÿçš„å¤æ‚æ€§

## ç¼“è§£æªæ–½

1. **æ¸è¿›å¼é›†æˆ**ï¼šåˆ†é˜¶æ®µé›†æˆï¼Œç¡®ä¿æ¯ä¸ªé˜¶æ®µéƒ½èƒ½æ­£å¸¸å·¥ä½œ
2. **å……åˆ†æµ‹è¯•**ï¼šç¼–å†™å…¨é¢çš„æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–å„ç§åœºæ™¯
3. **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶ç›‘æ§æ€§èƒ½æŒ‡æ ‡ï¼ŒåŠæ—¶å‘ç°å’Œè§£å†³é—®é¢˜
4. **å›æ»šæœºåˆ¶**ï¼šå‡†å¤‡å›æ»šæ–¹æ¡ˆï¼Œç¡®ä¿å‡ºç°é—®é¢˜æ—¶èƒ½å¿«é€Ÿæ¢å¤