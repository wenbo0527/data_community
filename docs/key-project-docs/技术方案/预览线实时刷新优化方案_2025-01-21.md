# 预览线实时刷新优化方案

## 问题背景

在Vue+X6流程图编辑器中，用户拖拽节点时预览线应该实时跟随移动，但存在明显的延迟问题，影响用户体验。

## 问题分析

### 根本原因
1. **防抖延迟过长**：UnifiedPreviewLineManager使用100ms防抖，导致预览线更新滞后
2. **缺少实时更新机制**：node:moving事件中没有预览线更新逻辑
3. **事件处理不够优化**：依赖防抖机制，缺少立即响应能力

### 影响范围
- 所有带有预览线的节点拖拽操作
- 用户体验：拖拽时预览线跟随不流畅
- 视觉效果：预览线位置与节点位置不同步

## 解决方案

### 1. 防抖延迟优化
```javascript
// 修改前：100ms延迟
this.debouncedUpdatePosition = PerformanceUtils.debounce(
  this.updatePreviewLinePosition.bind(this), 
  100
)

// 修改后：16ms延迟（约60fps）
this.debouncedUpdatePosition = PerformanceUtils.debounce(
  this.updatePreviewLinePosition.bind(this), 
  16  // 🔧 修复：减少防抖延迟到16ms（约60fps）提升实时性
)
```

### 2. 添加立即更新机制
```javascript
// 新增立即更新方法
this.immediateUpdatePosition = this.updatePreviewLinePosition.bind(this)
```

### 3. 优化事件处理逻辑
```javascript
handleNodeMove(e) {
  const { node } = e
  const nodeData = node.getData() || {}
  
  if (!this.shouldCreatePreviewLine(node)) {
    return
  }
  
  // 🔧 修复：使用立即更新提升实时性，同时保留防抖作为备份
  try {
    // 立即更新预览线位置，确保实时响应
    this.immediateUpdatePosition(node)
  } catch (error) {
    console.warn('⚠️ [统一预览线管理器] 立即更新失败，使用防抖更新:', error)
    // 如果立即更新失败，回退到防抖更新
    this.debouncedUpdatePosition(node)
  }
}
```

### 4. TaskFlowCanvas实时更新
```javascript
// 在node:moving事件中添加预览线实时更新
graph.on('node:moving', ({ node }) => {
  // ... 现有逻辑 ...
  
  // 🔧 修复：为普通节点添加预览线实时更新
  if (!isEndpoint) {
    const unifiedPreviewManager = configDrawers.value?.structuredLayout?.getConnectionPreviewManager()
    if (unifiedPreviewManager && typeof unifiedPreviewManager.immediateUpdatePosition === 'function') {
      try {
        // 立即更新预览线位置，确保拖拽时实时跟随
        unifiedPreviewManager.immediateUpdatePosition(node)
      } catch (error) {
        // 静默处理错误，避免影响拖拽性能
      }
    }
  }
})
```

## 技术实现

### 修改文件
1. **UnifiedPreviewLineManager.js**
   - 第180行：防抖延迟优化
   - 第190行：添加立即更新方法
   - 第2500行：优化handleNodeMove方法

2. **TaskFlowCanvas.vue**
   - 第1226行：添加node:moving事件中的实时更新

### 性能考虑
- **帧率优化**：16ms延迟对应约60fps，与浏览器刷新率匹配
- **错误处理**：立即更新失败时自动回退到防抖机制
- **性能保护**：在node:moving中使用静默错误处理，避免影响拖拽性能

## 预期效果

1. **实时性提升**：预览线延迟从100ms降低到16ms
2. **用户体验改善**：拖拽时预览线流畅跟随节点移动
3. **系统稳定性**：保留错误处理和回退机制
4. **性能优化**：与浏览器刷新率同步，避免不必要的计算

## 测试验证

### 测试场景
1. 拖拽带有单一预览线的节点
2. 拖拽带有分支预览线的节点
3. 快速拖拽节点测试性能
4. 异常情况下的错误处理

### 验证指标
- 预览线跟随延迟 < 20ms
- 拖拽过程中无明显卡顿
- 错误情况下系统正常运行
- CPU使用率保持合理范围

## 后续优化建议

1. **性能监控**：添加预览线更新性能监控
2. **自适应优化**：根据设备性能动态调整更新频率
3. **批量更新**：对多个预览线进行批量更新优化
4. **缓存机制**：优化位置计算的缓存策略