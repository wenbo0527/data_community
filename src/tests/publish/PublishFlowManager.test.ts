import { describe, it, expect, beforeEach, vi } from 'vitest';
import { PublishFlowManager } from '../../managers/publish/PublishFlowManager';
import { ValidationManager } from '../../managers/publish/ValidationManager';
import { EndNodeAutoGenerator } from '../../managers/publish/EndNodeAutoGenerator';
import { CycleDetector } from '../../managers/publish/CycleDetector';
import { UnifiedEventBus } from '../../managers/core/UnifiedEventBus';
import { UnifiedCacheManager } from '../../managers/core/UnifiedCacheManager';
import { ErrorHandler } from '../../managers/core/ErrorHandler';
import { CoordinateSystemManager } from '../../managers/CoordinateSystemManager';

describe('PublishFlowManager', () => {
  let publishFlowManager: PublishFlowManager;
  let mockCanvas: any;
  let mockEventBus: any;
  let mockCacheManager: any;
  let mockErrorHandler: any;
  let mockCoordinateManager: any;
  let mockValidationManager: any;
  let mockEndNodeGenerator: any;
  let mockCycleDetector: any;

  beforeEach(() => {
    // Mock Canvas
    mockCanvas = {
      getNodes: vi.fn().mockReturnValue([]),
      getEdges: vi.fn().mockReturnValue([]),
      getCellById: vi.fn(),
      getConnectedEdges: vi.fn().mockReturnValue([]),
      addNode: vi.fn(),
      addEdge: vi.fn(),
      removeNode: vi.fn(),
      removeEdge: vi.fn(),
      toJSON: vi.fn().mockReturnValue({ cells: [] }),
      container: {
        appendChild: vi.fn(),
        removeChild: vi.fn(),
        querySelector: vi.fn(),
        querySelectorAll: vi.fn()
      }
    };

    // Mock EventBus
    mockEventBus = {
      emit: vi.fn(),
      on: vi.fn(),
      off: vi.fn(),
      once: vi.fn(),
      removeAllListeners: vi.fn(),
      addMiddleware: vi.fn(),
      removeMiddleware: vi.fn(),
      getEventHistory: vi.fn().mockReturnValue([]),
      clearEventHistory: vi.fn(),
      getListenerCount: vi.fn().mockReturnValue(0)
    } as any;

    // Mock CacheManager
    mockCacheManager = {
      set: vi.fn(),
      get: vi.fn(),
      delete: vi.fn(),
      clear: vi.fn(),
      has: vi.fn(),
      keys: vi.fn(),
      size: vi.fn(),
      getStats: vi.fn()
    } as any;

    // Mock ErrorHandler
    mockErrorHandler = {
      handleError: vi.fn(),
      getErrorHistory: vi.fn().mockReturnValue([]),
      clearErrorHistory: vi.fn(),
      setErrorCallback: vi.fn(),
      getErrorStats: vi.fn()
    } as any;

    // Mock CoordinateSystemManager
    mockCoordinateManager = {
      logicalToDOM: vi.fn().mockReturnValue({ x: 100, y: 100 }),
      DOMToLogical: vi.fn().mockReturnValue({ x: 50, y: 50 }),
      calculateCoordinateOffset: vi.fn().mockReturnValue({ x: 0, y: 0 }),
      correctDragHintPosition: vi.fn().mockReturnValue({ x: 100, y: 100 }),
      correctPreviewLinePath: vi.fn().mockReturnValue([{ x: 0, y: 0 }, { x: 100, y: 100 }]),
      getNodeDOMCenter: vi.fn().mockReturnValue({ x: 50, y: 50 }),
      validateCoordinateTransform: vi.fn().mockReturnValue(true)
    } as any;

    // Mock ValidationManager
    mockValidationManager = {
      validateAll: vi.fn().mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      }),
      validateNodes: vi.fn(),
      validateConnections: vi.fn(),
      validateFlowIntegrity: vi.fn(),
      getValidationResult: vi.fn(),
      clearValidationCache: vi.fn()
    } as any;

    // Mock EndNodeAutoGenerator
    mockEndNodeGenerator = {
      detectUnconnectedPreviewLines: vi.fn().mockResolvedValue([]),
      autoAddEndNodes: vi.fn().mockResolvedValue([]),
      cleanupAutoGeneratedNodes: vi.fn().mockResolvedValue(undefined),
      getAutoGeneratedNodes: vi.fn().mockReturnValue([]),
      isAutoGeneratedNode: vi.fn().mockReturnValue(false)
    } as any;

    // Mock CycleDetector
    mockCycleDetector = {
      detectCycles: vi.fn().mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      }),
      analyzeCycleImpact: vi.fn(),
      isNodeInCycle: vi.fn().mockReturnValue(false),
      clearDetectionCache: vi.fn(),
      getDetectionStats: vi.fn().mockReturnValue({
        totalNodesChecked: 0,
        cyclesFound: 0,
        lastDetectionTime: null
      })
    } as any;

    // Mock PreviewLineManager
    const mockPreviewLineManager = {
      createPreviewLine: vi.fn(),
      removePreviewLine: vi.fn(),
      updatePreviewLine: vi.fn(),
      getPreviewLines: vi.fn().mockReturnValue([])
    } as any;

    // Mock LayoutEngine
    const mockLayoutEngine = {
      applyLayout: vi.fn().mockResolvedValue({
        success: true,
        optimizedNodes: [],
        errors: []
      }),
      calculateLayout: vi.fn(),
      optimizeLayout: vi.fn()
    } as any;

    // Mock BranchLineProcessor
    const mockBranchLineProcessor = {
      processBranchesForAllDecisionNodes: vi.fn().mockResolvedValue({
        success: true,
        processedBranches: [],
        errors: []
      }),
      getBranchesForDecisionNode: vi.fn().mockReturnValue([]),
      processUnattachedBranch: vi.fn().mockResolvedValue([])
    } as any;

    // Mock LabelManager
    const mockLabelManager = {
      updateLabelsForPublish: vi.fn().mockResolvedValue({
        success: true,
        updatedLabels: [],
        errors: []
      }),
      clearLabels: vi.fn(),
      getLabels: vi.fn().mockReturnValue([])
    } as any;

    publishFlowManager = new PublishFlowManager(
      mockCanvas,
      mockPreviewLineManager,
      mockLayoutEngine,
      mockEventBus,
      mockCacheManager,
      mockErrorHandler,
      mockCoordinateManager
    );

    // 注入mock的依赖
    (publishFlowManager as any).validationManager = mockValidationManager;
    (publishFlowManager as any).endNodeGenerator = mockEndNodeGenerator;
    (publishFlowManager as any).cycleDetector = mockCycleDetector;
    (publishFlowManager as any).branchLineProcessor = mockBranchLineProcessor;
    (publishFlowManager as any).labelManager = mockLabelManager;
  });

  describe('初始化', () => {
    it('应该正确初始化PublishFlowManager', () => {
      expect(publishFlowManager).toBeDefined();
      expect(publishFlowManager.getPublishStatus()).toBe('idle');
    });

    it('应该设置事件监听器', () => {
      expect(mockEventBus.on).toHaveBeenCalledWith('publish:flow:start', expect.any(Function));
      expect(mockEventBus.on).toHaveBeenCalledWith('publish:flow:cancel', expect.any(Function));
      expect(mockEventBus.on).toHaveBeenCalledWith('publish:validation:failed', expect.any(Function));
    });
  });

  describe('发布流程执行', () => {
    it('应该成功执行完整的发布流程', async () => {
      // Mock 成功的场景
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      mockEndNodeGenerator.detectUnconnectedPreviewLines.mockResolvedValue([]);
      mockEndNodeGenerator.autoAddEndNodes.mockResolvedValue([]);
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      });

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(true);
      expect(result.publishConfig).toBeDefined();
      expect(result.errors).toHaveLength(0);
      expect(publishFlowManager.getPublishStatus()).toBe('completed');
      
      // 验证事件发布
      expect(mockEventBus.emit).toHaveBeenCalledWith('publish:flow:started');
      expect(mockEventBus.emit).toHaveBeenCalledWith('publish:flow:completed', expect.any(Object));
    });

    it('应该在校验失败时停止发布流程', async () => {
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: false,
        errors: [{ type: 'node_config', message: '节点配置不完整' }],
        warnings: []
      });

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(false);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].message).toContain('节点配置不完整');
      expect(publishFlowManager.getPublishStatus()).toBe('failed');
      
      expect(mockEventBus.emit).toHaveBeenCalledWith('publish:validation:failed', expect.any(Object));
    });

    it('应该在检测到循环依赖时停止发布流程', async () => {
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: true,
        cycles: [{
          nodes: ['node1', 'node2'],
          path: ['node1', 'node2', 'node1'],
          severity: 'high'
        }],
        affectedNodes: ['node1', 'node2']
      });

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(false);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].type).toBe('cycle_dependency');
      expect(publishFlowManager.getPublishStatus()).toBe('failed');
      
      expect(mockEventBus.emit).toHaveBeenCalledWith('publish:cycle:detected', expect.any(Object));
    });

    it('应该处理发布流程中的异常', async () => {
      mockValidationManager.validateAll.mockRejectedValue(new Error('校验服务异常'));

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(false);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].message).toContain('校验服务异常');
      expect(publishFlowManager.getPublishStatus()).toBe('failed');
      
      expect(mockErrorHandler.handleError).toHaveBeenCalled();
    });

    it('应该能够取消正在进行的发布流程', async () => {
      // 模拟长时间运行的校验
      mockValidationManager.validateAll.mockImplementation(() => {
        return new Promise((resolve) => {
          setTimeout(() => resolve({ isValid: true, errors: [], warnings: [] }), 1000);
        });
      });

      const publishPromise = publishFlowManager.executePublishFlow();
      
      // 立即取消
      publishFlowManager.cancelPublishFlow();
      
      const result = await publishPromise;

      expect(result.success).toBe(false);
      expect(result.errors[0].type).toBe('cancelled');
      expect(publishFlowManager.getPublishStatus()).toBe('cancelled');
      
      expect(mockEventBus.emit).toHaveBeenCalledWith('publish:flow:cancelled');
    });
  });

  describe('结束节点自动添加', () => {
    it('应该检测并添加结束节点', async () => {
      const unconnectedLines = [
        { id: 'line1', targetPosition: { x: 100, y: 100 } }
      ];
      
      const addedNodes = [
        { id: 'end_node_1', type: 'END', position: { x: 150, y: 100 } }
      ];
      
      mockEndNodeGenerator.detectUnconnectedPreviewLines.mockResolvedValue(unconnectedLines);
      mockEndNodeGenerator.autoAddEndNodes.mockResolvedValue(addedNodes);
      
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      });

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(true);
      expect(mockEndNodeGenerator.detectUnconnectedPreviewLines).toHaveBeenCalled();
      expect(mockEndNodeGenerator.autoAddEndNodes).toHaveBeenCalledWith(unconnectedLines);
      expect(mockEventBus.emit).toHaveBeenCalledWith('publish:endnodes:added', addedNodes);
    });

    it('应该在没有未连接预览线时跳过结束节点添加', async () => {
      mockEndNodeGenerator.detectUnconnectedPreviewLines.mockResolvedValue([]);
      
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      });

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(true);
      expect(mockEndNodeGenerator.autoAddEndNodes).not.toHaveBeenCalled();
    });
  });

  describe('发布配置生成', () => {
    it('应该生成正确的发布配置', async () => {
      const mockNodes = [
        { 
          id: 'node1', 
          type: 'INPUT', 
          getData: () => ({ nodeType: 'INPUT', name: '输入节点' }),
          getPosition: () => ({ x: 0, y: 0 })
        },
        { 
          id: 'node2', 
          type: 'PROCESSING', 
          getData: () => ({ nodeType: 'PROCESSING', name: '处理节点' }),
          getPosition: () => ({ x: 100, y: 0 })
        },
        { 
          id: 'node3', 
          type: 'OUTPUT', 
          getData: () => ({ nodeType: 'OUTPUT', name: '输出节点' }),
          getPosition: () => ({ x: 200, y: 0 })
        }
      ];
      
      const mockEdges = [
        { 
          id: 'edge1', 
          getSourceCellId: () => 'node1', 
          getTargetCellId: () => 'node2',
          getData: () => ({})
        },
        { 
          id: 'edge2', 
          getSourceCellId: () => 'node2', 
          getTargetCellId: () => 'node3',
          getData: () => ({})
        }
      ];
      
      mockCanvas.getNodes.mockReturnValue(mockNodes);
      mockCanvas.getEdges.mockReturnValue(mockEdges);
      mockCanvas.toJSON.mockReturnValue({
        cells: [...mockNodes, ...mockEdges]
      });
      
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      });

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(true);
      expect(result.publishConfig).toBeDefined();
      expect(result.publishConfig.version).toBe('1.0');
      expect(result.publishConfig.nodes).toHaveLength(3);
      expect(result.publishConfig.edges).toHaveLength(2);
      expect(result.publishConfig.metadata.nodeCount).toBe(3);
      expect(result.publishConfig.metadata.edgeCount).toBe(2);
      expect(result.publishConfig.metadata.totalConnections).toBe(2);
    });

    it('应该在发布配置中包含自动生成的结束节点', async () => {
      const addedEndNodes = [
        { id: 'end_node_1', type: 'END', position: { x: 150, y: 100 } }
      ];
      
      mockEndNodeGenerator.detectUnconnectedPreviewLines.mockResolvedValue([
        { id: 'line1', targetPosition: { x: 100, y: 100 } }
      ]);
      mockEndNodeGenerator.autoAddEndNodes.mockResolvedValue(addedEndNodes);
      mockEndNodeGenerator.getAutoGeneratedNodes.mockReturnValue(addedEndNodes);
      
      mockCanvas.getNodes.mockReturnValue([
        { id: 'node1', type: 'INPUT', getData: () => ({ name: '输入节点' }), getPosition: () => ({ x: 0, y: 0 }) },
        ...addedEndNodes.map(node => ({
          ...node,
          getData: () => ({ nodeType: 'END_NODE' }),
          getPosition: () => node.position
        }))
      ]);
      
      mockCanvas.getEdges.mockReturnValue([
        { id: 'edge1', getSourceCellId: () => 'node1', getTargetCellId: () => 'end_node_1', getData: () => ({}) }
      ]);
      
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      });

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(true);
      expect(result.publishConfig.metadata.autoGeneratedEndNodes).toBe(1);
    });
  });

  describe('发布状态管理', () => {
    it('应该正确管理发布状态', async () => {
      expect(publishFlowManager.getPublishStatus()).toBe('idle');
      
      // 设置基本的canvas mock数据
      mockCanvas.getNodes.mockReturnValue([
        { 
          id: 'node1', 
          type: 'INPUT', 
          getData: () => ({ nodeType: 'INPUT', name: '输入节点' }), 
          getPosition: () => ({ x: 0, y: 0 }) 
        }
      ]);
      mockCanvas.getEdges.mockReturnValue([]);
      
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      });

      const publishPromise = publishFlowManager.executePublishFlow();
      
      // 检查运行中状态
      expect(publishFlowManager.getPublishStatus()).toBe('running');
      
      await publishPromise;
      
      // 检查完成状态
      expect(publishFlowManager.getPublishStatus()).toBe('completed');
    });

    it('应该提供发布进度信息', async () => {
      // 设置基本的canvas mock数据
        mockCanvas.getNodes.mockReturnValue([
          { 
            id: 'node1', 
            type: 'INPUT', 
            getData: () => ({ nodeType: 'INPUT', name: '输入节点' }), 
            getPosition: () => ({ x: 0, y: 0 }) 
          }
        ]);
        mockCanvas.getEdges.mockReturnValue([]);
      
      mockValidationManager.validateAll.mockImplementation(async () => {
        // 模拟进度更新
        return { isValid: true, errors: [], warnings: [] };
      });
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      });

      const publishPromise = publishFlowManager.executePublishFlow();
      
      // 检查进度
      const progress = publishFlowManager.getPublishProgress();
      expect(progress.currentStep).toBeDefined();
      expect(progress.totalSteps).toBeGreaterThan(0);
      expect(progress.percentage).toBeGreaterThanOrEqual(0);
      
      await publishPromise;
    });
  });

  describe('缓存管理', () => {
    it('应该缓存发布结果', async () => {
      // 设置基本的canvas mock数据
        mockCanvas.getNodes.mockReturnValue([
          { 
            id: 'node1', 
            type: 'INPUT', 
            getData: () => ({ nodeType: 'INPUT', name: '输入节点' }), 
            getPosition: () => ({ x: 0, y: 0 }) 
          }
        ]);
        mockCanvas.getEdges.mockReturnValue([]);
      
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      mockCycleDetector.detectCycles.mockResolvedValue({
        hasCycles: false,
        cycles: [],
        affectedNodes: []
      });

      const result = await publishFlowManager.executePublishFlow();

      expect(mockCacheManager.set).toHaveBeenCalledWith(
        'publish_flow_result',
        expect.objectContaining({
          success: expect.any(Boolean),
          steps: expect.any(Array),
          errors: expect.any(Array),
          warnings: expect.any(Array),
          generatedEndNodes: expect.any(Array),
          validationResults: expect.anything(),
          cycleDetectionResults: expect.anything()
        }),
        86400000
      );
    });

    it('应该能够获取缓存的发布结果', () => {
      const cachedResult = {
        success: true,
        publishConfig: { flowId: 'test-flow' },
        errors: []
      };
      
      mockCacheManager.get.mockReturnValue(cachedResult);
      
      const result = publishFlowManager.getCachedPublishResult();
      
      expect(result).toEqual(cachedResult);
      expect(mockCacheManager.get).toHaveBeenCalledWith('publish_flow_result');
    });

    it('应该能够清除发布缓存', () => {
      publishFlowManager.clearPublishCache();
      
      expect(mockCacheManager.delete).toHaveBeenCalledWith('publish_flow_result');
      expect(mockCacheManager.delete).toHaveBeenCalledWith('publish_flow_config');
      expect(mockCacheManager.delete).toHaveBeenCalledWith('publish_flow_state');
      expect(mockEventBus.emit).toHaveBeenCalledWith('publish:cache:cleared', expect.objectContaining({
        timestamp: expect.any(Number)
      }));
    });
  });

  describe('错误处理', () => {
    it('应该正确处理校验错误', async () => {
      // 设置基本的canvas mock数据
        mockCanvas.getNodes.mockReturnValue([
          { 
            id: 'node1', 
            type: 'INPUT', 
            getData: () => ({ nodeType: 'INPUT', name: '输入节点' }), 
            getPosition: () => ({ x: 0, y: 0 }) 
          }
        ]);
        mockCanvas.getEdges.mockReturnValue([]);
      
      const validationError = new Error('校验失败');
      mockValidationManager.validateAll.mockRejectedValue(validationError);

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(false);
      expect(mockErrorHandler.handleError).toHaveBeenCalledWith(validationError, {
        context: 'publish_flow_validation',
        severity: 'high'
      });
    });

    it('应该正确处理循环检测错误', async () => {
      // 设置基本的canvas mock数据
        mockCanvas.getNodes.mockReturnValue([
          { 
            id: 'node1', 
            type: 'INPUT', 
            getData: () => ({ nodeType: 'INPUT', name: '输入节点' }), 
            getPosition: () => ({ x: 0, y: 0 }) 
          }
        ]);
        mockCanvas.getEdges.mockReturnValue([]);
      
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      const cycleError = new Error('循环检测失败');
      mockCycleDetector.detectCycles.mockRejectedValue(cycleError);

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(false);
      expect(mockErrorHandler.handleError).toHaveBeenCalledWith(cycleError, {
        context: 'publish_flow_cycle_detection',
        severity: 'high'
      });
    });

    it('应该正确处理结束节点生成错误', async () => {
      // 设置基本的canvas mock数据
        mockCanvas.getNodes.mockReturnValue([
          { 
            id: 'node1', 
            type: 'INPUT', 
            getData: () => ({ nodeType: 'INPUT', name: '输入节点' }), 
            getPosition: () => ({ x: 0, y: 0 }) 
          }
        ]);
        mockCanvas.getEdges.mockReturnValue([]);
      
      mockValidationManager.validateAll.mockResolvedValue({
        isValid: true,
        errors: [],
        warnings: []
      });
      
      // 模拟有未连接的预览线，这样autoAddEndNodes才会被调用
      mockEndNodeGenerator.detectUnconnectedPreviewLines.mockResolvedValue([
        { id: 'line1', targetPosition: { x: 100, y: 100 } }
      ]);
      
      const endNodeError = new Error('结束节点生成失败');
      mockEndNodeGenerator.autoAddEndNodes.mockRejectedValue(endNodeError);

      const result = await publishFlowManager.executePublishFlow();

      expect(result.success).toBe(false);
      expect(mockErrorHandler.handleError).toHaveBeenCalledWith(endNodeError, {
        context: 'publish_flow_endnode_generation',
        severity: 'medium'
      });
    });
  });
});