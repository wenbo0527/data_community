import { describe, it, expect, beforeEach, vi } from 'vitest';
import { EndNodeAutoGenerator } from '../../managers/publish/EndNodeAutoGenerator';
import { UnifiedEventBus } from '../../managers/core/UnifiedEventBus';
import { UnifiedCacheManager } from '../../managers/core/UnifiedCacheManager';
import { ErrorHandler } from '../../managers/core/ErrorHandler';

describe('EndNodeAutoGenerator', () => {
  let endNodeGenerator: EndNodeAutoGenerator;
  let mockCanvas: any;
  let mockPreviewLineManager: any;
  let mockEventBus: UnifiedEventBus;
  let mockCacheManager: UnifiedCacheManager;
  let mockErrorHandler: ErrorHandler;

  beforeEach(() => {
    // Mock Canvas
    mockCanvas = {
      addNode: vi.fn().mockReturnValue({ id: 'end_node_1', getData: () => ({}) }),
      addEdge: vi.fn().mockReturnValue({ id: 'edge_1' }),
      getCellById: vi.fn(),
      getConnectedEdges: vi.fn().mockReturnValue([]),
      removeCell: vi.fn()
    };

    // Mock PreviewLineManager
    mockPreviewLineManager = {
      getAllPreviewLines: vi.fn().mockReturnValue([]),
      registerEndNode: vi.fn(),
      removePreviewLine: vi.fn()
    };

    // Mock EventBus
    mockEventBus = {
      emit: vi.fn(),
      on: vi.fn(),
      off: vi.fn(),
      once: vi.fn(),
      removeAllListeners: vi.fn(),
      addMiddleware: vi.fn(),
      removeMiddleware: vi.fn(),
      getEventHistory: vi.fn().mockReturnValue([]),
      clearEventHistory: vi.fn(),
      getListenerCount: vi.fn().mockReturnValue(0)
    } as any;

    // Mock CacheManager
    mockCacheManager = {
      set: vi.fn(),
      get: vi.fn(),
      delete: vi.fn(),
      clear: vi.fn(),
      has: vi.fn(),
      keys: vi.fn(),
      size: vi.fn(),
      getStats: vi.fn()
    } as any;

    // Mock ErrorHandler
    mockErrorHandler = {
      handleError: vi.fn(),
      getErrorHistory: vi.fn().mockReturnValue([]),
      clearErrorHistory: vi.fn(),
      setErrorCallback: vi.fn(),
      getErrorStats: vi.fn()
    } as any;

    endNodeGenerator = new EndNodeAutoGenerator(
      mockCanvas,
      mockPreviewLineManager,
      mockEventBus,
      mockCacheManager,
      mockErrorHandler
    );
  });

  describe('初始化', () => {
    it('应该正确初始化EndNodeAutoGenerator', () => {
      expect(endNodeGenerator).toBeDefined();
      expect(endNodeGenerator.getAutoGeneratedNodes()).toEqual([]);
    });

    it('应该有默认的结束节点配置', () => {
      const config = endNodeGenerator.getEndNodeConfig();
      expect(config.type).toBe('END_NODE');
      expect(config.shape).toBe('circle');
      expect(config.label).toBe('结束');
    });
  });

  describe('检测未连接的预览线', () => {
    it('应该检测到未连接的预览线', () => {
      const mockUnconnectedLine = {
        id: 'line_1',
        target: null
      };
      
      mockPreviewLineManager.getAllPreviewLines.mockReturnValue([mockUnconnectedLine]);
      
      const unconnectedLines = endNodeGenerator.detectUnconnectedPreviewLines();
      
      expect(unconnectedLines).toHaveLength(1);
      expect(unconnectedLines[0].id).toBe('line_1');
    });

    it('应该过滤已连接的预览线', () => {
      const mockConnectedLine = {
        id: 'line_1',
        target: { cell: 'node_1' }
      };
      const mockUnconnectedLine = {
        id: 'line_2',
        target: null
      };
      
      mockPreviewLineManager.getAllPreviewLines.mockReturnValue([
        mockConnectedLine,
        mockUnconnectedLine
      ]);
      
      const unconnectedLines = endNodeGenerator.detectUnconnectedPreviewLines();
      
      expect(unconnectedLines).toHaveLength(1);
      expect(unconnectedLines[0].id).toBe('line_2');
    });

    it('应该处理检测过程中的错误', () => {
      mockPreviewLineManager.getAllPreviewLines.mockImplementation(() => {
        throw new Error('获取预览线失败');
      });
      
      const unconnectedLines = endNodeGenerator.detectUnconnectedPreviewLines();
      
      expect(unconnectedLines).toEqual([]);
      expect(mockErrorHandler.handleError).toHaveBeenCalled();
    });
  });

  describe('自动添加结束节点', () => {
    it('应该为未连接的预览线自动添加结束节点', async () => {
      const mockUnconnectedLine = {
        id: 'line_1',
        target: null,
        getTargetPoint: () => ({ x: 100, y: 100 }),
        getDirection: () => 'horizontal',
        source: { cell: 'source_node' }
      };
      
      mockPreviewLineManager.getAllPreviewLines.mockReturnValue([mockUnconnectedLine]);
      
      const results = await endNodeGenerator.autoAddEndNodes();
      
      expect(results).toHaveLength(1);
      expect(results[0].line.id).toBe('line_1');
      expect(results[0].endNode.id).toBe('end_node_1');
      expect(mockCanvas.addNode).toHaveBeenCalled();
      expect(mockCanvas.addEdge).toHaveBeenCalled();
      expect(mockEventBus.emit).toHaveBeenCalledWith('endnode:generation:started', {
        unconnectedCount: 1
      });
      expect(mockEventBus.emit).toHaveBeenCalledWith('endnode:generation:completed', {
        addedCount: 1,
        totalUnconnected: 1
      });
    });

    it('应该记录自动生成的节点', async () => {
      const mockUnconnectedLine = {
        id: 'line_1',
        target: null,
        getTargetPoint: () => ({ x: 100, y: 100 }),
        getDirection: () => 'horizontal',
        source: { cell: 'source_node' }
      };
      
      mockPreviewLineManager.getAllPreviewLines.mockReturnValue([mockUnconnectedLine]);
      
      await endNodeGenerator.autoAddEndNodes();
      
      const autoGeneratedNodes = endNodeGenerator.getAutoGeneratedNodes();
      expect(autoGeneratedNodes).toHaveLength(1);
      expect(autoGeneratedNodes[0].nodeId).toBe('end_node_1');
      expect(autoGeneratedNodes[0].sourceLineId).toBe('line_1');
    });

    it('应该处理单个预览线添加失败的情况', async () => {
      const mockUnconnectedLine = {
        id: 'line_1',
        target: null,
        getTargetPoint: () => ({ x: 100, y: 100 }),
        getDirection: () => 'horizontal',
        source: { cell: 'source_node' }
      };
      
      mockPreviewLineManager.getAllPreviewLines.mockReturnValue([mockUnconnectedLine]);
      mockCanvas.addNode.mockImplementation(() => {
        throw new Error('添加节点失败');
      });
      
      const results = await endNodeGenerator.autoAddEndNodes();
      
      expect(results).toHaveLength(0);
      expect(mockErrorHandler.handleError).toHaveBeenCalled();
      expect(mockEventBus.emit).toHaveBeenCalledWith('endnode:creation:failed', {
        lineId: 'line_1',
        error: expect.stringContaining('添加节点失败')
      });
    });
  });

  describe('创建结束节点', () => {
    it('应该为预览线创建正确的结束节点', async () => {
      const mockLine = {
        id: 'line_1',
        getTargetPoint: () => ({ x: 100, y: 100 }),
        getDirection: () => 'horizontal'
      };
      
      const endNode = await endNodeGenerator.createEndNodeForLine(mockLine);
      
      expect(mockCanvas.addNode).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'END_NODE',
          shape: 'circle',
          position: { x: 200, y: 100 }, // 100 + 100 offset
          data: expect.objectContaining({
            isAutoGenerated: true,
            sourceLineId: 'line_1',
            nodeType: 'END_NODE'
          })
        })
      );
      expect(endNode.id).toBe('end_node_1');
    });

    it('应该正确计算水平方向的结束节点位置', async () => {
      const mockLine = {
        id: 'line_1',
        getTargetPoint: () => ({ x: 150, y: 200 }),
        getDirection: () => 'horizontal'
      };
      
      await endNodeGenerator.createEndNodeForLine(mockLine);
      
      expect(mockCanvas.addNode).toHaveBeenCalledWith(
        expect.objectContaining({
          position: { x: 250, y: 200 } // 150 + 100 offset
        })
      );
    });

    it('应该正确计算垂直方向的结束节点位置', async () => {
      const mockLine = {
        id: 'line_1',
        getTargetPoint: () => ({ x: 150, y: 200 }),
        getDirection: () => 'vertical'
      };
      
      await endNodeGenerator.createEndNodeForLine(mockLine);
      
      expect(mockCanvas.addNode).toHaveBeenCalledWith(
        expect.objectContaining({
          position: { x: 150, y: 300 } // 200 + 100 offset
        })
      );
    });

    it('应该处理无法获取预览线端点的情况', async () => {
      const mockLine = {
        id: 'line_1',
        getTargetPoint: () => null,
        getDirection: () => 'horizontal'
      };
      
      await endNodeGenerator.createEndNodeForLine(mockLine);
      
      expect(mockCanvas.addNode).toHaveBeenCalledWith(
        expect.objectContaining({
          position: { x: 200, y: 200 } // 默认位置
        })
      );
    });
  });

  describe('连接预览线到结束节点', () => {
    it('应该正确连接预览线到结束节点', async () => {
      const mockLine = {
        id: 'line_1',
        source: { cell: 'source_node' }
      };
      const mockEndNode = { id: 'end_node_1' };
      
      const connection = await endNodeGenerator.connectLineToEndNode(mockLine, mockEndNode);
      
      expect(mockCanvas.addEdge).toHaveBeenCalledWith(
        expect.objectContaining({
          source: 'source_node',
          target: 'end_node_1',
          data: expect.objectContaining({
            isAutoGenerated: true,
            type: 'END_CONNECTION',
            sourceLineId: 'line_1'
          })
        })
      );
      expect(mockPreviewLineManager.removePreviewLine).toHaveBeenCalledWith('line_1');
      expect(connection.id).toBe('edge_1');
    });

    it('应该处理连接失败的情况', async () => {
      const mockLine = {
        id: 'line_1',
        source: { cell: 'source_node' }
      };
      const mockEndNode = { id: 'end_node_1' };
      
      mockCanvas.addEdge.mockImplementation(() => {
        throw new Error('连接失败');
      });
      
      await expect(endNodeGenerator.connectLineToEndNode(mockLine, mockEndNode))
        .rejects.toThrow('连接失败');
      
      expect(mockErrorHandler.handleError).toHaveBeenCalled();
    });
  });

  describe('清理自动生成的节点', () => {
    it('应该清理所有自动生成的节点和连接', async () => {
      // 先添加一些自动生成的节点
      const mockUnconnectedLine = {
        id: 'line_1',
        target: null,
        getTargetPoint: () => ({ x: 100, y: 100 }),
        getDirection: () => 'horizontal',
        source: { cell: 'source_node' }
      };
      
      mockPreviewLineManager.getAllPreviewLines.mockReturnValue([mockUnconnectedLine]);
      await endNodeGenerator.autoAddEndNodes();
      
      // Mock 节点和边
      const mockNode = { id: 'end_node_1', getData: () => ({ isAutoGenerated: true }) };
      const mockEdge = { id: 'edge_1', getData: () => ({ isAutoGenerated: true }) };
      
      mockCanvas.getCellById.mockReturnValue(mockNode);
      mockCanvas.getConnectedEdges.mockReturnValue([mockEdge]);
      
      await endNodeGenerator.cleanupAutoGeneratedNodes();
      
      expect(mockCanvas.removeCell).toHaveBeenCalledWith(mockEdge);
      expect(mockCanvas.removeCell).toHaveBeenCalledWith(mockNode);
      expect(endNodeGenerator.getAutoGeneratedNodes()).toHaveLength(0);
      expect(mockEventBus.emit).toHaveBeenCalledWith('endnode:cleanup:completed', 
        expect.objectContaining({
          removedNodes: 1,
          removedConnections: 1
        })
      );
    });

    it('应该处理清理过程中的错误', async () => {
      // 先添加一些自动生成的节点
      const mockUnconnectedLine = {
        id: 'line_1',
        target: null,
        getTargetPoint: () => ({ x: 100, y: 100 }),
        getDirection: () => 'horizontal',
        source: { cell: 'source_node' }
      };
      
      mockPreviewLineManager.getAllPreviewLines.mockReturnValue([mockUnconnectedLine]);
      await endNodeGenerator.autoAddEndNodes();
      
      mockCanvas.getCellById.mockImplementation(() => {
        throw new Error('获取节点失败');
      });
      
      await endNodeGenerator.cleanupAutoGeneratedNodes();
      
      expect(mockErrorHandler.handleError).toHaveBeenCalled();
      expect(mockEventBus.emit).toHaveBeenCalledWith('endnode:cleanup:completed', 
        expect.objectContaining({
          errors: expect.arrayContaining([expect.stringContaining('获取节点失败')])
        })
      );
    });
  });

  describe('节点检查和配置', () => {
    it('应该正确识别自动生成的节点', async () => {
      const mockUnconnectedLine = {
        id: 'line_1',
        target: null,
        getTargetPoint: () => ({ x: 100, y: 100 }),
        getDirection: () => 'horizontal',
        source: { cell: 'source_node' }
      };
      
      mockPreviewLineManager.getAllPreviewLines.mockReturnValue([mockUnconnectedLine]);
      await endNodeGenerator.autoAddEndNodes();
      
      expect(endNodeGenerator.isAutoGeneratedNode('end_node_1')).toBe(true);
      expect(endNodeGenerator.isAutoGeneratedNode('other_node')).toBe(false);
    });

    it('应该允许更新结束节点配置', () => {
      const newConfig = {
        size: { width: 80, height: 80 },
        label: '终点'
      };
      
      endNodeGenerator.updateEndNodeConfig(newConfig);
      
      const updatedConfig = endNodeGenerator.getEndNodeConfig();
      expect(updatedConfig.size.width).toBe(80);
      expect(updatedConfig.label).toBe('终点');
      expect(mockEventBus.emit).toHaveBeenCalledWith('endnode:config:updated', {
        config: updatedConfig
      });
    });
  });
});