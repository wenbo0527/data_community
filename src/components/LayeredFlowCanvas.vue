<template>
  <div class="layered-flow-canvas" ref="canvasContainer">
    <!-- ÁΩëÊ†ºËÉåÊôØ -->
    <div class="canvas-grid"></div>
    
    <!-- ËäÇÁÇπÂ±Ç -->
    <div class="nodes-layer">
      <!-- ÂºÄÂßãËäÇÁÇπ -->
      <NodeWithPresetSlots
        v-if="startNode"
        :node-id="startNode.id"
        :node-type="startNode.type"
        :position="startNode.position"
        :config="startNode.config"
        :preset-slots="getNodePresetSlots(startNode.id)"
        :draggable="false"
        @preset-slot-click="handlePresetSlotClick"
        @add-node-to-slot="handleAddNodeToSlot"
        @node-click="handleNodeClick"
      >
        <template #node>
          <FlowNode
            :node-type="startNode.type"
            :label="startNode.label"
            :selected="selectedNodeId === startNode.id"
            :data="startNode.data"
            :deletable="false"
            @click="handleNodeClick(startNode)"
          />
        </template>
      </NodeWithPresetSlots>
      
      <!-- ÂÖ∂‰ªñËäÇÁÇπ -->
      <NodeWithPresetSlots
        v-for="node in flowNodes"
        :key="node.id"
        :node-id="node.id"
        :node-type="node.type"
        :position="node.position"
        :config="node.config"
        :preset-slots="getNodePresetSlots(node.id)"
        @update:position="handleNodePositionUpdate(node.id, $event)"
        @preset-slot-click="handlePresetSlotClick"
        @add-node-to-slot="handleAddNodeToSlot"
        @node-click="handleNodeClick"
      >
        <template #node>
          <FlowNode
            :node-type="node.type"
            :label="node.label"
            :selected="selectedNodeId === node.id"
            :data="node.data"
            @click="handleNodeClick(node)"
            @delete="handleNodeDelete(node)"
          />
        </template>
      </NodeWithPresetSlots>
    </div>
    
    <!-- ËøûÊé•Á∫øÂ±Ç -->
    <div class="connections-layer">
      <svg class="connections-svg" :width="canvasWidth" :height="canvasHeight">
        <g>
          <path
            v-for="connection in connections"
            :key="connection.id"
            :d="generatePath(connection)"
            :stroke="connection.color || '#5F95FF'"
            stroke-width="2"
            fill="none"
            marker-end="url(#arrowhead)"
          />
        </g>
        <defs>
          <marker
            id="arrowhead"
            markerWidth="10"
            markerHeight="7"
            refX="9"
            refY="3.5"
            orient="auto"
          >
            <polygon points="0 0, 10 3.5, 0 7" fill="#5F95FF" />
          </marker>
        </defs>
      </svg>
    </div>
    
    <!-- ËäÇÁÇπÁ±ªÂûãÈÄâÊã©Âô® -->
    <NodeTypeSelector
      v-if="showNodeSelector"
      :visible="showNodeSelector"
      :position="nodeSelectorPosition"
      :source-node="nodeSelectorSourceNode"
      :preset-slot="selectedPresetSlot"
      @select="handleNodeTypeSelected"
      @close="closeNodeSelector"
    />
    
    <!-- ËäÇÁÇπÈÖçÁΩÆÊäΩÂ±â -->
    <NodeConfigDrawer
      v-if="showConfigDrawer"
      :visible="showConfigDrawer"
      :node="selectedNode"
      @close="closeConfigDrawer"
      @update="handleNodeDataUpdate"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import NodeWithPresetSlots from './NodeWithPresetSlots.vue'
import FlowNode from './FlowNode.vue'
import NodeTypeSelector from './NodeTypeSelector.vue'
import NodeConfigDrawer from './NodeConfigDrawer.vue'
import { getNodeConfig, generateDynamicNextSlots } from '../utils/nodeTypes.js'
import { useEnhancedAutoLayout } from '../composables/useEnhancedAutoLayout.js'

// ÁªÑ‰ª∂Â±ûÊÄß
const props = defineProps({
  // ÂàùÂßãËäÇÁÇπÊï∞ÊçÆ
  initialNodes: {
    type: Array,
    default: () => []
  },
  // ÂàùÂßãËøûÊé•Êï∞ÊçÆ
  initialConnections: {
    type: Array,
    default: () => []
  },
  // ÊòØÂê¶Ëá™Âä®Ê∑ªÂä†ÂºÄÂßãËäÇÁÇπ
  autoAddStartNode: {
    type: Boolean,
    default: true
  }
})

// ‰∫ã‰ª∂
const emit = defineEmits([
  'canvas-ready',
  'node-created',
  'node-moved',
  'node-selected',
  'node-updated',
  'node-deleted',
  'connection-created',
  'preset-slot-created',
  'preset-slot-occupied'
])

// ÁîªÂ∏ÉÂÆπÂô®ÂºïÁî®
const canvasContainer = ref(null)

// ÂàõÂª∫‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂõæÂΩ¢ÂØπË±°ÔºåÁî®‰∫éautoLayoutÂàùÂßãÂåñ
let graph = null

// ÂàùÂßãÂåñÂ¢ûÂº∫Ëá™Âä®Â∏ÉÂ±ÄÁÆ°ÁêÜ
const autoLayout = useEnhancedAutoLayout(() => graph)

// ÁîªÂ∏ÉÂ∞∫ÂØ∏
const canvasWidth = ref(1000)
const canvasHeight = ref(800)

// ËäÇÁÇπÊï∞ÊçÆ
const nodes = ref([])
const startNode = ref(null)
const flowNodes = computed(() => nodes.value.filter(node => node.type !== 'start'))

// ËøûÊé•Êï∞ÊçÆ
const connections = ref([])

// È¢ÑËÆæ‰ΩçÊï∞ÊçÆ
const presetSlots = ref([])

// ÈÄâ‰∏≠Áä∂ÊÄÅ
const selectedNodeId = ref(null)
const selectedNode = computed(() => {
  return nodes.value.find(node => node.id === selectedNodeId.value) || null
})

// ËäÇÁÇπÈÄâÊã©Âô®Áä∂ÊÄÅ
const showNodeSelector = ref(false)
const nodeSelectorPosition = ref({ x: 0, y: 0 })
const nodeSelectorSourceNode = ref(null)
const selectedPresetSlot = ref(null)

// ÈÖçÁΩÆÊäΩÂ±âÁä∂ÊÄÅ
const showConfigDrawer = ref(false)

// ÂàùÂßãÂåñÁîªÂ∏É
const initCanvas = () => {
  // ÂàùÂßãÂåñÂõæÂΩ¢ÂØπË±°ÔºåÁî®‰∫éautoLayout
  graph = {
    // Êèê‰æõ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂõæÂΩ¢Êé•Âè£ÔºåÊª°Ë∂≥autoLayoutÁöÑÈúÄÊ±Ç
    addNode: (nodeData) => {
      nodes.value.push(nodeData)
      return nodeData
    },
    createEdge: (source, target, edgeData) => {
      const connection = {
        id: `${source}-${target}`,
        source,
        target,
        ...edgeData
      }
      connections.value.push(connection)
      return connection
    },
    getNodes: () => nodes.value,
    getEdges: () => connections.value
  }
  
  // ÂàùÂßãÂåñautoLayout
  autoLayout.initLayoutManager()

  // ËÆæÁΩÆÁîªÂ∏ÉÂ∞∫ÂØ∏
  if (canvasContainer.value) {
    canvasWidth.value = canvasContainer.value.clientWidth
    canvasHeight.value = canvasContainer.value.clientHeight
  }
  
  // Âä†ËΩΩÂàùÂßãËäÇÁÇπ
  if (props.initialNodes.length > 0) {
    nodes.value = [...props.initialNodes]
    // ÊâæÂà∞ÂºÄÂßãËäÇÁÇπ
    const start = nodes.value.find(node => node.type === 'start')
    if (start) {
      startNode.value = start
    }
  } else if (props.autoAddStartNode) {
    // Ëá™Âä®Ê∑ªÂä†ÂºÄÂßãËäÇÁÇπ
    addStartNode()
  }
  
  // Âä†ËΩΩÂàùÂßãËøûÊé•
  if (props.initialConnections.length > 0) {
    connections.value = [...props.initialConnections]
  }
  
  // ÂàùÂßãÂåñÈ¢ÑËÆæ‰Ωç
  initPresetSlots()
  
  // Ëß¶ÂèëÁîªÂ∏ÉÂ∞±Áª™‰∫ã‰ª∂
  emit('canvas-ready', {
    nodes: nodes.value,
    connections: connections.value,
    presetSlots: presetSlots.value
  })
}

// Ê∑ªÂä†ÂºÄÂßãËäÇÁÇπ
const addStartNode = () => {
  const nodeConfig = getNodeConfig('start')
  if (!nodeConfig) return
  
  const startNodeId = 'start-node'
  
  // Â∞ùËØï‰ΩøÁî®Ëá™Âä®Â∏ÉÂ±ÄÊ∑ªÂä†ÂºÄÂßãËäÇÁÇπ
  try {
    // ‰ΩøÁî®Â¢ûÂº∫Ëá™Âä®Â∏ÉÂ±ÄÊ∑ªÂä†ËäÇÁÇπ
    const result = autoLayout.addNodeWithEnhancedLayout('start', null, {
      forceLevel: 0
    })
    
    if (result && result.nodeData) {
      startNode.value = result.nodeData
      // ËäÇÁÇπÂ∑≤ÁªèÈÄöËøáautoLayoutÊ∑ªÂä†Âà∞nodes‰∏≠
      console.log('[LayeredFlowCanvas] ‰ΩøÁî®Ëá™Âä®Â∏ÉÂ±ÄÊ∑ªÂä†ÂºÄÂßãËäÇÁÇπÊàêÂäü')
      
      // ÂàùÂßãÂåñÂºÄÂßãËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç
      initNodePresetSlots(startNode.value)
      return
    }
  } catch (error) {
    console.error('[LayeredFlowCanvas] ‰ΩøÁî®Ëá™Âä®Â∏ÉÂ±ÄÊ∑ªÂä†ÂºÄÂßãËäÇÁÇπÂ§±Ë¥•ÔºåÈôçÁ∫ßÂ§ÑÁêÜ', error)
  }
  
  // ÈôçÁ∫ßÂ§ÑÁêÜÔºöÊâãÂä®Ê∑ªÂä†ÂºÄÂßãËäÇÁÇπ
  const position = { x: canvasWidth.value / 2 - 50, y: 100 }
  
  const newStartNode = {
    id: startNodeId,
    type: 'start',
    label: nodeConfig.label,
    position,
    data: {
      fixed: true
    },
    config: nodeConfig
  }
  
  startNode.value = newStartNode
  nodes.value.push(newStartNode)
  
  // ÂàùÂßãÂåñÂºÄÂßãËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç
  initNodePresetSlots(newStartNode)
}

// ÂàùÂßãÂåñÈ¢ÑËÆæ‰Ωç
const initPresetSlots = () => {
  nodes.value.forEach(node => {
    initNodePresetSlots(node)
  })
}

// ÂàùÂßãÂåñËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç
const initNodePresetSlots = (node) => {
  console.log('üîß ÂàùÂßãÂåñËäÇÁÇπÈ¢ÑËÆæ‰Ωç:', node.type, node.id)
  
  const nodeConfig = getNodeConfig(node.type)
  console.log('üìã ËäÇÁÇπÈÖçÁΩÆ:', nodeConfig)
  
  if (!nodeConfig || !nodeConfig.autoExpand) {
    console.log('‚ùå ËäÇÁÇπ‰∏çÊîØÊåÅËá™Âä®Êâ©Â±ïÊàñÈÖçÁΩÆ‰∏çÂ≠òÂú®')
    return
  }
  
  // ÂØπ‰∫éÂä®ÊÄÅËäÇÁÇπÔºà‰∫∫Áæ§ÂàÜÊµÅ„ÄÅ‰∫ã‰ª∂ÂàÜÊµÅ„ÄÅABÂÆûÈ™åÔºâÔºåÂü∫‰∫éÈÖçÁΩÆÂä®ÊÄÅÁîüÊàêÈ¢ÑËÆæ‰Ωç
  if (['audience-split', 'event-split', 'ab-test'].includes(node.type)) {
    console.log('üîÑ Âä®ÊÄÅËäÇÁÇπÔºåÁ≠âÂæÖÈÖçÁΩÆÂÆåÊàêÂêéÁîüÊàêÈ¢ÑËÆæ‰Ωç')
    // Ëøô‰∫õËäÇÁÇπÁöÑÈ¢ÑËÆæ‰ΩçÂ∫îËØ•Âü∫‰∫éÈÖçÁΩÆÈ°µÈù¢ÁöÑÁªìÊûúÂä®ÊÄÅÁîüÊàê
    // ÊöÇÊó∂‰∏çÂàõÂª∫È¢ÑËÆæ‰ΩçÔºåÁ≠âÂæÖÈÖçÁΩÆÂÆåÊàêÂêéÂÜçÁîüÊàê
    return
  }
  
  // ÂØπ‰∫éÂÖ∂‰ªñËäÇÁÇπÔºå‰ΩøÁî®ÈùôÊÄÅÈÖçÁΩÆÁöÑÈ¢ÑËÆæ‰Ωç
  if (!nodeConfig.nextSlots || nodeConfig.nextSlots.length === 0) {
    console.log('‚ùå ËäÇÁÇπÊ≤°ÊúânextSlotsÈÖçÁΩÆ')
    return
  }
  
  console.log('‚úÖ ÂºÄÂßãÂàõÂª∫È¢ÑËÆæ‰ΩçÔºånextSlotsÊï∞Èáè:', nodeConfig.nextSlots.length)
  
  nodeConfig.nextSlots.forEach((slotConfig, index) => {
    const slotId = `${node.id}_slot_${index}`
    const slot = {
      id: slotId,
      nodeId: node.id,
      type: slotConfig.type,
      label: slotConfig.label,
      position: {
        x: node.position.x + slotConfig.position.x,
        y: node.position.y + slotConfig.position.y
      },
      allowedTypes: slotConfig.allowedTypes || [],
      state: 'empty',
      config: slotConfig
    }
    
    console.log('üéØ ÂàõÂª∫È¢ÑËÆæ‰Ωç:', slotId, 'allowedTypes:', slot.allowedTypes)
    
    // Ê∑ªÂä†Âà∞È¢ÑËÆæ‰ΩçÂàóË°®
    const existingIndex = presetSlots.value.findIndex(s => s.id === slotId)
    if (existingIndex >= 0) {
      presetSlots.value[existingIndex] = slot
    } else {
      presetSlots.value.push(slot)
    }
    
    // Ëß¶ÂèëÈ¢ÑËÆæ‰ΩçÂàõÂª∫‰∫ã‰ª∂
    emit('preset-slot-created', slot)
  })
}

// Ëé∑ÂèñËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç
const getNodePresetSlots = (nodeId) => {
  return presetSlots.value.filter(slot => slot.nodeId === nodeId)
}

// Â§ÑÁêÜËäÇÁÇπ‰ΩçÁΩÆÊõ¥Êñ∞
const handleNodePositionUpdate = (nodeId, newPosition) => {
  // Êõ¥Êñ∞ËäÇÁÇπ‰ΩçÁΩÆ
  const nodeIndex = nodes.value.findIndex(node => node.id === nodeId)
  if (nodeIndex >= 0) {
    nodes.value[nodeIndex].position = newPosition
    
    // Êõ¥Êñ∞ËØ•ËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç‰ΩçÁΩÆ
    updateNodePresetSlots(nodeId, newPosition)
    
    // Ëß¶ÂèëËäÇÁÇπÁßªÂä®‰∫ã‰ª∂
    emit('node-moved', {
      nodeId,
      position: newPosition
    })
  }
}

// Êõ¥Êñ∞ËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç‰ΩçÁΩÆ
const updateNodePresetSlots = (nodeId, newPosition) => {
  const node = nodes.value.find(n => n.id === nodeId)
  if (!node) return
  
  // ÂØπ‰∫éÂä®ÊÄÅËäÇÁÇπÔºåÈúÄË¶ÅÈáçÊñ∞ÁîüÊàêÈ¢ÑËÆæ‰Ωç
  if (['audience-split', 'event-split', 'ab-test'].includes(node.type)) {
    // Ëé∑ÂèñÂΩìÂâçËäÇÁÇπÁöÑÈÖçÁΩÆÊï∞ÊçÆ
    const nodeData = node.data || {}
    
    // Êõ¥Êñ∞ËäÇÁÇπ‰ΩçÁΩÆ
    node.position = newPosition
    
    // ÈáçÊñ∞ÁîüÊàêÈ¢ÑËÆæ‰Ωç
    if (node.type === 'audience-split' && nodeData.splitCount) {
      generateDynamicPresetSlots(node, { splitCount: nodeData.splitCount })
    } else if (node.type === 'event-split' && nodeData.events) {
      generateDynamicPresetSlots(node, { events: nodeData.events })
    } else if (node.type === 'ab-test' && nodeData.variants) {
      generateDynamicPresetSlots(node, { variants: nodeData.variants })
    }
    return
  }
  
  // ÂØπ‰∫éÈùôÊÄÅËäÇÁÇπÔºåÊõ¥Êñ∞È¢ÑËÆæ‰Ωç‰ΩçÁΩÆ
  const nodeConfig = getNodeConfig(node.type)
  if (!nodeConfig || !nodeConfig.nextSlots) return
  
  // Êõ¥Êñ∞È¢ÑËÆæ‰Ωç‰ΩçÁΩÆ
  nodeConfig.nextSlots.forEach((slotConfig, index) => {
    const slotId = `${nodeId}_slot_${index}`
    const slotIndex = presetSlots.value.findIndex(slot => slot.id === slotId)
    
    if (slotIndex >= 0) {
      presetSlots.value[slotIndex].position = {
        x: newPosition.x + slotConfig.position.x,
        y: newPosition.y + slotConfig.position.y
      }
    }
  })
}

// Â§ÑÁêÜÈ¢ÑËÆæ‰ΩçÁÇπÂáª
const handlePresetSlotClick = (slot) => {
  if (slot.state !== 'empty') return
  
  selectedPresetSlot.value = slot
  
  // ÊòæÁ§∫ËäÇÁÇπÁ±ªÂûãÈÄâÊã©Âô®
  showNodeSelector.value = true
  nodeSelectorPosition.value = {
    x: slot.position.x,
    y: slot.position.y
  }
  
  // ËÆæÁΩÆÊ∫êËäÇÁÇπ
  const sourceNode = nodes.value.find(node => node.id === slot.nodeId)
  nodeSelectorSourceNode.value = sourceNode
}

// Â§ÑÁêÜÂú®È¢ÑËÆæ‰ΩçÊ∑ªÂä†ËäÇÁÇπ
const handleAddNodeToSlot = (slot) => {
  handlePresetSlotClick(slot)
}

// Â§ÑÁêÜËäÇÁÇπÁ±ªÂûãÈÄâÊã©
const handleNodeTypeSelected = (nodeType) => {
  if (!selectedPresetSlot.value) return
  
  // Ê∑ªÂä†ËäÇÁÇπÂà∞È¢ÑËÆæ‰Ωç
  addNodeToPresetSlot(selectedPresetSlot.value, nodeType)
  
  // ÂÖ≥Èó≠ËäÇÁÇπÈÄâÊã©Âô®
  closeNodeSelector()
}

// Ê∑ªÂä†ËäÇÁÇπÂà∞È¢ÑËÆæ‰Ωç
const addNodeToPresetSlot = (slot, nodeType) => {
  const nodeConfig = getNodeConfig(nodeType)
  if (!nodeConfig) return
  
  // Ê£ÄÊü•ËäÇÁÇπÁ±ªÂûãÊòØÂê¶ÂÖÅËÆ∏
  if (slot.allowedTypes.length > 0 && !slot.allowedTypes.includes(nodeType)) {
    console.warn(`ËäÇÁÇπÁ±ªÂûã ${nodeType} ‰∏çÂÖÅËÆ∏Ê∑ªÂä†Âà∞Ê≠§È¢ÑËÆæ‰Ωç`)
    return
  }
  
  // Ëé∑ÂèñÊ∫êËäÇÁÇπ
  const sourceNode = nodes.value.find(node => node.id === slot.nodeId)
  if (!sourceNode) {
    console.error('Êâæ‰∏çÂà∞Ê∫êËäÇÁÇπ', slot.nodeId)
    return
  }
  
  // Â∞ùËØï‰ΩøÁî®Ëá™Âä®Â∏ÉÂ±ÄÊ∑ªÂä†ËäÇÁÇπ
  try {
    // ‰ΩøÁî®Â¢ûÂº∫Ëá™Âä®Â∏ÉÂ±ÄÊ∑ªÂä†ËäÇÁÇπ
    const result = autoLayout.addNodeWithEnhancedLayout(nodeType, sourceNode, {
      connectionLabel: slot.label,
      slotIndex: slot.index
    })
    
    if (result && result.nodeData) {
      const newNode = result.nodeData
      console.log('[LayeredFlowCanvas] ‰ΩøÁî®Ëá™Âä®Â∏ÉÂ±ÄÊ∑ªÂä†ËäÇÁÇπÊàêÂäü', newNode.id)
      
      // Âà†Èô§È¢ÑËÆæ‰ΩçÔºàÈ¢ÑËÆæ‰ΩçÂú®ÁªëÂÆöËäÇÁÇπÂêéÂ∫î‰ªéÁîªÂ∏É‰∏äÂà†Èô§Ôºâ
      removePresetSlot(slot.id)
      
      // ÂàùÂßãÂåñÊñ∞ËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç
      initNodePresetSlots(newNode)
      
      // Ëß¶ÂèëËäÇÁÇπÂàõÂª∫‰∫ã‰ª∂
      emit('node-created', { node: newNode, sourceNode, connection: result.connection })
      
      return newNode
    }
  } catch (error) {
    console.error('[LayeredFlowCanvas] ‰ΩøÁî®Ëá™Âä®Â∏ÉÂ±ÄÊ∑ªÂä†ËäÇÁÇπÂ§±Ë¥•ÔºåÈôçÁ∫ßÂ§ÑÁêÜ', error)
  }
  
  // ÈôçÁ∫ßÂ§ÑÁêÜÔºöÊâãÂä®Ê∑ªÂä†ËäÇÁÇπ
  const newNodeId = `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  // Â∞Ü‰ΩçÁΩÆÂØπÈΩêÂà∞ÁΩëÊ†º
  const position = snapToGrid(slot.position)
  
  const newNode = {
    id: newNodeId,
    type: nodeType,
    label: nodeConfig.label,
    position,
    data: {},
    config: nodeConfig
  }
  
  // Ê∑ªÂä†ËäÇÁÇπ
  nodes.value.push(newNode)
  
  // ÂàõÂª∫ËøûÊé•
  const connection = createConnection(slot.nodeId, newNodeId, slot.label)
  
  // Âà†Èô§È¢ÑËÆæ‰ΩçÔºàÈ¢ÑËÆæ‰ΩçÂú®ÁªëÂÆöËäÇÁÇπÂêéÂ∫î‰ªéÁîªÂ∏É‰∏äÂà†Èô§Ôºâ
  removePresetSlot(slot.id)
  
  // ÂàùÂßãÂåñÊñ∞ËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç
  initNodePresetSlots(newNode)
  
  // Ëß¶ÂèëËäÇÁÇπÂàõÂª∫‰∫ã‰ª∂
  emit('node-created', { node: newNode, sourceNode, connection })
  
  return newNode
}

// Âà†Èô§È¢ÑËÆæ‰Ωç
const removePresetSlot = (slotId) => {
  const slotIndex = presetSlots.value.findIndex(slot => slot.id === slotId)
  if (slotIndex >= 0) {
    presetSlots.value.splice(slotIndex, 1)
  }
}

// ÂàõÂª∫ËøûÊé•
const createConnection = (sourceId, targetId, label = '') => {
  const connectionId = `connection_${sourceId}_${targetId}`
  
  const newConnection = {
    id: connectionId,
    sourceId,
    targetId,
    label
  }
  
  connections.value.push(newConnection)
  
  // Ëß¶ÂèëËøûÊé•ÂàõÂª∫‰∫ã‰ª∂
  emit('connection-created', newConnection)
  
  return newConnection
}

// ÁîüÊàêËøûÊé•Ë∑ØÂæÑ
const generatePath = (connection) => {
  const sourceNode = nodes.value.find(node => node.id === connection.sourceId)
  const targetNode = nodes.value.find(node => node.id === connection.targetId)
  
  if (!sourceNode || !targetNode) return ''
  
  const sourceX = sourceNode.position.x + 50 // ËäÇÁÇπ‰∏≠ÂøÉ
  const sourceY = sourceNode.position.y + 100 // ËäÇÁÇπÂ∫ïÈÉ®
  const targetX = targetNode.position.x + 50 // ËäÇÁÇπ‰∏≠ÂøÉ
  const targetY = targetNode.position.y // ËäÇÁÇπÈ°∂ÈÉ®
  
  // ‰ΩøÁî®Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø
  const controlPointY = (sourceY + targetY) / 2
  return `M ${sourceX} ${sourceY} C ${sourceX} ${controlPointY}, ${targetX} ${controlPointY}, ${targetX} ${targetY}`
}

// Â§ÑÁêÜËäÇÁÇπÁÇπÂáª - Áõ¥Êé•Â±ïÁ§∫ÈÖçÁΩÆÊäΩÂ±â
const handleNodeClick = (node) => {
  selectedNodeId.value = node.id
  showConfigDrawer.value = true
  
  // Ëß¶ÂèëËäÇÁÇπÈÄâÊã©‰∫ã‰ª∂
  emit('node-selected', node)
}

// Â§ÑÁêÜËäÇÁÇπÂà†Èô§
const handleNodeDelete = (node) => {
  // ÈÄíÂΩíÂà†Èô§ËäÇÁÇπÂèäÂÖ∂ÂêéÁª≠ËäÇÁÇπ
  deleteNodeAndDescendants(node.id)
}

// ÈÄíÂΩíÂà†Èô§ËäÇÁÇπÂèäÂÖ∂ÂêéÁª≠ËäÇÁÇπ
const deleteNodeAndDescendants = (nodeId) => {
  // ÊâæÂà∞ÊâÄÊúâ‰ªéËØ•ËäÇÁÇπÂá∫ÂèëÁöÑËøûÊé•
  const outgoingConnections = connections.value.filter(conn => conn.sourceId === nodeId)
  
  // ÊâæÂà∞ÊåáÂêëË¢´Âà†Èô§ËäÇÁÇπÁöÑËøûÊé•ÔºåÁî®‰∫éÂêéÁª≠ÈáçÊñ∞ÂàõÂª∫È¢ÑËÆæ‰Ωç
  const incomingConnections = connections.value.filter(conn => conn.targetId === nodeId)
  
  // ÈÄíÂΩíÂà†Èô§ÊâÄÊúâÂêéÁª≠ËäÇÁÇπ
  outgoingConnections.forEach(connection => {
    deleteNodeAndDescendants(connection.targetId)
  })
  
  // ËÆ∞ÂΩïÈúÄË¶ÅÈáçÊñ∞ÂàõÂª∫È¢ÑËÆæ‰ΩçÁöÑ‰ø°ÊÅØ
  const slotsToRecreate = []
  incomingConnections.forEach(connection => {
    const sourceNode = nodes.value.find(node => node.id === connection.sourceId)
    const deletedNode = nodes.value.find(node => node.id === nodeId)
    
    if (sourceNode && deletedNode) {
      // ËÆ°ÁÆóË¢´Âà†Èô§ËäÇÁÇπÁõ∏ÂØπ‰∫éÊ∫êËäÇÁÇπÁöÑ‰ΩçÁΩÆÔºåÁî®‰∫éÈáçÊñ∞ÂàõÂª∫È¢ÑËÆæ‰Ωç
      const relativePosition = {
        x: deletedNode.position.x - sourceNode.position.x,
        y: deletedNode.position.y - sourceNode.position.y
      }
      
      slotsToRecreate.push({
        sourceNode,
        targetPosition: deletedNode.position,
        relativePosition,
        connectionLabel: connection.label
      })
    }
  })
  
  // Âà†Èô§‰∏éËØ•ËäÇÁÇπÁõ∏ÂÖ≥ÁöÑÊâÄÊúâËøûÊé•
  connections.value = connections.value.filter(conn => 
    conn.sourceId !== nodeId && conn.targetId !== nodeId
  )
  
  // Âà†Èô§ËØ•ËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç
  presetSlots.value = presetSlots.value.filter(slot => slot.nodeId !== nodeId)
  
  // Âà†Èô§ËäÇÁÇπÊú¨Ë∫´
  const nodeIndex = nodes.value.findIndex(node => node.id === nodeId)
  if (nodeIndex >= 0) {
    const deletedNode = nodes.value[nodeIndex]
    nodes.value.splice(nodeIndex, 1)
    
    // Ëß¶ÂèëËäÇÁÇπÂà†Èô§‰∫ã‰ª∂
    emit('node-deleted', deletedNode)
  }
  
  // ÈáçÊñ∞ÂàõÂª∫ÂØπÂ∫îÁöÑÈ¢ÑËÆæ‰Ωç
  slotsToRecreate.forEach(({ sourceNode, targetPosition, relativePosition, connectionLabel }) => {
    recreateSpecificPresetSlot(sourceNode, targetPosition, relativePosition, connectionLabel)
  })
  
  // Â¶ÇÊûúÂà†Èô§ÁöÑÊòØÂΩìÂâçÈÄâ‰∏≠ÁöÑËäÇÁÇπÔºåÊ∏ÖÈô§ÈÄâ‰∏≠Áä∂ÊÄÅ
  if (selectedNodeId.value === nodeId) {
    selectedNodeId.value = null
    showConfigDrawer.value = false
  }
}

// ÈáçÊñ∞ÂàõÂª∫ÁâπÂÆöÁöÑÈ¢ÑËÆæ‰Ωç
const recreateSpecificPresetSlot = (sourceNode, targetPosition, relativePosition, connectionLabel) => {
  // ÁîüÊàêÊñ∞ÁöÑÈ¢ÑËÆæ‰ΩçID
  const timestamp = Date.now()
  const slotId = `${sourceNode.id}_recreated_slot_${timestamp}`
  
  // ÂàõÂª∫Êñ∞ÁöÑÈ¢ÑËÆæ‰Ωç
  const newSlot = {
    id: slotId,
    nodeId: sourceNode.id,
    type: 'branch',
    label: connectionLabel || 'ÂàÜÊîØ',
    position: {
      x: targetPosition.x,
      y: targetPosition.y
    },
    allowedTypes: ['sms', 'ai-call', 'manual-call', 'wait', 'end'],
    state: 'empty',
    config: {
      position: relativePosition,
      type: 'branch'
    }
  }
  
  // Ê∑ªÂä†Âà∞È¢ÑËÆæ‰ΩçÂàóË°®
  presetSlots.value.push(newSlot)
  
  // Ëß¶ÂèëÈ¢ÑËÆæ‰ΩçÂàõÂª∫‰∫ã‰ª∂
  emit('preset-slot-created', newSlot)
}

// Â§ÑÁêÜËäÇÁÇπÊï∞ÊçÆÊõ¥Êñ∞
const handleNodeDataUpdate = (nodeId, newData) => {
  const nodeIndex = nodes.value.findIndex(node => node.id === nodeId)
  if (nodeIndex >= 0) {
    nodes.value[nodeIndex].data = { ...nodes.value[nodeIndex].data, ...newData }
    
    const node = nodes.value[nodeIndex]
    
    // Ê†πÊçÆËäÇÁÇπÁ±ªÂûãÂä®ÊÄÅÁîüÊàêÈ¢ÑËÆæ‰Ωç
    if (node.type === 'audience-split' && newData.splitCount) {
      generateDynamicPresetSlots(node, { splitCount: newData.splitCount })
    } else if (node.type === 'event-split' && newData.events) {
      generateDynamicPresetSlots(node, { events: newData.events })
    } else if (node.type === 'ab-test' && newData.variants) {
      generateDynamicPresetSlots(node, { variants: newData.variants })
    }
    
    // Ëß¶ÂèëËäÇÁÇπÊõ¥Êñ∞‰∫ã‰ª∂
    emit('node-updated', {
      nodeId,
      data: nodes.value[nodeIndex].data
    })
  }
  
  // ÂÖ≥Èó≠ÈÖçÁΩÆÊäΩÂ±â
  closeConfigDrawer()
}

// Âä®ÊÄÅÁîüÊàêÈ¢ÑËÆæ‰ΩçÔºàÁî®‰∫é‰∫∫Áæ§ÂàÜÊµÅ„ÄÅ‰∫ã‰ª∂ÂàÜÊµÅ„ÄÅABÂÆûÈ™åËäÇÁÇπÔºâ
const generateDynamicPresetSlots = (node, config = {}) => {
  // ÂÖàÁßªÈô§ËØ•ËäÇÁÇπÁé∞ÊúâÁöÑÈ¢ÑËÆæ‰Ωç
  presetSlots.value = presetSlots.value.filter(slot => slot.nodeId !== node.id)
  
  const dynamicSlots = generateDynamicNextSlots(node.type, config)
  
  dynamicSlots.forEach((slotConfig, index) => {
    const slotId = `${node.id}_slot_${index}`
    const slot = {
      id: slotId,
      nodeId: node.id,
      type: slotConfig.type,
      label: slotConfig.label,
      position: {
        x: node.position.x + slotConfig.position.x,
        y: node.position.y + slotConfig.position.y
      },
      allowedTypes: slotConfig.allowedTypes || [],
      state: 'empty',
      config: slotConfig
    }
    
    presetSlots.value.push(slot)
    
    // Ëß¶ÂèëÈ¢ÑËÆæ‰ΩçÂàõÂª∫‰∫ã‰ª∂
    emit('preset-slot-created', slot)
  })
}

// Êõ¥Êñ∞‰∫∫Áæ§ÂàÜÊµÅËäÇÁÇπÁöÑÈ¢ÑËÆæ‰Ωç
const updateAudienceSplitPresetSlots = (node, splitCount) => {
  generateDynamicPresetSlots(node, { splitCount })
}

// ÂÖ≥Èó≠ËäÇÁÇπÈÄâÊã©Âô®
const closeNodeSelector = () => {
  showNodeSelector.value = false
  selectedPresetSlot.value = null
  nodeSelectorSourceNode.value = null
}

// ÂÖ≥Èó≠ÈÖçÁΩÆÊäΩÂ±â
const closeConfigDrawer = () => {
  showConfigDrawer.value = false
}

// ÂØπÈΩêÂà∞ÁΩëÊ†º
const snapToGrid = (position) => {
  const gridSize = 20 // Â∞èÁΩëÊ†ºÂ§ßÂ∞è
  return {
    x: Math.round(position.x / gridSize) * gridSize,
    y: Math.round(position.y / gridSize) * gridSize
  }
}

// Á™óÂè£Â§ßÂ∞èÂèòÂåñÂ§ÑÁêÜ
const handleResize = () => {
  if (canvasContainer.value) {
    canvasWidth.value = canvasContainer.value.clientWidth
    canvasHeight.value = canvasContainer.value.clientHeight
  }
}

// Ê∏ÖÁ©∫ÁîªÂ∏É
const clearCanvas = () => {
  // Ê∏ÖÁ©∫ËäÇÁÇπÂíåËøûÊé•
  nodes.value = []
  connections.value = []
  presetSlots.value = []
  startNode.value = null
  selectedNodeId.value = null
  showConfigDrawer.value = false
  
  // Ê∏ÖÁêÜËá™Âä®Â∏ÉÂ±ÄÊï∞ÊçÆ
  autoLayout.clearEnhancedLayout()
  
  // ÈáçÊñ∞ÂàùÂßãÂåñÂõæÂΩ¢ÂØπË±°ÂíåËá™Âä®Â∏ÉÂ±Ä
  graph = {
    addNode: (nodeData) => {
      nodes.value.push(nodeData)
      return nodeData
    },
    createEdge: (source, target, edgeData) => {
      const connection = {
        id: `${source}-${target}`,
        source,
        target,
        ...edgeData
      }
      connections.value.push(connection)
      return connection
    },
    getNodes: () => nodes.value,
    getEdges: () => connections.value
  }
  
  // ÈáçÊñ∞ÂàùÂßãÂåñËá™Âä®Â∏ÉÂ±Ä
  autoLayout.initLayoutManager()
  
  // Â¶ÇÊûúÈúÄË¶ÅËá™Âä®Ê∑ªÂä†ÂºÄÂßãËäÇÁÇπ
  if (props.autoAddStartNode) {
    addStartNode()
  }
  
  // Ëß¶ÂèëÁîªÂ∏ÉÊ∏ÖÁ©∫‰∫ã‰ª∂
  emit('canvas-cleared')
}

// Ëé∑ÂèñÁîªÂ∏ÉÊï∞ÊçÆ
const getCanvasData = () => {
  return {
    nodes: nodes.value,
    connections: connections.value,
    presetSlots: presetSlots.value
  }
}

// ÁªÑ‰ª∂ÊåÇËΩΩÊó∂
onMounted(() => {
  // ÂàùÂßãÂåñÁîªÂ∏É
  initCanvas()
  
  // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñ
  window.addEventListener('resize', handleResize)
})

// ÁªÑ‰ª∂Âç∏ËΩΩÊó∂
onUnmounted(() => {
  // ÁßªÈô§Á™óÂè£Â§ßÂ∞èÂèòÂåñÁõëÂê¨
  window.removeEventListener('resize', handleResize)
})

// Êö¥Èú≤ÊñπÊ≥ï
defineExpose({
  // ÁîªÂ∏ÉÊìç‰Ωú
  clearCanvas,
  getCanvasData,
  
  // ËäÇÁÇπÊìç‰Ωú
  addNodeToPresetSlot,
  
  // È¢ÑËÆæ‰ΩçÊìç‰Ωú
  getNodePresetSlots,
  generateDynamicPresetSlots,
  
  // Áä∂ÊÄÅ
  nodes,
  connections,
  presetSlots,
  
  // Ëá™Âä®Â∏ÉÂ±Ä
  autoLayout
})
</script>

<style scoped>
.layered-flow-canvas {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-color: #f8f9fa;
}

.canvas-grid {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-size: 20px 20px, 80px 80px;
  background-image: 
    linear-gradient(to right, rgba(200, 200, 200, 0.1) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(200, 200, 200, 0.1) 1px, transparent 1px),
    linear-gradient(to right, rgba(200, 200, 200, 0.2) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(200, 200, 200, 0.2) 1px, transparent 1px);
  background-position: -0.5px -0.5px;
}

.nodes-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.nodes-layer > * {
  pointer-events: auto;
}

.connections-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.connections-svg {
  position: absolute;
  top: 0;
  left: 0;
}
</style>