import type { Graph } from '@antv/x6';
import { UnifiedEventBus } from '@/core/UnifiedEventBus';
import { UnifiedCacheManager } from '@/core/UnifiedCacheManager';
import { ErrorHandler } from '@/core/ErrorHandler';

/**
 * 结束节点自动生成器
 * 负责检测未连接的预览线并自动添加结束节点
 */
export class EndNodeAutoGenerator {
  private canvas: Graph;
  private previewLineManager: any;
  private eventBus: UnifiedEventBus;
  private cacheManager: UnifiedCacheManager;
  private errorHandler: ErrorHandler;
  
  // 结束节点配置
  private endNodeConfig = {
    type: 'END_NODE',
    shape: 'circle',
    size: { width: 60, height: 60 },
    style: {
      fill: '#ff6b6b',
      stroke: '#ff5252',
      strokeWidth: 2
    },
    label: '结束'
  };
  
  // 自动生成的节点记录
  private autoGeneratedNodes: Map<string, {
    nodeId: string;
    sourceLineId: string;
    timestamp: number;
  }>;

  constructor(
    canvas: Graph,
    previewLineManager: any,
    eventBus: UnifiedEventBus,
    cacheManager: UnifiedCacheManager,
    errorHandler: ErrorHandler
  ) {
    this.canvas = canvas;
    this.previewLineManager = previewLineManager;
    this.eventBus = eventBus;
    this.cacheManager = cacheManager;
    this.errorHandler = errorHandler;
    
    this.autoGeneratedNodes = new Map();
  }

  /**
   * 检测未连接的预览线
   */
  detectUnconnectedPreviewLines(): any[] {
    try {
      const previewLines = this.previewLineManager.getAllPreviewLines();
      const unconnectedLines: any[] = [];
      
      previewLines.forEach((line: any) => {
        // 检查预览线的目标端是否连接到节点
        if (!line.target || !line.target.cell) {
          unconnectedLines.push(line);
        }
      });
      
      return unconnectedLines;
      
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: 'EndNodeAutoGenerator.detectUnconnectedPreviewLines',
        severity: 'medium'
      });
      return [];
    }
  }

  /**
   * 自动添加结束节点
   */
  async autoAddEndNodes(): Promise<Array<{
    line: any;
    endNode: any;
    connection: any;
  }>> {
    const addedEndNodes: Array<{
      line: any;
      endNode: any;
      connection: any;
    }> = [];
    
    try {
      const unconnectedLines = this.detectUnconnectedPreviewLines();
      
      this.eventBus.emit('endnode:generation:started', {
        unconnectedCount: unconnectedLines.length
      });
      
      for (const line of unconnectedLines) {
        try {
          const endNode = await this.createEndNodeForLine(line);
          const connection = await this.connectLineToEndNode(line, endNode);
          
          const result = {
            line: line,
            endNode: endNode,
            connection: connection
          };
          
          addedEndNodes.push(result);
          
          // 记录自动生成的节点
          this.autoGeneratedNodes.set(endNode.id, {
            nodeId: endNode.id,
            sourceLineId: line.id,
            timestamp: Date.now()
          });
          
          this.eventBus.emit('endnode:created', {
            lineId: line.id,
            nodeId: endNode.id
          });
          
        } catch (error) {
          const errorMessage = `为预览线 ${line.id} 添加结束节点失败: ${error instanceof Error ? error.message : String(error)}`;
          
          this.errorHandler.handleError(error, {
            context: 'EndNodeAutoGenerator.autoAddEndNodes',
            severity: 'medium',
            lineId: line.id
          });
          
          this.eventBus.emit('endnode:creation:failed', {
            lineId: line.id,
            error: errorMessage
          });
        }
      }
      
      this.eventBus.emit('endnode:generation:completed', {
        addedCount: addedEndNodes.length,
        totalUnconnected: unconnectedLines.length
      });
      
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: 'EndNodeAutoGenerator.autoAddEndNodes',
        severity: 'high'
      });
    }
    
    return addedEndNodes;
  }

  /**
   * 为特定预览线创建结束节点
   */
  async createEndNodeForLine(line: any): Promise<any> {
    try {
      // 计算结束节点位置（在预览线末端延伸100px）
      const endPosition = this.calculateEndNodePosition(line);
      
      const endNodeData = {
        ...this.endNodeConfig,
        id: `end_${line.id}_${Date.now()}`,
        position: endPosition,
        data: {
          isAutoGenerated: true,
          sourceLineId: line.id,
          nodeType: 'END_NODE',
          createdAt: new Date().toISOString()
        }
      };
      
      // 通过画布添加节点
      const endNode = this.canvas.addNode(endNodeData);
      
      // 更新预览线管理器
      if (this.previewLineManager.registerEndNode) {
        this.previewLineManager.registerEndNode(line.id, endNode.id);
      }
      
      return endNode;
      
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: 'EndNodeAutoGenerator.createEndNodeForLine',
        severity: 'medium',
        lineId: line.id
      });
      throw error;
    }
  }

  /**
   * 计算结束节点位置
   */
  private calculateEndNodePosition(line: any): { x: number; y: number } {
    try {
      const lineEndPoint = line.getTargetPoint ? line.getTargetPoint() : line.target?.point;
      const lineDirection = line.getDirection ? line.getDirection() : 'horizontal';
      
      if (!lineEndPoint) {
        // 如果无法获取预览线端点，使用默认位置
        return { x: 200, y: 200 };
      }
      
      // 根据预览线方向计算结束节点位置
      const offset = 100;
      let endPosition: { x: number; y: number };
      
      switch (lineDirection) {
        case 'horizontal':
          endPosition = {
            x: lineEndPoint.x + offset,
            y: lineEndPoint.y
          };
          break;
        case 'vertical':
          endPosition = {
            x: lineEndPoint.x,
            y: lineEndPoint.y + offset
          };
          break;
        default:
          // 默认水平延伸
          endPosition = {
            x: lineEndPoint.x + offset,
            y: lineEndPoint.y
          };
      }
      
      return endPosition;
      
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: 'EndNodeAutoGenerator.calculateEndNodePosition',
        severity: 'low'
      });
      
      // 返回默认位置
      return { x: 200, y: 200 };
    }
  }

  /**
   * 连接预览线到结束节点
   */
  async connectLineToEndNode(line: any, endNode: any): Promise<any> {
    try {
      const connection = this.canvas.addEdge({
        source: line.source?.cell || line.source,
        target: endNode.id,
        attrs: {
          line: {
            stroke: '#666',
            strokeWidth: 2,
            strokeDasharray: '5,5'
          }
        },
        data: {
          isAutoGenerated: true,
          type: 'END_CONNECTION',
          sourceLineId: line.id,
          createdAt: new Date().toISOString()
        }
      });
      
      // 移除原预览线
      if (this.previewLineManager.removePreviewLine) {
        this.previewLineManager.removePreviewLine(line.id);
      }
      
      return connection;
      
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: 'EndNodeAutoGenerator.connectLineToEndNode',
        severity: 'medium',
        lineId: line.id,
        endNodeId: endNode.id
      });
      throw error;
    }
  }

  /**
   * 清理自动生成的结束节点
   */
  async cleanupAutoGeneratedNodes(): Promise<void> {
    try {
      const cleanupResults = {
        removedNodes: 0,
        removedConnections: 0,
        errors: [] as string[]
      };
      
      for (const [nodeId, nodeInfo] of this.autoGeneratedNodes) {
        try {
          // 获取节点
          const node = this.canvas.getCellById(nodeId);
          if (node) {
            // 移除相关连接
            const edges = this.canvas.getConnectedEdges(node);
            edges.forEach((edge: any) => {
              if (edge.getData()?.isAutoGenerated) {
                this.canvas.removeCell(edge);
                cleanupResults.removedConnections++;
              }
            });
            
            // 移除节点
            this.canvas.removeCell(node);
            cleanupResults.removedNodes++;
          }
          
          // 从记录中移除
          this.autoGeneratedNodes.delete(nodeId);
          
        } catch (error) {
          const errorMessage = `清理节点 ${nodeId} 失败: ${error instanceof Error ? error.message : String(error)}`;
          cleanupResults.errors.push(errorMessage);
          
          this.errorHandler.handleError(error, {
            context: 'EndNodeAutoGenerator.cleanupAutoGeneratedNodes',
            severity: 'low',
            nodeId
          });
        }
      }
      
      this.eventBus.emit('endnode:cleanup:completed', cleanupResults);
      
    } catch (error) {
      this.errorHandler.handleError(error, {
        context: 'EndNodeAutoGenerator.cleanupAutoGeneratedNodes',
        severity: 'medium'
      });
    }
  }

  /**
   * 获取自动生成的节点列表
   */
  getAutoGeneratedNodes(): Array<{
    nodeId: string;
    sourceLineId: string;
    timestamp: number;
  }> {
    return Array.from(this.autoGeneratedNodes.values());
  }

  /**
   * 检查节点是否为自动生成
   */
  isAutoGeneratedNode(nodeId: string): boolean {
    return this.autoGeneratedNodes.has(nodeId);
  }

  /**
   * 获取结束节点配置
   */
  getEndNodeConfig(): any {
    return { ...this.endNodeConfig };
  }

  /**
   * 更新结束节点配置
   */
  updateEndNodeConfig(config: Partial<typeof this.endNodeConfig>): void {
    this.endNodeConfig = { ...this.endNodeConfig, ...config };
    
    this.eventBus.emit('endnode:config:updated', {
      config: this.endNodeConfig
    });
  }
}