<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‡ªåº•å‘ä¸Šå¸ƒå±€ä¼˜åŒ–å™¨æµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .test-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .test-header h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .test-header p {
            color: #666;
            font-size: 14px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #1e7e34;
        }
        
        .canvas-container {
            width: 100%;
            height: 600px;
            border: 2px solid #ddd;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .logs {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .log-info { color: #007bff; }
        .log-success { color: #28a745; }
        .log-warning { color: #ffc107; }
        .log-error { color: #dc3545; }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        
        .stat-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 18px;
            color: #007bff;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>ğŸš€ è‡ªåº•å‘ä¸Šå¸ƒå±€ä¼˜åŒ–å™¨æµ‹è¯•</h1>
            <p>æµ‹è¯•æ™ºèƒ½å¸ƒå±€ä¸­çš„è‡ªåº•å‘ä¸ŠèŠ‚ç‚¹åˆ†å¸ƒä¼˜åŒ–ç®—æ³•</p>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="createTestFlow()">åˆ›å»ºæµ‹è¯•æµç¨‹</button>
            <button class="btn btn-success" onclick="applyBottomUpLayout()">åº”ç”¨è‡ªåº•å‘ä¸Šå¸ƒå±€</button>
            <button class="btn btn-secondary" onclick="applyNormalLayout()">åº”ç”¨æ™®é€šå¸ƒå±€</button>
            <button class="btn btn-secondary" onclick="clearCanvas()">æ¸…ç©ºç”»å¸ƒ</button>
            <button class="btn btn-secondary" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
        </div>
        
        <div class="canvas-container" id="canvas-container">
            <!-- X6 ç”»å¸ƒå°†åœ¨è¿™é‡Œæ¸²æŸ“ -->
        </div>
        
        <div class="stats" id="stats">
            <!-- ç»Ÿè®¡ä¿¡æ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
        </div>
        
        <div class="logs" id="logs">
            <div class="log-entry log-info">ğŸ“‹ ç­‰å¾…åˆ›å»ºæµ‹è¯•æµç¨‹...</div>
        </div>
    </div>

    <script type="module">
        // ä½¿ç”¨æœ¬åœ°X6åº“
        const { Graph, Shape } = window.X6 || {}
        
        if (!Graph) {
            document.getElementById('logs').innerHTML = '<div class="log-entry log-error">âŒ X6åº“æœªåŠ è½½ï¼Œè¯·ç¡®ä¿åœ¨ä¸»åº”ç”¨ä¸­ä½¿ç”¨æ­¤æµ‹è¯•é¡µé¢</div>'
        }
        
        let graph = null
        let testNodes = []
        let testEdges = []
        
        // åˆå§‹åŒ–ç”»å¸ƒ
        function initGraph() {
            if (graph) {
                graph.dispose()
            }
            
            graph = new Graph({
                container: document.getElementById('canvas-container'),
                width: document.getElementById('canvas-container').offsetWidth,
                height: document.getElementById('canvas-container').offsetHeight,
                background: {
                    color: '#ffffff'
                },
                grid: {
                    visible: true,
                    type: 'dot',
                    args: {
                        color: '#f0f0f0',
                        thickness: 1
                    }
                },
                panning: {
                    enabled: true,
                    eventTypes: ['leftMouseDown', 'mouseWheel']
                },
                mousewheel: {
                    enabled: true,
                    modifiers: 'ctrl',
                    factor: 1.1,
                    maxScale: 3,
                    minScale: 0.3
                },
                selecting: {
                    enabled: true,
                    rubberband: true,
                    movable: true,
                    showNodeSelectionBox: true
                },
                connecting: {
                    router: 'orth',
                    connector: {
                        name: 'rounded',
                        args: {
                            radius: 8
                        }
                    },
                    anchor: 'center',
                    connectionPoint: 'anchor',
                    allowBlank: false,
                    snap: {
                        radius: 20
                    },
                    createEdge() {
                        return new Shape.Edge({
                            attrs: {
                                line: {
                                    stroke: '#A2B1C3',
                                    strokeWidth: 2,
                                    targetMarker: {
                                        name: 'block',
                                        width: 12,
                                        height: 8
                                    }
                                }
                            },
                            zIndex: 0
                        })
                    },
                    validateConnection({ targetMagnet }) {
                        return !!targetMagnet
                    }
                }
            })
            
            addLog('âœ… ç”»å¸ƒåˆå§‹åŒ–å®Œæˆ', 'success')
        }
        
        // åˆ›å»ºæµ‹è¯•æµç¨‹
        window.createTestFlow = function() {
            if (!graph) {
                initGraph()
            }
            
            graph.clearCells()
            testNodes = []
            testEdges = []
            
            addLog('ğŸ”§ å¼€å§‹åˆ›å»ºæµ‹è¯•æµç¨‹...', 'info')
            
            // åˆ›å»ºä¸€ä¸ªå¤æ‚çš„å¤šå±‚çº§æµç¨‹
            const nodeConfigs = [
                // ç¬¬ä¸€å±‚ï¼ˆé¡¶å±‚ï¼‰
                { id: 'start', x: 400, y: 50, label: 'å¼€å§‹', type: 'start', layer: 0 },
                
                // ç¬¬äºŒå±‚
                { id: 'condition1', x: 400, y: 150, label: 'æ¡ä»¶åˆ¤æ–­1', type: 'condition', layer: 1 },
                
                // ç¬¬ä¸‰å±‚ - åˆ†æ”¯è¾ƒå¤š
                { id: 'process1', x: 200, y: 250, label: 'å¤„ç†A', type: 'process', layer: 2 },
                { id: 'process2', x: 400, y: 250, label: 'å¤„ç†B', type: 'process', layer: 2 },
                { id: 'process3', x: 600, y: 250, label: 'å¤„ç†C', type: 'process', layer: 2 },
                
                // ç¬¬å››å±‚ - æ›´å¤šåˆ†æ”¯
                { id: 'sub1', x: 100, y: 350, label: 'å­æµç¨‹1', type: 'process', layer: 3 },
                { id: 'sub2', x: 250, y: 350, label: 'å­æµç¨‹2', type: 'process', layer: 3 },
                { id: 'sub3', x: 350, y: 350, label: 'å­æµç¨‹3', type: 'process', layer: 3 },
                { id: 'sub4', x: 450, y: 350, label: 'å­æµç¨‹4', type: 'process', layer: 3 },
                { id: 'sub5', x: 550, y: 350, label: 'å­æµç¨‹5', type: 'process', layer: 3 },
                { id: 'sub6', x: 700, y: 350, label: 'å­æµç¨‹6', type: 'process', layer: 3 },
                
                // ç¬¬äº”å±‚ï¼ˆåº•å±‚ï¼‰- æœ€å¤šåˆ†æ”¯
                { id: 'end1', x: 50, y: 450, label: 'ç»“æŸA', type: 'end', layer: 4 },
                { id: 'end2', x: 150, y: 450, label: 'ç»“æŸB', type: 'end', layer: 4 },
                { id: 'end3', x: 250, y: 450, label: 'ç»“æŸC', type: 'end', layer: 4 },
                { id: 'end4', x: 350, y: 450, label: 'ç»“æŸD', type: 'end', layer: 4 },
                { id: 'end5', x: 450, y: 450, label: 'ç»“æŸE', type: 'end', layer: 4 },
                { id: 'end6', x: 550, y: 450, label: 'ç»“æŸF', type: 'end', layer: 4 },
                { id: 'end7', x: 650, y: 450, label: 'ç»“æŸG', type: 'end', layer: 4 },
                { id: 'end8', x: 750, y: 450, label: 'ç»“æŸH', type: 'end', layer: 4 }
            ]
            
            // åˆ›å»ºèŠ‚ç‚¹
            nodeConfigs.forEach(config => {
                const node = graph.addNode({
                    id: config.id,
                    x: config.x - 50,
                    y: config.y - 15,
                    width: 100,
                    height: 30,
                    label: config.label,
                    attrs: {
                        body: {
                            stroke: getNodeColor(config.type),
                            fill: getNodeFillColor(config.type),
                            strokeWidth: 2,
                            rx: 6,
                            ry: 6
                        },
                        text: {
                            fontSize: 12,
                            fill: '#333'
                        }
                    },
                    ports: {
                        groups: {
                            top: {
                                position: 'top',
                                attrs: {
                                    circle: {
                                        r: 4,
                                        magnet: true,
                                        stroke: '#5F95FF',
                                        strokeWidth: 1,
                                        fill: '#fff'
                                    }
                                }
                            },
                            bottom: {
                                position: 'bottom',
                                attrs: {
                                    circle: {
                                        r: 4,
                                        magnet: true,
                                        stroke: '#5F95FF',
                                        strokeWidth: 1,
                                        fill: '#fff'
                                    }
                                }
                            }
                        },
                        items: [
                            { group: 'top', id: 'top' },
                            { group: 'bottom', id: 'bottom' }
                        ]
                    },
                    data: {
                        type: config.type,
                        layer: config.layer
                    }
                })
                
                testNodes.push(node)
            })
            
            // åˆ›å»ºè¿æ¥å…³ç³»
            const connections = [
                // ç¬¬ä¸€å±‚åˆ°ç¬¬äºŒå±‚
                { source: 'start', target: 'condition1' },
                
                // ç¬¬äºŒå±‚åˆ°ç¬¬ä¸‰å±‚
                { source: 'condition1', target: 'process1' },
                { source: 'condition1', target: 'process2' },
                { source: 'condition1', target: 'process3' },
                
                // ç¬¬ä¸‰å±‚åˆ°ç¬¬å››å±‚
                { source: 'process1', target: 'sub1' },
                { source: 'process1', target: 'sub2' },
                { source: 'process2', target: 'sub3' },
                { source: 'process2', target: 'sub4' },
                { source: 'process3', target: 'sub5' },
                { source: 'process3', target: 'sub6' },
                
                // ç¬¬å››å±‚åˆ°ç¬¬äº”å±‚
                { source: 'sub1', target: 'end1' },
                { source: 'sub1', target: 'end2' },
                { source: 'sub2', target: 'end3' },
                { source: 'sub3', target: 'end4' },
                { source: 'sub4', target: 'end5' },
                { source: 'sub5', target: 'end6' },
                { source: 'sub6', target: 'end7' },
                { source: 'sub6', target: 'end8' }
            ]
            
            // åˆ›å»ºè¿çº¿
            connections.forEach(conn => {
                const edge = graph.addEdge({
                    source: { cell: conn.source, port: 'bottom' },
                    target: { cell: conn.target, port: 'top' },
                    attrs: {
                        line: {
                            stroke: '#A2B1C3',
                            strokeWidth: 2,
                            targetMarker: {
                                name: 'block',
                                width: 8,
                                height: 6
                            }
                        }
                    },
                    router: {
                        name: 'orth',
                        args: {
                            padding: 10
                        }
                    }
                })
                
                testEdges.push(edge)
            })
            
            // å±…ä¸­æ˜¾ç¤º
            graph.centerContent()
            
            addLog(`âœ… æµ‹è¯•æµç¨‹åˆ›å»ºå®Œæˆ: ${testNodes.length} ä¸ªèŠ‚ç‚¹, ${testEdges.length} æ¡è¿çº¿`, 'success')
            updateStats()
        }
        
        // åº”ç”¨è‡ªåº•å‘ä¸Šå¸ƒå±€
        window.applyBottomUpLayout = async function() {
            if (!graph || testNodes.length === 0) {
                addLog('âŒ è¯·å…ˆåˆ›å»ºæµ‹è¯•æµç¨‹', 'error')
                return
            }
            
            addLog('ğŸš€ å¼€å§‹åº”ç”¨è‡ªåº•å‘ä¸Šå¸ƒå±€ä¼˜åŒ–...', 'info')
            
            try {
                // æ¨¡æ‹Ÿè‡ªåº•å‘ä¸Šå¸ƒå±€ä¼˜åŒ–å™¨çš„é€»è¾‘
                const layers = groupNodesByLayer()
                addLog(`ğŸ“Š æ£€æµ‹åˆ° ${layers.length} ä¸ªå±‚çº§`, 'info')
                
                // ä»æœ€åº•å±‚å¼€å§‹ä¼˜åŒ–
                for (let i = layers.length - 1; i >= 0; i--) {
                    const layer = layers[i]
                    addLog(`ğŸ”§ ä¼˜åŒ–ç¬¬ ${i} å±‚ (${layer.length} ä¸ªèŠ‚ç‚¹)`, 'info')
                    
                    if (layer.length > 1) {
                        // è®¡ç®—è¯¥å±‚èŠ‚ç‚¹çš„æœ€ä¼˜åˆ†å¸ƒ
                        const totalWidth = (layer.length - 1) * 120 // èŠ‚ç‚¹é—´è·
                        const centerX = 400 // ç”»å¸ƒä¸­å¿ƒ
                        const startX = centerX - totalWidth / 2
                        
                        layer.forEach((node, index) => {
                            const newX = startX + index * 120
                            const currentPos = node.getPosition()
                            
                            // å¹³æ»‘ç§»åŠ¨åˆ°æ–°ä½ç½®
                            animateNodeToPosition(node, { x: newX - 50, y: currentPos.y })
                        })
                        
                        // ç­‰å¾…åŠ¨ç”»å®Œæˆ
                        await new Promise(resolve => setTimeout(resolve, 500))
                    }
                }
                
                // é‡æ–°è·¯ç”±æ‰€æœ‰è¿çº¿
                testEdges.forEach(edge => {
                    edge.setVertices([])
                    edge.setRouter({
                        name: 'orth',
                        args: {
                            padding: 15,
                            step: 10
                        }
                    })
                })
                
                addLog('âœ… è‡ªåº•å‘ä¸Šå¸ƒå±€ä¼˜åŒ–å®Œæˆ', 'success')
                updateStats()
                
            } catch (error) {
                addLog(`âŒ å¸ƒå±€ä¼˜åŒ–å¤±è´¥: ${error.message}`, 'error')
            }
        }
        
        // åº”ç”¨æ™®é€šå¸ƒå±€ï¼ˆå¯¹æ¯”ç”¨ï¼‰
        window.applyNormalLayout = function() {
            if (!graph || testNodes.length === 0) {
                addLog('âŒ è¯·å…ˆåˆ›å»ºæµ‹è¯•æµç¨‹', 'error')
                return
            }
            
            addLog('ğŸ”§ åº”ç”¨æ™®é€šå¸ƒå±€...', 'info')
            
            // ç®€å•çš„ä»ä¸Šåˆ°ä¸‹å¸ƒå±€
            const layers = groupNodesByLayer()
            
            layers.forEach((layer, layerIndex) => {
                const y = 50 + layerIndex * 100
                const totalWidth = (layer.length - 1) * 150
                const centerX = 400
                const startX = centerX - totalWidth / 2
                
                layer.forEach((node, index) => {
                    const newX = startX + index * 150
                    animateNodeToPosition(node, { x: newX - 50, y: y - 15 })
                })
            })
            
            // é‡æ–°è·¯ç”±è¿çº¿
            setTimeout(() => {
                testEdges.forEach(edge => {
                    edge.setVertices([])
                    edge.setRouter({
                        name: 'orth',
                        args: {
                            padding: 10
                        }
                    })
                })
            }, 600)
            
            addLog('âœ… æ™®é€šå¸ƒå±€åº”ç”¨å®Œæˆ', 'success')
        }
        
        // æ¸…ç©ºç”»å¸ƒ
        window.clearCanvas = function() {
            if (graph) {
                graph.clearCells()
                testNodes = []
                testEdges = []
                addLog('ğŸ—‘ï¸ ç”»å¸ƒå·²æ¸…ç©º', 'info')
                updateStats()
            }
        }
        
        // æ¸…ç©ºæ—¥å¿—
        window.clearLogs = function() {
            document.getElementById('logs').innerHTML = ''
        }
        
        // è¾…åŠ©å‡½æ•°
        function groupNodesByLayer() {
            const layers = {}
            testNodes.forEach(node => {
                const layer = node.getData().layer || 0
                if (!layers[layer]) {
                    layers[layer] = []
                }
                layers[layer].push(node)
            })
            
            return Object.keys(layers).sort((a, b) => a - b).map(key => layers[key])
        }
        
        function animateNodeToPosition(node, targetPos) {
            const currentPos = node.getPosition()
            const duration = 500
            const startTime = Date.now()
            
            function animate() {
                const elapsed = Date.now() - startTime
                const progress = Math.min(elapsed / duration, 1)
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                const easeProgress = 1 - Math.pow(1 - progress, 3)
                
                const x = currentPos.x + (targetPos.x - currentPos.x) * easeProgress
                const y = currentPos.y + (targetPos.y - currentPos.y) * easeProgress
                
                node.setPosition({ x, y })
                
                if (progress < 1) {
                    requestAnimationFrame(animate)
                }
            }
            
            animate()
        }
        
        function getNodeColor(type) {
            const colors = {
                start: '#28a745',
                end: '#dc3545',
                condition: '#ffc107',
                process: '#007bff'
            }
            return colors[type] || '#6c757d'
        }
        
        function getNodeFillColor(type) {
            const colors = {
                start: '#d4edda',
                end: '#f8d7da',
                condition: '#fff3cd',
                process: '#d1ecf1'
            }
            return colors[type] || '#e9ecef'
        }
        
        function addLog(message, type = 'info') {
            const logs = document.getElementById('logs')
            const entry = document.createElement('div')
            entry.className = `log-entry log-${type}`
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`
            logs.appendChild(entry)
            logs.scrollTop = logs.scrollHeight
        }
        
        function updateStats() {
            const stats = document.getElementById('stats')
            const layers = groupNodesByLayer()
            
            const layerStats = layers.map((layer, index) => ({
                layer: index,
                count: layer.length,
                spread: layer.length > 1 ? Math.max(...layer.map(n => n.getPosition().x)) - Math.min(...layer.map(n => n.getPosition().x)) : 0
            }))
            
            stats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-title">æ€»èŠ‚ç‚¹æ•°</div>
                    <div class="stat-value">${testNodes.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">æ€»è¿çº¿æ•°</div>
                    <div class="stat-value">${testEdges.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">å±‚çº§æ•°</div>
                    <div class="stat-value">${layers.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">æœ€å¤§å±‚å®½åº¦</div>
                    <div class="stat-value">${Math.max(...layerStats.map(s => s.spread)).toFixed(0)}px</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">æœ€å¤šèŠ‚ç‚¹å±‚</div>
                    <div class="stat-value">ç¬¬${layerStats.reduce((max, curr) => curr.count > max.count ? curr : max, {count: 0, layer: 0}).layer}å±‚ (${Math.max(...layerStats.map(s => s.count))}ä¸ª)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">å¸ƒå±€è´¨é‡</div>
                    <div class="stat-value">${layerStats.every(s => s.spread < 800) ? 'è‰¯å¥½' : 'éœ€ä¼˜åŒ–'}</div>
                </div>
            `
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initGraph()
            addLog('ğŸ¯ è‡ªåº•å‘ä¸Šå¸ƒå±€ä¼˜åŒ–å™¨æµ‹è¯•é¡µé¢å·²å°±ç»ª', 'success')
        })
        
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è°ƒæ•´ç”»å¸ƒ
        window.addEventListener('resize', function() {
            if (graph) {
                const container = document.getElementById('canvas-container')
                graph.resize(container.offsetWidth, container.offsetHeight)
            }
        })
    </script>
</body>
</html>